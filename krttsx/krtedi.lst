KRTEDI	SL editor	MACRO V05.03b  00:01
Table of contents

    3-   1	KRTMAC	Various handy constants and macros
    5-   2	Utility macros
    7-   2	Local data
    8-   3	SL editor main loop	; /BBS/ minor mods..
    9-   2	Process escape sequence	; /BBS/ minor mods..
   10-   2	Ring the bell		; /BBS/ replaces noop
   11-   2	PF2, Help		; /BBS/ added..
   12-   2	Post-PF1 processor	; /BBS/ all new
   13-   2	Two ways to undel a char  ; /BBS/ all new
   14-   2	Insert a char		; /BBS/ cleaned up
   15-   2	Move to start of line (Keypad 0)
   16-   2	Move to end of line (Keypad 2)
   17-   2	Move cursor one word	; /BBS/ all new
   18-   2	Move cursor one char	; /BBS/ added
   19-   2	Move right one char
   20-   2	Move left one char
   21-   2	Set advance mode	; /BBS/ added
   22-   2	Set backup mode		; /BBS/ added
   23-   2	Process ^C, ^Z		; /BBS/ fixed up..
   24-   2	Process CR, store command line	; /BBS/ fixed up..
   25-   2	Recall a command	; /BBS/ some changes..
   26-   2	Up-arrow key		; /BBS/ some changes..
   27-   2	Recover a command line	; /BBS/ made this a subroutine
   28-   2	Process ^U		; /BBS/ all new
   29-   2	Keypad minus		; /BBS/ all new..
   30-   2	Line feed		; /BBS/ all new
   31-   2	Write buffers		; /BBS/ for the above two routines
   32-   2	Un-do PF4, keypad comma	; /BBS/ all new
   33-   2	Un-do ^U, line feed	; /BBS/ all new
   34-   2	Process PF4		; /BBS/ all new
   35-   2	Erase char under cursor	; /BBS/ all new
   36-   2	Erase char to left of cursor  ; /BBS/ fixed up..
   37-   2	Process ^R		; /BBS/ minor clean up
   38-   2	Toggle insert/overstrike mode
   39-   1	Save cursor then clear to EOL	; /BBS/ added
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 1


      1						.title	KRTEDI	SL editor
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	fixed all possible sign extension problems now the LN$MAX > 127.
      7					;	but keep it under 255. or you'll have to fix some other stuff!!
      8
      9					; /62/	27-Jul-93  Billy Youdelman  V03.62
     10					;
     11					;	add bells: up arrow when nothing saved yet, down arrow at end
     12
     13					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     14					;
     15					;	up/dn arrow command scrolling fixed
     16					;	command dispatch table patched for VT-100 keypad (KED equivs)
     17					;	dup cmds now not saved even when < max cmds are currently stored
     18					;	extended keypad for adv, bkup, word, char, line, delete, undelete
     19					;	added check for SS3 for VT-220 keypad
     20					;	cleaned up various odds and ends..
     21					;	WARNING:  If LN$MAX is made greater than 127., fix sxt stuff here
     22
     23					;	18-Jul-86  12:00:29  Brian Nelson
     24
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 2


      1
      2						.include "IN:KRTMAC.MAC"
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 3
KRTMAC	Various handy constants and macros

      1						.sbttl	KRTMAC	Various handy constants and macros
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	add support for SET ATTRIBUTES
      7					;	add flag to suspend logging to a disk file
      8					;	make $LN$MAX 132. bytes for EIS assembly
      9					;	pulled message macro, no longer used..
     10
     11					; /62/	27-Jul-93  Billy Youdelman  V03.62
     12					;
     13					;	move dispatch macro to KRTSER
     14					;	move erbfsiz here from KRTPAK
     15					;	condense logging (debug) modes
     16					;	increase efficiency of incm64 macro
     17					;	increase MAXLNG (long-packet size) to 1920.
     18					;	reduce MAXLNG to 600. for NONEIS assembly, so pgm loads under FB..
     19					;	ditto for ALSIZE (phone # buffer) and LN$CNT (SL # of lines saved)
     20
     21					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     22					;
     23					;	modified message macro to call .newline instead of saving CR/LF
     24					;	and null for each new line, knocking 1042. bytes off the size
     25					;	of this version..  also changed ".print" emulation to wrtall,
     26					;	for a similar savings in compiled program size.
     27					;
     28					;	dump raw I/O logging from log$al (SET DEB ALL) - too confusing
     29					;	also pulled log$rp out and made it a completely separate item..
     30					;
     31					;	added a couple upper case macros
     32
     33					;	include file for Kermit-11
     34					;
     35					;	Brian Nelson  01-Dec-83  13:56:12
     36
     37						.NLIST	BEX
     38						.LIST	MEB			; /62/
     39
     40		000001 				KRTINC	=	1		; for .include error checking
     41
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 4
KRTMAC	Various handy constants and macros

      1
      2	000000					.psect	$code	,ro,i,lcl,rel,con ; psect ordering..
      3	000000					.psect	$pdata	,ro,d,lcl,rel,con
      4
      5					;	various ascii chars
      6		000001 				SOH	=   1		; default packet start of header
      7		000007 				BELL	=   7		; beep
      8		000010 				BS	=  10		; backspace
      9		000011 				TAB	=  11		; tab
     10		000012 				LF	=  12		; line feed
     11		000014 				FF	=  14		; form feed
     12		000015 				CR	=  15		; carriage return
     13		000016 				CTRL$N	=  16		; ^N VT-100 line drawing on
     14		000017 				CTRL$O	=  17		; ^O VT-100 line drawing off
     15		000021 				XON	=  'Q&37	; ^Q
     16		000023 				XOFF	=  'S&37	; ^S
     17		000033 				ESC	=  33		; escape
     18		000040 				SPACE	=  40
     19		000054 				COMMA	=  54
     20		000056 				DOT	=  56		; /63/
     21		000073 				SCOLON	=  73		; /63/
     22		000176 				TILDE	= 176		; /63/
     23		000177 				DEL	= 177		; delete
     24
     25					;	system data locations
     26		000044 				JSW	= 44		; job status word
     27		000052 				ERRBYT	= 52		; emt error byte
     28		000053 				USERRB	= 53		; /62/ user error byte
     29		000001 					SUCCS$	=  1	; no error
     30		000002 					WARN$	=  2	; warning
     31		000004 					ERROR$	=  4	; error
     32		000010 					SEVER$	= 10	; sever error
     33		000020 					FATAL$	= 20	; fatal error
     34
     35					;	byte offsets into SINIT parameter vector
     36		000000 				P.SPSIZ	= 0		; set packet length
     37		000001 				P.TIME	= 1		; time-out
     38		000002 				P.NPAD	= 2		; number of pad chars
     39		000003 				P.PADC	= 3		; the pad character
     40		000004 				P.EOL	= 4		; eol char
     41		000005 				P.QCTL	= 5		; control char quoting
     42		000006 				P.QBIN	= 6		; 8-bit quote
     43		000007 				P.CHKT	= 7		; checksum type
     44		000010 				P.REPT	= 10		; repeated character prefix
     45		000011 				P.CAPAS	= 11		; capability bitmask
     46		000010 					CAPA.A	= 10	; attribute handling
     47		000002 					CAPA.L	= 2	; /42/ long packets
     48		000004 					CAPA.S	= 4	; /42/ sliding windows
     49		000012 				P.WINDS	= 12		; /43/ window size, # of packets
     50		000013 				P.MXL1	= 13		; /43/ high order of long packet size
     51		000014 				P.MXL2	= 14		; /43/ low order of long packet size
     52		000017 				P.VEND	= 17		; end of parameter vector
     53
     54					; /62/	bits in doattr (file attribute processing)
     55		000001 				AT.CDT	=: 1		; create date
     56		000002 				AT.INF	=: 2		; /63/ system specific info
     57		000004 				AT.LEN	=: 4		; length
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 4-1
KRTMAC	Various handy constants and macros

     58		000010 				AT.PRO	=: 10		; file protection
     59		000020 				AT.SYS	=: 20		; system ID
     60		000040 				AT.TYP	=: 40		; file type
     61		000100 				AT.XLE	=: 100		; exact length in bytes
     62		100000 				AT.ON	=: 100000	; /63/ do attribute processing
     63		000177 				AT.ALL	=: AT.CDT!AT.INF!AT.LEN!AT.PRO!AT.SYS!AT.TYP!AT.XLE
     64
     65					;	bits in trace (debug status word)
     66		000001 				LOG$PA	= 1		; log all packets
     67		000002 				LOG$CO	= 2		; /62/ CONNECT logging to disk
     68		000004 				LOG$RP	= 4		; /62/ rpack chars to TT
     69		000010 				LOG$IO	= 10		; /62/ everything received or sent
     70		000020 				LOG$DE	= 20		; /62/ debugging to TT
     71		040000 				LOG$ON	= 40000		; /63/ set to write to disk, clear to suspend
     72		100000 				LOG$OP	= 100000	; logfile is open
     73		000003 				LOG$AL	= LOG$PA!LOG$CO	; /62/ ALL
     74
     75					;	parity options
     76		000000 				PAR$NO	=: 0		; none
     77		000001 				PAR$OD	=: 1		; odd
     78		000002 				PAR$EV	=: 2		; even
     79		000003 				PAR$MA	=: 3		; mark
     80		000004 				PAR$SP	=: 4		; space
     81
     82					;	file types
     83		177777 				TERMINAL=: -1		; file to term ala xreply, not to disk
     84		000000 				TEXT	=:  0		; normal ascii text files
     85		000001 				BINARY	=:  1		; image mode
     86		000002 				DECNAT	=:  2		; /52/ 8-bit text files
     87
     88					;	terminal types
     89		000000 				NOSCOPE	= 0		; /BBS/ hard copy terminal
     90		000001 				TTY	= 1		; a dumb tube terminal
     91		000002 				VT100	= 2		; itself
     92		000003 				VT200	= 3		; ditto..
     93
     94					;	supported CVT$$ cvt_bit_pattern bits
     95		000004 				C.CRLF	= 4		; discard CR LF FF ESC
     96		000010 				C.LSPA	= 10		; discard leading spaces and tabs
     97		000020 				C.SSPA	= 20		; reduce spaces and tabs to a single space
     98		000040 				C.LCUC	= 40		; lower case to upper case
     99		000200 				C.TSPA	= 200		; discard trailing spaces and tabs
    100
    101		000034 				CON$ESC	=  '\-100	; default CONNECT escape char
    102		000170 				ERBFSIZ	=  120.		; /62/ error msg text buff size
    103		000136 				MAXPAK	=:  94.		; /63/ max_packet_length - max_checksum_length
    104
    105						.if df	NONEIS		; /62/ using NONEIS for convenience..
    106						ALSIZE	=   1000	; /63/ bufsiz for SET DIAL/PHO NUM
    107						LN$CNT	=      3.	; /62/ save/recall 3. commands
    108						LN$MAX	=     80.	; /63/ max command line length
    109						MAXLNG	=    600.	; /63/ so image is small enuff to run
    110						.iff
    111		002000 				ALSIZE	=   2000	; /62/ bufsiz for SET DIAL/PHO NUM
    112		000012 				LN$CNT	=     10.	; /63/ save/recall 10. commands
    113		000204 				LN$MAX	=    132.	; /63/ max command line length
    114		003600 				MAXLNG	=   1920.	; /63/ use max long-packet buff size
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 4-2
KRTMAC	Various handy constants and macros

    115						.endc
    116		003614 				$ALLSIZ	= <MAXLNG+14>&177776 ; /62/ make it this for safety
    117
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 5
KRTMAC	Various handy constants and macros

      1
      2						.sbttl	Utility macros
      3
      4						.macro	.br to		; /63/ added
      5						.if df	to
      6						.if ne	to-.
      7						.error	<; not at location to;>
      8						.endc
      9						.endc
     10						.endm	.br
     11
     12						.macro	.chksp	arg
     13						.ntype	$$5	,arg
     14						.iif eq <<$$5&7>-6> .error arg <; Illegal use of SP (r6) in call>
     15						.endm	.chksp
     16
     17						.macro	calls	name	,arglst
     18					;	subroutine call with arguments passed in an area pointed to by r5
     19					;	(as with F4 and BP2).  all args are pushed onto the stack in the
     20					;	order specified.  r5 points to the sp before the call and is saved
     21					;	and restored.
     22						$$ = 0				; init # of args count
     23						  .irp x ,<arglst>		; count up # of args passed
     24						  $$ = $$+1			; one at a time
     25						  .endr				; got it
     26						.if eq $$			; no args present?
     27						jsr	pc	,name		; if so, substitute a simple call
     28						.iff				; at least one arg in <arglst>
     29						mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
     30						  .if eq $$-1			; is it one or more than one arg?
     31						  .chksp	arglst		; one arg, check for legal SP modes
     32						  mov	arglst	,-(sp)		; doing it thusly generates less code
     33						  mov	sp	,r5		; set pointer to argument list
     34						  jsr	pc	,name		; call the subroutine
     35						  tst	(sp)+			; pop parameter list from stack
     36						  mov	(sp)+	,r5		; /63/ restore r5
     37						  .iff				; arg_count > 1
     38						  $$2 = $$			; extract the args in
     39						    .rept	$$		; reverse order so that
     40						    $$1 = 0			; we might save a little
     41						      .irp x ,<arglst>		; core (four words)
     42						      $$1 = $$1+1		; scan the arg list until we come to
     43						        .if eq $$2-$$1		; the last one before one we just did
     44						        .chksp	x		; check for SP addressing mode
     45						        mov	x	,-(sp)	; push it
     46						        .mexit			; and exit the .irp
     47						        .endc
     48						      .endr
     49						    $$2 = $$2-1			; backwards to previous arg
     50						    .endr
     51						  mov	sp	,r5		; set up the argument list pointer
     52						  jsr	pc	,name		; and go to the routine
     53						  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
     54						  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
     55						  mov	(sp)+	,r5		; /63/ restore r5
     56						  .endc
     57						.endc
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 5-1
Utility macros

     58						.endm	calls
     59
     60						.macro	ctl	src ,dst
     61						clr	-(sp)
     62						bisb	src	,@sp
     63						call	l$xor
     64						movb	(sp)+	,dst
     65						.endm	ctl
     66
     67						.macro	copyz	from ,to ,maxlen
     68						.if  b	<maxlen>
     69						clr	-(sp)
     70						.iff
     71						mov	maxlen	,-(sp)
     72						.endc
     73						mov	from	,-(sp)
     74						mov	to	,-(sp)
     75						call	copyz$
     76						.endm	copyz
     77
     78						.macro	deccvt	val ,buf ,width
     79						mov	r5	,-(sp)
     80						.if  b	<width>
     81						clr	-(sp)
     82						.iff
     83						mov	width	,-(sp)
     84						.endc
     85						mov	val	,-(sp)
     86						mov	buf	,-(sp)
     87						mov	sp	,r5
     88						call	l$cvtnum
     89						add	#6	,sp
     90						mov	(sp)+	,r5
     91						.endm	deccvt
     92
     93						.macro	decout	val
     94						mov	r5	,-(sp)
     95						mov	val	,-(sp)		; /62/ l$wrdec pops this buffer
     96						mov	sp	,r5
     97						call	l$wrdec
     98						mov	(sp)+	,r5
     99						.endm	decout
    100
    101						.macro	direrr	val
    102						mov	val	,-(sp)
    103						call	direr$
    104						.endm	direrr
    105
    106						.macro	incm64	val
    107						inc	val
    108						bic	#^c<77>	,val		; /62/ faster
    109						.endm	incm64
    110
    111						.macro	indexm	reg		; check for auto increment/decrement
    112						.ntype	$$$0	,reg		; modes for macros that can't have..
    113						.if  ne	$$$0-27			; always allow pc autoincrement
    114						$$$0 =	<$$$0&177770>/10	; ..these modes in their arg list
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 5-2
Utility macros

    115						.ift				; get the mode into 0..7
    116						  .if  ge $$$0-2		; if mode >=2 and mode <=5 then error
    117						  .iif ge <5-$$$0> .error      <; Can't use auto inc/dec mode here>
    118						  .endc
    119						.endc
    120						.endm	indexm
    121
    122						.macro	ixor	reg ,dst
    123					;	get around the mode restrictions for the hardware XOR instruction
    124					;	and fix for RT-11 systems that don't have the EIS chip option
    125						.chksp	reg			; can't allow sp args
    126						.chksp	dst			; in either register
    127						indexm	reg			; check for allowed
    128						indexm	dst			; addressing mode
    129						mov	reg	,-(sp)		; it's much simpler to do this
    130						bic	dst	,@sp		; for all RT-11 systems rather
    131						bic	reg	,dst		; than to be selective
    132						bis	(sp)+	,dst		; done
    133						.endm	ixor
    134
    135						.macro	.newline		; print CR/LF on TT
    136						call	l$pcrlf
    137						.endm	.newline
    138
    139						.macro	octout	val
    140						calls	l$wroct	,<val>
    141						.endm	octout
    142
    143						.macro	prsbuf	dst
    144						mov	dst	,r0
    145						call	prsarg
    146						.endm	prsbuf
    147
    148						.macro	rpack	len.a ,pakn.a ,msg.a ,max.len	; /62/
    149						sub	#10	,sp
    150						mov	sp	,r1
    151						calls	rpack$	,<msg.a,r1,max.len>
    152						mov	(r1)+	,len.a
    153						mov	(r1)+	,pakn.a
    154						mov	@r1	,r1
    155						add	#10	,sp
    156						.endm	rpack
    157
    158						.macro	save	list
    159						.if  b	<list>
    160						 save	<r0,r1,r2,r3,r4,r5>
    161						.iff
    162						.irp	x ,<list>
    163						 mov	x	,-(sp)
    164						.endr
    165						.endc
    166						.endm	save
    167
    168						.macro	scan	ch ,str
    169						mov	str	,-(sp)
    170						clr	-(sp)
    171						bisb	ch	,@sp
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 5-3
Utility macros

    172						call	scanch
    173						.endm	scan
    174
    175						.macro	setpar	src ,dst
    176						movb	src	,-(sp)
    177						call	dopari
    178						movb	(sp)+	,dst
    179						.endm	setpar
    180
    181						.macro	spack	type ,pnum ,len ,msg
    182						.if  b	<len>
    183						.iif nb	<msg>	.error	<; bad call to SPACK macro>
    184						calls	spack$	,<type,pnum,#0,#null>
    185						.iff
    186						calls	spack$	,<type,pnum,len,msg>
    187						.endc
    188						.endm	spack
    189
    190						.macro	strcat	dst ,src
    191						mov	src	,-(sp)
    192						mov	dst	,-(sp)
    193						jsr	pc	,strcat
    194						.endm	strcat
    195
    196						.macro	strcpy	dst ,src
    197						mov	src	,-(sp)
    198						mov	dst	,-(sp)
    199						jsr	pc	,strcpy
    200						.endm	strcpy
    201
    202						.macro	strlen	string
    203						mov	string	,r0
    204						call	l$len
    205						.endm	strlen
    206
    207						.macro	textsrc	text
    208						.if  b	<text>
    209						clr	getcroutine		; /62/ reset to file I/O
    210						clr	tgetaddr
    211						.iff
    212						mov	#tgetcr0,getcroutine
    213						mov	text	,tgetaddr
    214						.endc
    215						.endm	textsrc
    216
    217						.macro	tochar	src ,dst
    218						clr	-(sp)
    219						bisb	src	,@sp
    220						add	#40	,@sp
    221						movb	(sp)+	,dst
    222						.endm	tochar
    223
    224						.macro	unchar	src ,dst
    225						clr	-(sp)
    226						bisb	src	,@sp
    227						sub	#40	,@sp
    228						movb	(sp)+	,dst
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 5-4
Utility macros

    229						.endm	unchar
    230
    231						.macro	unsave	list
    232						.if b <list>
    233						unsave	<r5,r4,r3,r2,r1,r0>
    234						.iff
    235						.irp	x ,<list>
    236						 mov	(sp)+	,x
    237						.endr
    238						.endc
    239						.endm	unsave
    240
    241						.macro	upcase	s		; /BBS/ added ..
    242						mov	s	,r0
    243						call	upcase			; /BBS/ upcase until null terminator
    244						.endm	upcase
    245
    246						.macro	upone	s		; /BBS/ added ..
    247						mov	s	,r0
    248						call	upone			; /BBS/ upcase only to next delimiter
    249						.endm	upone
    250
    251						.macro	wrtall	arg		; IO.WAL for an .asciz string
    252						mov	arg	,-(sp)		; pass the address
    253						call	wrtall			; do it
    254						.endm	wrtall
    255
    256						.macro	xor	reg ,dst
    257						ixor	reg	,dst
    258						.endm	xor
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 6
Utility macros

      1						.iif ndf  KRTINC  .error	<; .include for IN:KRTMAC.MAC failed>
      2
      3						; bits used in edists (the editor status word)
      4		000001 				IN$MODE	=	1	; if <> insert mode is on (default)
      5		000002 				UP$MODE	=	2	; down arrow wuz last, going up the list
      6		000004 				DN$MODE	=	4	; up arrow wuz last, going down the list
      7		000010 				UP$END	=	10	; up arrow has just dumped edicmd #0
      8		000020 				FW$MODE	=	20	; if <>, advance mode (default=backup=0)
      9
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 7
Utility macros

      1
      2						.sbttl	Local data
      3
      4	000000					.psect	$pdata
      5	000000	   033 	   133 	   113 	$ceol:	.asciz	<esc>"[K"	; clear from cursor to end of line
      6	000004	   136 	   132 	   015 	$cz:	.asciz	"^Z"<cr><lf>	; to echo ^Z
      7	000011	   033 	   133 	   104 	$left:	.asciz	<esc>"[D"	; move cursor left one column
      8	000015	   033 	   070 	   000 	$resto:	.asciz	<esc>"8"	; restore cursor to previously saved position
      9	000020	   033 	   133 	   103 	$right:	.asciz	<esc>"[C"	; move cursor right one column
     10	000024	   010 	   040 	   010 	$rubout:.byte	bs ,space ,bs ,0 ; echo this for a rubout
     11	000030	   033 	   067 	   000 	$save:	.asciz	<esc>"7"	; save current cursor position
     12	000033	   033 	   075 	   000 	$setvt:	.byte	esc ,'= ,0	; enable VT-100 keypad
     13	000036	   040 	   054 	   056 	delimit:.byte	40 ,54 ,56 ,57 ,72 ,75 ,133 ,0	; word delimiters (tab unused)
     14	000046	   077 	   113 	   122 	edi.01:	.asciz	"?KRTEDI-W-Can't overlay HELP from here"<cr><lf> ; /63/
     15	000117	   123 	   114 	   040 	edi.02:	.asciz	"SL F"		; /63/ display SL Function keys topic
     16	000124	   123 	   114 	   040 	edi.03:	.asciz	"SL K"		; /63/ or do KED version if KED mode is on
     17						.even
     18
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 8
Local data

      1
      2	000000					.psect	$code
      3						.sbttl	SL editor main loop	; /BBS/ minor mods..
      4
      5					;	 (r5)	= the prompt string
      6					;	2(r5)	= buffer in which to return input string
      7					;	  r1	= length of string returned in 2(r5)
      8					;	  r0	= if <>, the error code
      9
     10	000000				kbredi::save	<r2,r3,r4>
	000000	010246 				 mov	r2	,-(sp)
	000002	010346 				 mov	r3	,-(sp)
	000004	010446 				 mov	r4	,-(sp)
     11	000006	005767 	000000G			tst	sl.on			; is SL on?
     12	000012	001014 				bne	10$			; ya
     13	000014					wrtall	@r5			; no, prompt and
	000014	011546 				mov	@r5	,-(sp)		; pass the address
	000016	004767 	000000G			call	wrtall			; do it
     14	000022					calls	kbread	,<2(r5)>	; do hardcopy ttin
	000022	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000024	016546 	000002 			  mov	2(r5)	,-(sp)		; doing it thusly generates less code
	000030	010605 				  mov	sp	,r5		; set pointer to argument list
	000032	004767 	000000G			  jsr	pc	,kbread		; call the subroutine
	000036	005726 				  tst	(sp)+			; pop parameter list from stack
	000040	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     15	000042	000462 				br	70$			; done
     16
     17	000044	004767 	000000G		10$:	call	l$nolf			; just a return
     18	000050					wrtall	@r5			; print the prompt
	000050	011546 				mov	@r5	,-(sp)		; pass the address
	000052	004767 	000000G			call	wrtall			; do it
     19	000056	005767 	000000G			tst	sl.ked			; KED mode on?
     20	000062	001404 				beq	20$			; no
     21	000064					wrtall	#$setvt			; ya, force keypad to application mode
	000064	012746 	000033'			mov	#$setvt	,-(sp)		; pass the address
	000070	004767 	000000G			call	wrtall			; do it
     22	000074	005067 	000000G		20$:	clr	edipos			; cursor is at start of the line
     23	000100	005067 	000000G			clr	edilen			; length=0
     24	000104	016504 	000002 			mov	2(r5)	,r4		; buffer address
     25	000110	105014 				clrb	@r4			; ensure starting with .asciz
     26	000112	004767 	000000G		30$:	call	read1ch			; get one char from the keyboard
     27	000116	010003 				mov	r0	,r3		; save a copy
     28	000120	001430 				beq	60$			; nothing there, treat as a ^Z
     29
     30	000122	005767 	000000G			tst	sl.ked			; KED mode on?
     31	000126	001012 				bne	40$			; ya, dispatch accordingly
     32	000130					scan	r3	,#scanlst	; no, look for a match
	000130	012746 	000132'			mov	#scanlst	,-(sp)
	000134	005046 				clr	-(sp)
	000136	150316 				bisb	r3	,@sp
	000140	004767 	000000G			call	scanch
     33	000144	006300 				asl	r0			; word indexing
     34	000146	004770 	000154'			jsr	pc	,@scandsp(r0)	; dispatch
     35	000152	000411 				br	50$			; skip past KED code
     36	000154				40$:	scan	r3	,#kedlst	; look for a match
	000154	012746 	000220'			mov	#kedlst	,-(sp)
	000160	005046 				clr	-(sp)
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 8-1
SL editor main loop	; /BBS/ minor mods..

	000162	150316 				bisb	r3	,@sp
	000164	004767 	000000G			call	scanch
     37	000170	006300 				asl	r0			; word indexing
     38	000172	004770 	000236'			jsr	pc	,@keddsp(r0)	; dispatch
     39	000176	103745 			50$:	bcs	30$			; not done yet
     40	000200	000403 				br	70$			; done
     41
     42	000202	012700 	000000G		60$:	mov	#er$eof	,r0		; error, return end-of-file
     43	000206	005001 				clr	r1			; length=0
     44	000210				70$:	unsave	<r4,r3,r2>
	000210	012604 				 mov	(sp)+	,r4
	000212	012603 				 mov	(sp)+	,r3
	000214	012602 				 mov	(sp)+	,r2
     45	000216	000207 				return
     46
     47						.save
     48	000132					.psect	$pdata
     49	000132	   001 	   002 	   003 	scanlst:.byte	'A&37	,'B&37	,'C&37	,'D&37	,'E&37	,'F&37	,lf
     50	000141	   015 	   022 	   025 		.byte	cr	,'R&37	,'U&37	,'V&37	,'W&37	,'Z&37	,33
     51	000150	   177 	   217 	   233 		.byte	177	,217	,233
     52	000153	   000 				.byte	0
     53						.even
     54	000154	000662'			scandsp:.word	insch
     55	000156	003456'	002116'	001376'		.word	toggle	,prev	,ctrlc	,left	,prev	,right	,lfproc
     56	000174	001500'	003354'	002344'		.word	done	,retype	,ctrlu	,next	,retype	,eof	,doesc
     57	000212	003226'	000240'	000240'		.word	dorub	,do220	,do220
     58
     59	000220	   003 	   010 	   011 	kedlst:	.byte	'C&37	,'H&37	,'I&37	,lf	,cr	,'R&37
     60	000226	   025 	   032 	   033 		.byte	'U&37	,'Z&37	,33	,177	,217	,233
     61	000234	   000 				.byte	0
     62						.even
     63	000236	000662'			keddsp:	.word	insch
     64	000240	001376'	003226'	003456'		.word	ctrlc	,dorub	,toggle	,lfproc	,done	,retype
     65	000254	002344'	001446'	000220'		.word	ctrlu	,eof	,doesc	,dorub	,do220	,do220
     66	000220					.restore
     67
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 9
SL editor main loop	; /BBS/ minor mods..

      1
      2						.sbttl	Process escape sequence	; /BBS/ minor mods..
      3
      4	000220	004767 	000000G		doesc:	call	read1ch			; get next char in escape sequence
      5	000224	120027 	000133 			cmpb	r0	,#'[		; CSI?
      6	000230	001403 				beq	do220			; ya
      7	000232	120027 	000117 			cmpb	r0	,#'O&137	; from the keypad?
      8	000236	001027 				bne	beep			; struck out..
      9
     10	000240	004767 	000000G		do220:	call	read1ch			; get next char in escape sequence
     11	000244	005767 	000000G			tst	sl.ked			; is SL on?
     12	000250	001011 				bne	10$			; ya
     13	000252					scan	r0	,#esclst	; no, index to process
	000252	012746 	000270'			mov	#esclst	,-(sp)
	000256	005046 				clr	-(sp)
	000260	150016 				bisb	r0	,@sp
	000262	004767 	000000G			call	scanch
     14	000266	006300 				asl	r0			; word indexing
     15	000270	000170 	000300'			jmp	@escdsp(r0)		; /62/ do it
     16	000274				10$:	scan	r0	,#k.lst		; index to process
	000274	012746 	000320'			mov	#k.lst	,-(sp)
	000300	005046 				clr	-(sp)
	000302	150016 				bisb	r0	,@sp
	000304	004767 	000000G			call	scanch
     17	000310	006300 				asl	r0			; word indexing
     18	000312	000170 	000342'			jmp	@k.dsp(r0)		; /62/ do it
     19
     20						.save
     21	000270					.psect	$pdata
     22	000270	   101 	   102 	   103 	esclst:	.byte	'A&137	,'B&137	,'C&137	,'D&137	,'S&137	,'P&137	,'Q&137
     23	000277	   000 				.byte	0
     24						.even
     25	000300	000316'			escdsp:	.word	beep
     26	000302	002116'	001714'	001246'		.word	prev	,next	,right	,left	,pf$4	,pf$1	,pf$2
     27
     28	000320	   101 	   102 	   103 	k.lst:	.byte	'A&137	,'B&137	,'C&137	,'D&137	,'p!40	,'r!40	,'M&137
     29	000327	   161 	   163 	   164 		.byte	'q!40	,'s!40	,'t!40	,'u!40	,'S&137	,'m!40	,'l!40
     30	000336	   120 	   121 			.byte	'P&137	,'Q&137
     31	000340	   000 				.byte	0
     32						.even
     33	000342	000316'			k.dsp:	.word	beep
     34	000344	002116'	001714'	001246'		.word	prev	,next	,right	,left	,sol	,eol	,done
     35	000362	001124'	001236'	001352'		.word	kp$1	,kp$3	,kp$4	,kp$5	,pf$4	,kp$min	,kp$com
     36	000400	000446'	000332'			.word	pf$1	,pf$2
     37	000316					.restore
     38
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 10
Process escape sequence	; /BBS/ minor mods..

      1
      2						.sbttl	Ring the bell		; /BBS/ replaces noop
      3
      4	000316	012700 	000007 		beep:	mov	#bell	,r0		; load a bell
      5	000322	004767 	000000G			call	writ1char		; ship it to the terminal
      6	000326	000261 				sec				; not done yet
      7	000330	000207 				return
      8
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 11
Ring the bell		; /BBS/ replaces noop

      1
      2						.sbttl	PF2, Help		; /BBS/ added..
      3
      4	000332	005767 	000000G		pf$2:	tst	pf2$ok			; could doing this destroy an overlay?
      5	000336	001413 				beq	10$			; no
      6	000340	004767 	000000G			call	l$nolf			; possibly..  goto column 1
      7	000344					wrtall	#$ceol			; hose the line
	000344	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	000350	004767 	000000G			call	wrtall			; do it
      8	000354					wrtall	#edi.01			; /63/ "Can't overlay HELP from here"
	000354	012746 	000046'			mov	#edi.01	,-(sp)		; pass the address
	000360	004767 	000000G			call	wrtall			; do it
      9	000364	000424 				br	30$			; and retype the command line
     10
     11	000366	012700 	000117'		10$:	mov	#edi.02	,r0		; preset normal mode
     12	000372	005767 	000000G			tst	sl.ked			; KED mode on?
     13	000376	001402 				beq	20$			; no
     14	000400	012700 	000124'			mov	#edi.03	,r0		; ya, use this help text
     15	000404				20$:	strcpy	argbuf	,r0		; /62/ pass desired topic to HELP
	000404	010046 				mov	r0	,-(sp)
	000406	016746 	000000G			mov	argbuf	,-(sp)
	000412	004767 	000000G			jsr	pc	,strcpy
     16	000416					.newline			; format display
	000416	004767 	000000G			call	l$pcrlf
     17	000422					save	<r5,r4>			; preserve pointers
	000422	010546 				 mov	r5	,-(sp)
	000424	010446 				 mov	r4	,-(sp)
     18	000426	004767 	000000G			call	c$help			; dump the help text to the terminal
     19	000432					unsave	<r4,r5>			; recover pointers
	000432	012604 				 mov	(sp)+	,r4
	000434	012605 				 mov	(sp)+	,r5
     20	000436	004767 	002712 		30$:	call	retype			; then re-display the command line
     21	000442	000261 				sec				; not done yet
     22	000444	000207 				return
     23
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 12
PF2, Help		; /BBS/ added..

      1
      2						.sbttl	Post-PF1 processor	; /BBS/ all new
      3
      4	000446	004767 	000000G		pf$1:	call	read1ch			; get next char
      5	000452	005767 	000000G			tst	sl.ked			; KED mode on?
      6	000456	001011 				bne	10$			; ya
      7	000460					scan	r0	,#pf1lst	; look for a match
	000460	012746 	000404'			mov	#pf1lst	,-(sp)
	000464	005046 				clr	-(sp)
	000466	150016 				bisb	r0	,@sp
	000470	004767 	000000G			call	scanch
      8	000474	006300 				asl	r0			; word indexing
      9	000476	000170 	000416'			jmp	@pf1dsp(r0)		; /62/ dispatch
     10	000502				10$:	scan	r0	,#k1.lst	; look for a match
	000502	012746 	000440'			mov	#k1.lst	,-(sp)
	000506	005046 				clr	-(sp)
	000510	150016 				bisb	r0	,@sp
	000512	004767 	000000G			call	scanch
     11	000516	006300 				asl	r0			; word indexing
     12	000520	000170 	000452'			jmp	@k1.dsp(r0)		; /62/ dispatch
     13
     14						.save
     15	000404					.psect	$pdata
     16	000404	   003 	   012 	   025 	pf1lst:	.byte	'C&37	,lf	,'U&37	,'Z&37
     17	000410	   033 	   177 	   217 		.byte	33	,177	,217	,233
     18	000414	   000 				.byte	0
     19						.even
     20	000416	000316'			pf1dsp:	.word	beep
     21	000420	001376'	002736'	002736'		.word	ctrlc	,.lfproc,.ctrlu	,eof
     22	000430	000524'	000646'	000550'		.word	.doesc	,.dorub	,.do220	,.do220
     23
     24	000440	   003 	   010 	   012 	k1.lst:	.byte	'C&37	,'H&37	,lf	,'U&37	,'Z&37
     25	000445	   033 	   177 	   217 		.byte	33	,177	,217	,233
     26	000451	   000 				.byte	0
     27						.even
     28	000452	000316'			k1.dsp:	.word	beep
     29	000454	001376'	000646'	002736'		.word	ctrlc	,.dorub	,.lfproc,.ctrlu	,eof
     30	000466	000524'	000646'	000550'		.word	.doesc	,.dorub	,.do220	,.do220
     31	000524					.restore
     32
     33	000524	004767 	000000G		.doesc:	call	read1ch			; get next in esc seq
     34	000530	120027 	000133 			cmpb	r0	,#'[		; CSI?
     35	000534	001405 				beq	.do220			; ya
     36	000536	120027 	000117 			cmpb	r0	,#'O&137	; from the keypad?
     37	000542	001402 				beq	.do220			; ya
     38	000544	000167 	177546 			jmp	beep			; struck out..
     39
     40	000550	004767 	000000G		.do220:	call	read1ch			; get next in esc seq
     41	000554	005767 	000000G			tst	sl.ked			; SL on?
     42	000560	001011 				bne	20$			; ya
     43	000562					scan	r0	,#pfxlst	; index to its process
	000562	012746 	000476'			mov	#pfxlst	,-(sp)
	000566	005046 				clr	-(sp)
	000570	150016 				bisb	r0	,@sp
	000572	004767 	000000G			call	scanch
     44	000576	006300 				asl	r0			; word offset
     45	000600	000170 	000502'			jmp	@pfxdsp(r0)		; /62/ dispatch
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 12-1
Post-PF1 processor	; /BBS/ all new

     46	000604				20$:	scan	r0	,#kx.lst	; index to its process
	000604	012746 	000510'			mov	#kx.lst	,-(sp)
	000610	005046 				clr	-(sp)
	000612	150016 				bisb	r0	,@sp
	000614	004767 	000000G			call	scanch
     47	000620	006300 				asl	r0			; word offset
     48	000622	000170 	000516'			jmp	@kx.dsp(r0)		; /62/ dispatch
     49
     50						.save
     51	000476					.psect	$pdata
     52	000476	   123 	   120 		pfxlst:	.byte	'S&137	,'P&137
     53	000500	   000 				.byte	0
     54						.even
     55	000502	000316'			pfxdsp:	.word	beep
     56	000504	002710'	000446'			.word	.pf$4	,pf$1
     57
     58	000510	   123 	   155 	   154 	kx.lst:	.byte	'S&137	,'m!40	,'l!40	,'P&137
     59	000514	   000 				.byte	0
     60						.even
     61	000516	000316'			kx.dsp:	.word	beep
     62	000520	002710'	002710'	000626'		.word	.pf$4	,.kp$min,.kp$com,pf$1
     63	000626					.restore
     64
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 13
Post-PF1 processor	; /BBS/ all new

      1
      2						.sbttl	Two ways to undel a char  ; /BBS/ all new
      3
      4	000626	004767 	000014 		.kp$com:call	.dorub			; undelete the char
      5	000632	005700 				tst	r0			; did it work?  beep loads r0 if not..
      6	000634	001002 				bne	10$			; no, leave cursor alone
      7	000636	004767 	000452 			call	left			; ya, fix the cursor position
      8	000642	000261 			10$:	sec				; not done yet
      9	000644	000207 				return
     10
     11	000646	005003 			.dorub:	clr	r3			; /63/ avoid possible sign extension
     12	000650	156703 	000000G			bisb	undchr	,r3		; /63/ recover char to undelete
     13	000654	001002 				bne	insch			; /63/ there is a char
     14	000656	000167 	177434 			jmp	beep			; nothing has been saved
     15
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 14
Two ways to undel a char  ; /BBS/ all new

      1
      2						.sbttl	Insert a char		; /BBS/ cleaned up
      3
      4	000662	120327 	000040 		insch:	cmpb	r3	,#space		; control characters that get
      5	000666	103404 				blo	10$			; /63/ this far should be ignored..
      6	000670	026727 	000000G	000204 		cmp	edilen	,#ln$max	; too many chars?
      7	000676	103402 				blo	20$			; no
      8	000700	000167 	177412 		10$:	jmp	beep			; ring bell if line is full
      9
     10	000704	016701 	000000G		20$:	mov	edipos	,r1		; get the offset into line
     11	000710	060401 				add	r4	,r1		; where to stuff the data
     12	000712	105711 				tstb	(r1)			; already at end of line?
     13	000714	001013 				bne	30$			; no
     14	000716	110321 				movb	r3	,(r1)+		; ya, add current char to it
     15	000720	105011 				clrb	(r1)			; reterminate
     16	000722	005301 				dec	r1			; back up
     17	000724					wrtall	r1			; echo
	000724	010146 				mov	r1	,-(sp)		; pass the address
	000726	004767 	000000G			call	wrtall			; do it
     18	000732	005267 	000000G			inc	edilen			; line is now one char longer
     19	000736	005267 	000000G			inc	edipos			; cursor is now here
     20	000742	000444 				br	60$			; that's it..
     21
     22	000744	032767 	000001 	000000G	30$:	bit	#in$mode,edists		; insert or overstrike?
     23	000752	001002 				bne	40$			; insert
     24	000754	110321 				movb	r3	,(r1)+		; overstrike
     25	000756	000420 				br	50$			; finish up
     26
     27	000760	162706 	000206 		40$:	sub	#ln$max+2,sp		; a temp buffer
     28	000764	010602 				mov	sp	,r2		; pointer to it
     29	000766					strcpy	r2	,r1		; save from cursor to EOL
	000766	010146 				mov	r1	,-(sp)
	000770	010246 				mov	r2	,-(sp)
	000772	004767 	000000G			jsr	pc	,strcpy
     30	000776	110321 				movb	r3	,(r1)+		; insert the new character
     31	001000					strcpy	r1	,r2		; put the trailing data back in
	001000	010246 				mov	r2	,-(sp)
	001002	010146 				mov	r1	,-(sp)
	001004	004767 	000000G			jsr	pc	,strcpy
     32	001010	062706 	000206 			add	#ln$max+2,sp		; pop buffer
     33	001014	005267 	000000G			inc	edilen			; line is now one char longer
     34	001020				50$:	wrtall	#$save			; save cursor position
	001020	012746 	000030'			mov	#$save	,-(sp)		; pass the address
	001024	004767 	000000G			call	wrtall			; do it
     35	001030	005301 				dec	r1			; back to to the new character
     36	001032					wrtall	r1			; dump the data
	001032	010146 				mov	r1	,-(sp)		; pass the address
	001034	004767 	000000G			call	wrtall			; do it
     37	001040					wrtall	#$restore		; put the cursor back now
	001040	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	001044	004767 	000000G			call	wrtall			; do it
     38	001050	004767 	000172 			call	right			; move over on the display
     39	001054	005000 			60$:	clr	r0			; no error
     40	001056	000261 				sec				; not done yet
     41	001060	000207 				return
     42
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 15
Insert a char		; /BBS/ cleaned up

      1
      2						.sbttl	Move to start of line (Keypad 0)
      3
      4	001062	005767 	000000G		sol:	tst	edipos			; stop at position 0
      5	001066	003403 				ble	10$			; /BBS/ done
      6	001070	004767 	000220 			call	left			; /BBS/ move one column
      7	001074	000772 				br	sol			; and check position
      8	001076	000261 			10$:	sec				; not done yet
      9	001100	000207 				return
     10
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 16
Move to start of line (Keypad 0)

      1
      2						.sbttl	Move to end of line (Keypad 2)
      3
      4	001102	026767 	000000G	000000G	eol:	cmp	edipos	,edilen		; /BBS/ end yet?
      5	001110	103003 				bhis	10$			; yes
      6	001112	004767 	000130 			call	right			; /BBS/ no, move one column
      7	001116	000771 				br	eol			; and check position
      8	001120	000261 			10$:	sec				; not done yet
      9	001122	000207 				return
     10
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 17
Move to end of line (Keypad 2)

      1
      2						.sbttl	Move cursor one word	; /BBS/ all new
      3
      4	001124	016702 	000000G		kp$1:	mov	edists	,r2		; so kp$3 can flip direction at ends
      5	001130	016701 	000000G		loop:	mov	edipos	,r1		; copy of current cursor position
      6	001134	032702 	000020 			bit	#fw$mode,r2		; check direction
      7	001140	001003 				bne	10$			; it's advance
      8	001142	005701 				tst	r1			; backup, any room left?
      9	001144	003432 				ble	30$			; nope
     10	001146	000403 				br	20$			; ya
     11	001150	020167 	000000G		10$:	cmp	r1	,edilen		; advance, any room left?
     12	001154	103026 				bhis	30$			; no
     13	001156	004767 	000054 		20$:	call	kp$3			; ya, move one char
     14	001162	016701 	000000G			mov	edipos	,r1		; refresh pointer
     15	001166	060401 				add	r4	,r1		; point to byte at hand
     16	001170					scan	(r1)	,#delimit	; check for a word delimiter
	001170	012746 	000036'			mov	#delimit	,-(sp)
	001174	005046 				clr	-(sp)
	001176	151116 				bisb	(r1)	,@sp
	001200	004767 	000000G			call	scanch
     17	001204	005700 				tst	r0			; well?
     18	001206	001350 				bne	loop			; found one, keep looking
     19	001210					scan	-1(r1)	,#delimit	; a char, does a delimiter precede it?
	001210	012746 	000036'			mov	#delimit	,-(sp)
	001214	005046 				clr	-(sp)
	001216	156116 	177777 			bisb	-1(r1)	,@sp
	001222	004767 	000000G			call	scanch
     20	001226	005700 				tst	r0			; well?
     21	001230	001737 				beq	loop			; no
     22	001232	000261 			30$:	sec				; ya, but not done yet
     23	001234	000207 				return
     24
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 18
Move cursor one word	; /BBS/ all new

      1
      2						.sbttl	Move cursor one char	; /BBS/ added
      3
      4	001236	032767 	000020 	000000G	kp$3:	bit	#fw$mode,edists		; check current direction
      5	001244	001423 				beq	left			; it's to the left
      6	001246					.br	right			; /63/ or to the right..
      7
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 19
Move cursor one char	; /BBS/ added

      1
      2						.sbttl	Move right one char
      3
      4	001246	026767 	000000G	000000G	right:	cmp	edipos	,edilen		; EOL?
      5	001254	103015 				bhis	10$			; /63/ yes
      6	001256					wrtall	#$right			; no, move cursor
	001256	012746 	000020'			mov	#$right	,-(sp)		; pass the address
	001262	004767 	000000G			call	wrtall			; do it
      7	001266	005267 	000000G			inc	edipos			; cursor is now here
      8	001272	026767 	000000G	000000G		cmp	edipos	,edilen		; /BBS/ EOL now?
      9	001300	103403 				blo	10$			; /63/ no
     10	001302	042767 	000020 	000000G		bic	#fw$mode,edists		; /BBS/ ya, flip direction
     11	001310	000261 			10$:	sec				; not done yet
     12	001312	000207 				return
     13
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 20
Move right one char

      1
      2						.sbttl	Move left one char
      3
      4	001314	005767 	000000G		left:	tst	edipos			; SOL?
      5	001320	003412 				ble	10$			; no
      6	001322					wrtall	#$left			; ya, backup a bit
	001322	012746 	000011'			mov	#$left	,-(sp)		; pass the address
	001326	004767 	000000G			call	wrtall			; do it
      7	001332	005367 	000000G			dec	edipos			; cursor is now here
      8	001336	001003 				bne	10$			; /BBS/ when hitting SOL..
      9	001340	052767 	000020 	000000G		bis	#fw$mode,edists		; /BBS/ ..flip direction
     10	001346	000261 			10$:	sec				; not done yet
     11	001350	000207 				return
     12
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 21
Move left one char

      1
      2						.sbttl	Set advance mode	; /BBS/ added
      3
      4	001352	052767 	000020 	000000G	kp$4:	bis	#fw$mode,edists		; go forward
      5	001360	000261 				sec				; not done yet
      6	001362	000207 				return
      7
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 22
Set advance mode	; /BBS/ added

      1
      2						.sbttl	Set backup mode		; /BBS/ added
      3
      4	001364	042767 	000020 	000000G	kp$5:	bic	#fw$mode,edists		; go backward
      5	001372	000261 				sec				; not done yet
      6	001374	000207 				return
      7
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 23
Set backup mode		; /BBS/ added

      1
      2						.sbttl	Process ^C, ^Z		; /BBS/ fixed up..
      3
      4	001376	004767 	177460 		ctrlc:	call	sol			; move to start of line, clear edipos
      5	001402					wrtall	#$ceol			; erase to EOL
	001402	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	001406	004767 	000000G			call	wrtall			; do it
      6	001412	005067 	000000G			clr	edilen			; init length
      7	001416	105014 				clrb	@r4			; no data left over
      8	001420	005767 	000000G			tst	edicmd			; anything saved yet?
      9	001424	002405 				blt	10$			; nope..
     10	001426	012767 	000012 	000000G		mov	#ln$cnt	,edicmd		; reset cmd recall ptr
     11	001434	005367 	000000G			dec	edicmd			; offset so prev/next work ok
     12	001440	012700 	000000G		10$:	mov	#cmd$ab	,r0		; it's a ^C abort (NOT ^Z)
     13	001444	000410 				br	cz.fin			; /63/ common exit code
     14
     15	001446	004767 	177430 		eof:	call	eol			; do this first
     16	001452					wrtall	#$cz			; echo ^Z
	001452	012746 	000004'			mov	#$cz	,-(sp)		; pass the address
	001456	004767 	000000G			call	wrtall			; do it
     17	001462	012700 	000000G			mov	#cmd$ex	,r0		; flag ^Z exit
     18	001466	042767 	000036 	000000G	cz.fin:	bic	#<up$mode!dn$mode!up$end!fw$mode>,edists  ; clear flags
     19	001474	005001 				clr	r1			; byte_count=0, also clears carry
     20	001476	000207 				return
     21
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 24
Process ^C, ^Z		; /BBS/ fixed up..

      1
      2						.sbttl	Process CR, store command line	; /BBS/ fixed up..
      3
      4	001500	104340 			done:	emt	340			; eat possible LF after CR
      5	001502					.newline			; kickoff the command..
	001502	004767 	000000G			call	l$pcrlf
      6	001506	005767 	000000G			tst	edilen			; anything to do?
      7	001512	001471 				beq	110$			; no
      8
      9	001514	005002 				clr	r2			; ya, init index
     10	001516	012703 	000012 			mov	#ln$cnt	,r3		; number of lines to do
     11	001522	016200 	000000G		10$:	mov	lastli(r2),r0		; look for a free spot
     12	001526	105710 				tstb	@r0			; empty?
     13	001530	001005 				bne	20$			; nope..
     14	001532	005702 				tst	r2			; iz it the very first one?
     15	001534	001447 				beq	90$			; ya, thus nothing to scroll
     16	001536	010203 				mov	r2	,r3		; no, put pointer in right spot
     17	001540	006203 				asr	r3			; only scroll this many lines
     18	001542	000406 				br	30$			; instead of them all
     19	001544	062702 	000002 		20$:	add	#2	,r2		; bump to next line and..
     20	001550	077314 				sob	r3	,10$		; ..keep looking, until..
     21	001552	005002 				clr	r2			; ..all lines are in use
     22	001554	012703 	000012 			mov	#ln$cnt	,r3		; so do them all..
     23
     24	001560	010446 			30$:	mov	r4	,-(sp)		; save pointer to top of buffer
     25	001562	005303 				dec	r3			; bump to line to test
     26	001564	006303 				asl	r3			; word indexing
     27	001566	016301 	000000G			mov	lastli(r3),r1		; this is its current address
     28	001572	016700 	000000G			mov	edilen	,r0		; length of string just typed in
     29	001576	122100 				cmpb	(r1)+	,r0		; is it same as stored string?
     30	001600	001003 				bne	50$			; no
     31	001602	122421 			40$:	cmpb	(r4)+	,(r1)+		; ya, check for string equality
     32	001604	001001 				bne	50$			; not the same
     33	001606	077003 				sob	r0	,40$		; same, check next byte
     34	001610	012604 			50$:	mov	(sp)+	,r4		; restore pointer to top of buffer
     35	001612	006203 				asr	r3			; restore index
     36	001614	005700 				tst	r0			; did strings match?
     37	001616	001003 				bne	60$			; no
     38	001620	010367 	000000G			mov	r3	,edicmd		; yes, save index
     39	001624	000424 				br	110$			; that's it
     40
     41	001626	005702 			60$:	tst	r2			; are all buffers in use?
     42	001630	001011 				bne	90$			; nope..
     43										; ya, scroll back previous lines
     44	001632	016200 	000000G		70$:	mov	lastli(r2),r0		; address where string will be written
     45	001636	016201 	000002G			mov	lastli+2(r2),r1		; address of string to be moved
     46	001642	112120 			80$:	movb	(r1)+	,(r0)+		; copy the string now
     47	001644	001376 				bne	80$			; until hitting the null terminator
     48	001646	062702 	000002 			add	#2	,r2		; bump pointer to next line
     49	001652	077311 				sob	r3	,70$		; next please
     50
     51	001654	016201 	000000G		90$:	mov	lastli(r2),r1		; at last, copy the new line
     52	001660	116721 	000000G			movb	edilen	,(r1)+		; save the line length
     53	001664	112421 			100$:	movb	(r4)+	,(r1)+		; copy the data now
     54	001666	001376 				bne	100$			; including null terminator
     55	001670	006202 				asr	r2			; recover index to current command
     56	001672	010267 	000000G			mov	r2	,edicmd		; save it
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 24-1
Process CR, store command line	; /BBS/ fixed up..

     57
     58	001676	016701 	000000G		110$:	mov	edilen	,r1		; return line length
     59	001702	042767 	000036 	000000G		bic	#<up$mode!dn$mode!up$end!fw$mode>,edists  ; clear flags
     60	001710	005000 				clr	r0			; no error, also clears carry
     61	001712	000207 				return
     62
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 25
Process CR, store command line	; /BBS/ fixed up..

      1
      2						.sbttl	Recall a command	; /BBS/ some changes..
      3
      4	001714	012702 	000000G		next:	mov	#edicmd	,r2		; point to command number buffer
      5	001720	005712 				tst	@r2			; anything been saved?
      6	001722	002003 				bge	10$			; /62/ ya
      7	001724	004767 	176366 			call	beep			; /62/ not yet, so there's
      8	001730	000465 				br	60$			; /62/ nothing to recall
      9
     10	001732	021227 	000011 		10$:	cmp	@r2	,#ln$cnt-1	; /62/ can we move up?
     11	001736	103403 				blo	30$			; /63/ ya
     12	001740	004767 	176352 		20$:	call	beep			; /62/ no, beep
     13	001744	000436 				br	50$			; /62/ and cleanup anyway
     14
     15	001746	005212 			30$:	inc	@r2			; yes, move up
     16
     17	001750	032767 	000004 	000000G		bit	#dn$mode,edists		; if down arrow was used last time
     18	001756	001404 				beq	40$			; loop in one more bump up to fix pos
     19	001760	042767 	000004 	000000G		bic	#dn$mode,edists		; when going back up, but only do this
     20	001766	000761 				br	10$			; once when coming back here
     21
     22	001770	011202 			40$:	mov	@r2	,r2		; recover command number
     23	001772	006302 				asl	r2			; word addressing
     24	001774	016202 	000000G			mov	lastli(r2),r2		; at last
     25	002000	105712 				tstb	@r2			; anything to copy?
     26	002002	001756 				beq	20$			; /62/ no, ring bell and cleanup
     27
     28	002004	004767 	000246 			call	recover			; ya, get the line
     29	002010	052767 	000002 	000000G		bis	#up$mode,edists		; set mode flag
     30	002016	026727 	000000G	000012 		cmp	edicmd	,#ln$cnt	; poised at the last command?
     31	002024	103427 				blo	60$			; /63/ no
     32	002026	005367 	000000G			dec	edicmd			; ya, fix so prev works correctly
     33	002032	042767 	000002 	000000G		bic	#up$mode,edists		; ditto
     34	002040	000421 				br	60$
     35
     36	002042	042767 	000002 	000000G	50$:	bic	#up$mode,edists		; at the end, no extra bump please
     37	002050	004767 	000000G			call	l$nolf			; /62/ goto start of line
     38	002054					wrtall	#$ceol			; /62/ clear line on screen
	002054	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	002060	004767 	000000G			call	wrtall			; do it
     39	002064					wrtall	@r5			; /62/ print prompt
	002064	011546 				mov	@r5	,-(sp)		; pass the address
	002066	004767 	000000G			call	wrtall			; do it
     40	002072	105014 				clrb	@r4			; no data left over
     41	002074	005067 	000000G			clr	edilen			; length=0
     42	002100	005067 	000000G			clr	edipos			; /62/ cursor is at beginning of line
     43
     44	002104	042767 	000010 	000000G	60$:	bic	#up$end,edists		; no longer at the end of list
     45	002112	000261 				sec				; not done yet
     46	002114	000207 				return
     47
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 26
Recall a command	; /BBS/ some changes..

      1
      2						.sbttl	Up-arrow key		; /BBS/ some changes..
      3
      4	002116	032767 	000010 	000000G	prev:	bit	#up$end,edists		; already at the firewall?
      5	002124	001402 				beq	10$			; no
      6	002126	004767 	176164 			call	beep			; ya, ring the bell
      7
      8	002132	016702 	000000G		10$:	mov	edicmd	,r2		; current command number
      9	002136	002003 				bge	20$			; /62/ something has been saved
     10	002140	004767 	176152 			call	beep			; /62/ never been here
     11	002144	000442 				br	60$			; /62/ so nothing to recall yet
     12
     13	002146	032767 	000002 	000000G	20$:	bit	#up$mode,edists		; down arrow been used?
     14	002154	001005 				bne	30$			; ya, so bump edicmd to correct
     15
     16	002156	006302 				asl	r2			; word indexing
     17	002160	016202 	000000G			mov	lastli(r2),r2		; address of buffer
     18	002164	105712 				tstb	@r2			; anything to copy?
     19	002166	001006 				bne	40$			; yes
     20
     21	002170	042767 	000002 	000000G	30$:	bic	#up$mode,edists		; only do this first time thru here
     22	002176	005367 	000000G			dec	edicmd			; no, back up
     23	002202	000753 				br	10$			; and try again..
     24
     25	002204	004767 	000046 		40$:	call	recover			; ya, get the line
     26
     27	002210	005767 	000000G			tst	edicmd			; check for underflow
     28	002214	003011 				bgt	50$			; nope
     29	002216	005067 	000000G			clr	edicmd			; just in case..
     30	002222	042767 	000004 	000000G		bic	#dn$mode,edists		; no help needed coming off end
     31	002230	052767 	000010 	000000G		bis	#up$end,edists		; no more stuff, edicmd=0
     32	002236	000405 				br	60$
     33
     34	002240	005367 	000000G		50$:	dec	edicmd			; backup now and
     35	002244	052767 	000004 	000000G		bis	#dn$mode,edists		; apply appropriate compensation
     36
     37	002252	000261 			60$:	sec				; not done yet
     38	002254	000207 				return
     39
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 27
Up-arrow key		; /BBS/ some changes..

      1
      2						.sbttl	Recover a command line	; /BBS/ made this a subroutine
      3
      4	002256	004767 	000000G		recover:call	l$nolf			; goto start of line
      5	002262					wrtall	#$ceol			; clear line on screen
	002262	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	002266	004767 	000000G			call	wrtall			; do it
      6	002272					wrtall	@r5			; print prompt
	002272	011546 				mov	@r5	,-(sp)		; pass the address
	002274	004767 	000000G			call	wrtall			; do it
      7	002300	105014 				clrb	(r4)			; init buffer
      8	002302	005003 				clr	r3			; /63/ avoid possible sign extension
      9	002304	152203 				bisb	(r2)+	,r3		; /63/ get length
     10	002306	001406 				beq	20$			; nothing there
     11	002310	010401 				mov	r4	,r1		; copy of the destination address
     12	002312	112221 			10$:	movb	(r2)+	,(r1)+		; copy string
     13	002314	001376 				bne	10$			; including null terminator
     14	002316					wrtall	r4			; echo the string just copied
	002316	010446 				mov	r4	,-(sp)		; pass the address
	002320	004767 	000000G			call	wrtall			; do it
     15	002324	010367 	000000G		20$:	mov	r3	,edilen		; save length
     16	002330	010367 	000000G			mov	r3	,edipos		; cursor is now at EOL
     17	002334	042767 	000020 	000000G		bic	#fw$mode,edists		; can only backup from here
     18	002342	000207 				return
     19
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 28
Recover a command line	; /BBS/ made this a subroutine

      1
      2						.sbttl	Process ^U		; /BBS/ all new
      3
      4	002344	016701 	000000G		ctrlu:	mov	edipos	,r1		; get the offset into line
      5	002350	003430 				ble	30$			; nothing to do
      6	002352	004767 	176504 			call	SOL			; move to start of line, clear edipos
      7	002356					wrtall	#$ceol			; erase to EOL
	002356	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	002362	004767 	000000G			call	wrtall			; do it
      8	002366	005067 	000000G			clr	edilen			; init length
      9	002372	005000 				clr	r0			; start at the top
     10	002374	004767 	000236 			call	undwrt			; write deleted data into a buffer
     11	002400	010402 				mov	r4	,r2		; work copy of output pointer
     12	002402	112022 			10$:	movb	(r0)+	,(r2)+		; copy rest of line back into buffer
     13	002404	001405 				beq	20$			; until null
     14	002406	005267 	000000G			inc	edilen			; string is now one char longer
     15	002412	005267 	000000G			inc	edipos			; cursor will be here
     16	002416	000771 				br	10$			; next char
     17	002420				20$:	wrtall	r4			; dump result to term
	002420	010446 				mov	r4	,-(sp)		; pass the address
	002422	004767 	000000G			call	wrtall			; do it
     18	002426	004767 	176430 			call	sol			; go back to start of the line
     19	002432	000261 			30$:	sec				; not done yet
     20	002434	000207 				return
     21
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 29
Process ^U		; /BBS/ all new

      1
      2						.sbttl	Keypad minus		; /BBS/ all new..
      3
      4	002436	026767 	000000G	000000G	kp$min:	cmp	edipos	,edilen		; at end of the line?
      5	002444	103035 				bhis	10$			; /63/ ya, can't do this
      6	002446	016703 	000000G			mov	edipos	,r3		; save current cursor position
      7	002452	004767 	001026 			call	savclr			; save cursor position, erase to EOL
      8	002456	016746 	000000G			mov	edists	,-(sp)		; save current mode
      9	002462	052767 	000020 	000000G		bis	#fw$mode,edists		; set advance mode
     10	002470	004767 	176430 			call	kp$1			; bump to next word
     11	002474	012667 	000000G			mov	(sp)+	,edists		; restore old mode
     12	002500	016701 	000000G			mov	edipos	,r1		; end of the deleted data
     13	002504	160301 				sub	r3	,r1		; length of same
     14	002506	160167 	000000G			sub	r1	,edilen		; length of what remains in line
     15	002512	010300 				mov	r3	,r0		; begin copy from here
     16	002514	004767 	000116 			call	undwrt			; copy deleted stuff into buffer
     17	002520					wrtall	#$restore		; put cursor back
	002520	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	002524	004767 	000000G			call	wrtall			; do it
     18	002530	010367 	000000G			mov	r3	,edipos		; cursor is now here
     19	002534	004767 	000116 			call	outwrt			; pull up trailing part of line
     20	002540	000261 			10$:	sec				; not done yet
     21	002542	000207 				return
     22
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 30
Keypad minus		; /BBS/ all new..

      1
      2						.sbttl	Line feed		; /BBS/ all new
      3
      4	002544	005767 	000000G		lfproc:	tst	edipos			; at top of the line?
      5	002550	003430 				ble	10$			; ya, can't do this
      6	002552	016703 	000000G			mov	edipos	,r3		; save current cursor position
      7	002556	016746 	000000G			mov	edists	,-(sp)		; save current mode
      8	002562	042767 	000020 	000000G		bic	#fw$mode,edists		; set backup mode
      9	002570	004767 	176330 			call	kp$1			; bump to next word
     10	002574	012667 	000000G			mov	(sp)+	,edists		; restore old mode
     11	002600	010301 				mov	r3	,r1		; end of deleted data
     12	002602	166701 	000000G			sub	edipos	,r1		; length of deleted part of line
     13	002606	160167 	000000G			sub	r1	,edilen		; new length of what's left in line
     14	002612	016700 	000000G			mov	edipos	,r0		; start from here
     15	002616	004767 	000014 			call	undwrt			; write the undelete buffer
     16	002622	004767 	000656 			call	savclr			; save cursor position, erase to EOL
     17	002626	004767 	000024 			call	outwrt			; pull up trailing part of line
     18	002632	000261 			10$:	sec				; not done yet
     19	002634	000207 				return
     20
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 31
Line feed		; /BBS/ all new

      1
      2						.sbttl	Write buffers		; /BBS/ for the above two routines
      3
      4	002636	012702 	000000G		undwrt:	mov	#undlin	,r2		; pointer to undelete line buffer
      5	002642	110122 				movb	r1	,(r2)+		; stash copy of the length
      6	002644	060400 				add	r4	,r0		; start from here
      7	002646	112022 			10$:	movb	(r0)+	,(r2)+		; stash the deleted
      8	002650	077102 				sob	r1	,10$		; part of the line
      9	002652	105012 				clrb	(r2)			; null terminate it
     10	002654	000207 				return
     11
     12	002656				outwrt:	wrtall	r0			; restore undeleted part of line
	002656	010046 				mov	r0	,-(sp)		; pass the address
	002660	004767 	000000G			call	wrtall			; do it
     13	002664					wrtall	#$restore		; put cursor back
	002664	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	002670	004767 	000000G			call	wrtall			; do it
     14	002674	010402 				mov	r4	,r2		; work copy of input pointer
     15	002676	066702 	000000G			add	edipos	,r2		; where old line left off
     16	002702	112022 			20$:	movb	(r0)+	,(r2)+		; pull up the rest of it
     17	002704	001376 				bne	20$			; until hitting the null terminator
     18	002706	000207 				return
     19
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 32
Write buffers		; /BBS/ for the above two routines

      1
      2						.sbttl	Un-do PF4, keypad comma	; /BBS/ all new
      3
      4	002710				.kp$min:				; UNDEL WORD and LINE are same funct
      5	002710	004767 	000022 		.pf$4:	call	.ctrlu			; use this, then fix cursor
      6	002714	005700 				tst	r0			; did it work?   beep sets r0 if not..
      7	002716	001005 				bne	20$			; no   /63/ or r0 clear for bisb below
      8	002720	156700 	000000G			bisb	undlin	,r0		; /63/ recover length of insert
      9	002724	004767 	176364 		10$:	call	left			; back cursor up to
     10	002730	077003 				sob	r0	,10$		; where it was
     11	002732	000261 			20$:	sec				; not done yet
     12	002734	000207 				return
     13
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 33
Un-do PF4, keypad comma	; /BBS/ all new

      1
      2						.sbttl	Un-do ^U, line feed	; /BBS/ all new
      3
      4	002736				.lfproc:				; UNDO LF and UNDO ^U are same funct
      5	002736	105767 	000000G		.ctrlu:	tstb	undlin			; anything to undelete?
      6	002742	001410 				beq	10$			; no
      7	002744	012700 	000204 			mov	#ln$max	,r0		; max possible line length
      8	002750	166700 	000000G			sub	edilen	,r0		; minus what is already in use
      9	002754	003403 				ble	10$			; no room left
     10	002756	126700 	000000G			cmpb	undlin	,r0		; will new stuff fit?
     11	002762	101402 				blos	20$			; /63/ ya
     12	002764	000167 	175326 		10$:	jmp	beep			; it can't happen
     13
     14	002770	162706 	000206 		20$:	sub	#ln$max+2,sp		; it can happen, get a temp buffer
     15	002774	010602 				mov	sp	,r2		; and a pointer to it
     16
     17	002776	016701 	000000G			mov	edipos	,r1		; get the offset into line
     18	003002	060401 				add	r4	,r1		; where to stuff the data
     19
     20	003004	012703 	000000G			mov	#undlin	,r3		; pointer to string to insert
     21	003010	005000 				clr	r0			; /63/ avoid possible sign extension
     22	003012	152300 				bisb	(r3)+	,r0		; /63/ recover length
     23	003014	060067 	000000G			add	r0	,edilen		; add length of insert to total
     24	003020	060067 	000000G			add	r0	,edipos		; cursor will be here when done
     25
     26	003024					strcpy	r2	,r1		; save from cursor to EOL
	003024	010146 				mov	r1	,-(sp)
	003026	010246 				mov	r2	,-(sp)
	003030	004767 	000000G			jsr	pc	,strcpy
     27	003034	112321 			30$:	movb	(r3)+	,(r1)+		; recover the insert data
     28	003036	001376 				bne	30$			; copy up to null terminator
     29	003040	005301 				dec	r1			; bump pointer back onto it
     30	003042					strcpy	r1	,r2		; put the trailing data back in
	003042	010246 				mov	r2	,-(sp)
	003044	010146 				mov	r1	,-(sp)
	003046	004767 	000000G			jsr	pc	,strcpy
     31	003052					wrtall	#undlin+1		; echo insert moving cursor to its end
	003052	012746 	000001G			mov	#undlin+1	,-(sp)		; pass the address
	003056	004767 	000000G			call	wrtall			; do it
     32	003062					wrtall	#$save			; save cursor pos
	003062	012746 	000030'			mov	#$save	,-(sp)		; pass the address
	003066	004767 	000000G			call	wrtall			; do it
     33	003072					wrtall	r2			; restore trailing part of old line
	003072	010246 				mov	r2	,-(sp)		; pass the address
	003074	004767 	000000G			call	wrtall			; do it
     34	003100					wrtall	#$restore		; put the cursor back now
	003100	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	003104	004767 	000000G			call	wrtall			; do it
     35	003110	062706 	000206 			add	#ln$max+2,sp		; pop buffer
     36	003114	005000 				clr	r0			; flag no error
     37	003116	000261 				sec				; but not done yet
     38	003120	000207 				return
     39
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 34
Un-do ^U, line feed	; /BBS/ all new

      1
      2						.sbttl	Process PF4		; /BBS/ all new
      3
      4	003122	016701 	000000G		pf$4:	mov	edilen	,r1		; length of the whole banana
      5	003126	166701 	000000G			sub	edipos	,r1		; length of deleted part of line
      6	003132	003421 				ble	20$			; nothing to do
      7	003134	012702 	000000G			mov	#undlin	,r2		; pointer to undelete line buffer
      8	003140	110122 				movb	r1	,(r2)+		; stash copy of the length
      9	003142	010400 				mov	r4	,r0		; work copy of input pointer
     10	003144	066700 	000000G			add	edipos	,r0		; start from here
     11	003150	010001 				mov	r0	,r1		; save to terminate after copying..
     12	003152	112022 			10$:	movb	(r0)+	,(r2)+		; ..the deleted part of line..
     13	003154	001376 				bne	10$			; ..and its null term
     14	003156	105011 				clrb	(r1)			; now terminate the new string
     15	003160					wrtall	#$ceol			; erase to the end of the line
	003160	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	003164	004767 	000000G			call	wrtall			; do it
     16	003170	016767 	000000G	000000G		mov	edipos	,edilen		; this is new length
     17	003176	000261 			20$:	sec				; not done yet
     18	003200	000207 				return
     19
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 35
Process PF4		; /BBS/ all new

      1
      2						.sbttl	Erase char under cursor	; /BBS/ all new
      3
      4	003202	026767 	000000G	000000G	kp$com:	cmp	edipos	,edilen		; at end of the line?
      5	003210	103057 				bhis	do.end			; /63/ ya, nothing to do
      6	003212	010402 				mov	r4	,r2		; copy pointer to top of buffer
      7	003214	066702 	000000G			add	edipos	,r2		; now it's pointing to cursor position
      8	003220	105712 				tstb	(r2)			; don't load a null into undchr!
      9	003222	001452 				beq	do.end			; it's at EOL, nothing to do
     10	003224	000427 				br	do.com			; fall thru to common code..
     11
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 36
Erase char under cursor	; /BBS/ all new

      1
      2						.sbttl	Erase char to left of cursor  ; /BBS/ fixed up..
      3
      4	003226	005767 	000000G		dorub:	tst	edipos			; at SOL?
      5	003232	003446 				ble	do.end			; ya
      6	003234	010402 				mov	r4	,r2		; copy pointer to top of buffer
      7	003236	066702 	000000G			add	edipos	,r2		; now it's pointing to cursor position
      8	003242	105712 				tstb	(r2)			; at EOL?
      9	003244	001014 				bne	10$			; no
     10	003246	114267 	000000G			movb	-(r2)	,undchr		; ya, copy for undel_char
     11	003252	105012 				clrb	(r2)			; then zap char
     12	003254	005367 	000000G			dec	edilen			; new length
     13	003260					wrtall	#$rubout		; fix display
	003260	012746 	000024'			mov	#$rubout	,-(sp)		; pass the address
	003264	004767 	000000G			call	wrtall			; do it
     14	003270	005367 	000000G			dec	edipos			; cursor is now here
     15	003274	000425 				br	do.end
     16
     17	003276	004767 	176012 		10$:	call	left			; move back one char for a rubout
     18	003302	005302 				dec	r2			; fix pointer
     19
     20	003304	111267 	000000G		do.com:	movb	(r2)	,undchr		; /63/ stash copy for possible undel
     21	003310	010201 				mov	r2	,r1		; copy pointer for input
     22	003312	010203 				mov	r2	,r3		; copy pointer for output
     23	003314	005201 				inc	r1			; bump past char that is hosed
     24	003316	112123 			20$:	movb	(r1)+	,(r3)+		; slide everything left down a byte
     25	003320	001376 				bne	20$			; until null terminated
     26	003322	005367 	000000G			dec	edilen			; line is now one less char long
     27	003326	004767 	000152 			call	savclr			; save cursor position, erase to EOL
     28	003332					wrtall	r2			; dump buffer
	003332	010246 				mov	r2	,-(sp)		; pass the address
	003334	004767 	000000G			call	wrtall			; do it
     29	003340					wrtall	#$restore		; restore cursor position
	003340	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	003344	004767 	000000G			call	wrtall			; do it
     30	003350	000261 			do.end:	sec				; /63/ not done yet
     31	003352	000207 				return
     32
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 37
Erase char to left of cursor  ; /BBS/ fixed up..

      1
      2						.sbttl	Process ^R		; /BBS/ minor clean up
      3
      4	003354	004767 	000000G		retype:	call	l$nolf			; start of line
      5	003360					wrtall	#$ceol			; clear to end of line
	003360	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	003364	004767 	000000G			call	wrtall			; do it
      6	003370					wrtall	@r5			; print the prompt
	003370	011546 				mov	@r5	,-(sp)		; pass the address
	003372	004767 	000000G			call	wrtall			; do it
      7	003376	005767 	000000G			tst	sl.ked			; KED mode on?
      8	003402	001404 				beq	10$			; no
      9	003404					wrtall	#$setvt			; ya, force keypad to application mode
	003404	012746 	000033'			mov	#$setvt	,-(sp)		; pass the address
	003410	004767 	000000G			call	wrtall			; do it
     10	003414				10$:	wrtall	r4			; dump the buffer
	003414	010446 				mov	r4	,-(sp)		; pass the address
	003416	004767 	000000G			call	wrtall			; do it
     11	003422	004767 	000000G			call	l$nolf			; back to column 1
     12	003426					strlen	@r5			; prompt is this long
	003426	011500 				mov	@r5	,r0
	003430	004767 	000000G			call	l$len
     13	003434	066700 	000000G			add	edipos	,r0		; add expected cursor position
     14	003440				20$:	wrtall	#$right			; go to it
	003440	012746 	000020'			mov	#$right	,-(sp)		; pass the address
	003444	004767 	000000G			call	wrtall			; do it
     15	003450	077005 				sob	r0	,20$		; one column at a time until there
     16	003452	000261 				sec				; not done yet
     17	003454	000207 				return
     18
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 38
Process ^R		; /BBS/ minor clean up

      1
      2						.sbttl	Toggle insert/overstrike mode
      3
      4	003456	012700 	000001 		toggle:	mov	#in$mode,r0		; copy of insert mode bit
      5	003462					xor	r0	,edists		; toggle it
	003462	010046 				mov	r0	,-(sp)		; it's much simpler to do this
	003464	046716 	000000G			bic	edists	,@sp		; for all RT-11 systems rather
	003470	040067 	000000G			bic	r0	,edists		; than to be selective
	003474	052667 	000000G			bis	(sp)+	,edists		; done
      6	003500	000261 				sec				; not done yet
      7	003502	000207 				return
      8
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 39
Save cursor then clear to EOL	; /BBS/ added

      1						.sbttl	Save cursor then clear to EOL	; /BBS/ added
      2
      3	003504				savclr:	wrtall	#$save			; save cursor position
	003504	012746 	000030'			mov	#$save	,-(sp)		; pass the address
	003510	004767 	000000G			call	wrtall			; do it
      4	003514					wrtall	#$ceol			; erase to EOL
	003514	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	003520	004767 	000000G			call	wrtall			; do it
      5	003524	000207 				return
      6
      7		000001 				.end
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 39-1
Symbol table

ALSIZE= 002000   	DONE    001500R     002	KRTINC= 000001   	PF$2    000332R     002	TERMIN  177777
ARGBUF= ****** GX	DORUB   003226R     002	KX.DSP  000516R     003	PF$4    003122R     002	TEXT    000000
AT.ALL  000177   	DOT   = 000056   	KX.LST  000510R     003	PF1DSP  000416R     003	TILDE = 000176
AT.CDT  000001   	DO.COM  003304R     002	K.DSP   000342R     003	PF1LST  000404R     003	TOGGLE  003456R     002
AT.INF  000002   	DO.END  003350R     002	K.LST   000320R     003	PF2$OK= ****** GX	TTY   = 000001
AT.LEN  000004   	DO220   000240R     002	K1.DSP  000452R     003	PREV    002116R     002	UNDCHR= ****** GX
AT.ON   100000   	EDICMD= ****** GX	K1.LST  000440R     003	P.CAPA= 000011   	UNDLIN= ****** GX
AT.PRO  000010   	EDILEN= ****** GX	LASTLI= ****** GX	P.CHKT= 000007   	UNDWRT  002636R     002
AT.SYS  000020   	EDIPOS= ****** GX	LEFT    001314R     002	P.EOL = 000004   	UP$END= 000010
AT.TYP  000040   	EDISTS= ****** GX	LF    = 000012   	P.MXL1= 000013   	UP$MOD= 000002
AT.XLE  000100   	EDI.01  000046R     003	LFPROC  002544R     002	P.MXL2= 000014   	USERRB= 000053
BEEP    000316R     002	EDI.02  000117R     003	LN$CNT= 000012   	P.NPAD= 000002   	VT100 = 000002
BELL  = 000007   	EDI.03  000124R     003	LN$MAX= 000204   	P.PADC= 000003   	VT200 = 000003
BINARY  000001   	EOF     001446R     002	LOG$AL= 000003   	P.QBIN= 000006   	WARN$ = 000002
BS    = 000010   	EOL     001102R     002	LOG$CO= 000002   	P.QCTL= 000005   	WRIT1C= ****** GX
CAPA.A= 000010   	ERBFSI= 000170   	LOG$DE= 000020   	P.REPT= 000010   	WRTALL= ****** GX
CAPA.L= 000002   	ERRBYT= 000052   	LOG$IO= 000010   	P.SPSI= 000000   	XOFF  = 000023
CAPA.S= 000004   	ERROR$= 000004   	LOG$ON= 040000   	P.TIME= 000001   	XON   = 000021
CMD$AB= ****** GX	ER$EOF= ****** GX	LOG$OP= 100000   	P.VEND= 000017   	$ALLSI= 003614
CMD$EX= ****** GX	ESC   = 000033   	LOG$PA= 000001   	P.WIND= 000012   	$CEOL   000000R     003
COMMA = 000054   	ESCDSP  000300R     003	LOG$RP= 000004   	READ1C= ****** GX	$CZ     000004R     003
CON$ES= 000034   	ESCLST  000270R     003	LOOP    001130R     002	RECOVE  002256R     002	$LEFT   000011R     003
CR    = 000015   	FATAL$= 000020   	L$LEN = ****** GX	RETYPE  003354R     002	$RESTO  000015R     003
CTRLC   001376R     002	FF    = 000014   	L$NOLF= ****** GX	RIGHT   001246R     002	$RIGHT  000020R     003
CTRLU   002344R     002	FW$MOD= 000020   	L$PCRL= ****** GX	SAVCLR  003504R     002	$RUBOU  000024R     003
CTRL$N= 000016   	INSCH   000662R     002	MAXLNG= 003600   	SCANCH= ****** GX	$SAVE   000030R     003
CTRL$O= 000017   	IN$MOD= 000001   	MAXPAK  000136   	SCANDS  000154R     003	$SETVT  000033R     003
CZ.FIN  001466R     002	JSW   = 000044   	NEXT    001714R     002	SCANLS  000132R     003	$$    = 000001
C$HELP= ****** GX	KBREAD= ****** GX	NOSCOP= 000000   	SCOLON= 000073   	$$$0  = 000006
C.CRLF= 000004   	KBREDI  000000RG    002	OUTWRT  002656R     002	SEVER$= 000010   	$$5   = 000067
C.LCUC= 000040   	KEDDSP  000236R     003	PAR$EV  000002   	SL.KED= ****** GX	.CTRLU  002736R     002
C.LSPA= 000010   	KEDLST  000220R     003	PAR$MA  000003   	SL.ON = ****** GX	.DOESC  000524R     002
C.SSPA= 000020   	KP$COM  003202R     002	PAR$NO  000000   	SOH   = 000001   	.DORUB  000646R     002
C.TSPA= 000200   	KP$MIN  002436R     002	PAR$OD  000001   	SOL     001062R     002	.DO220  000550R     002
DECNAT  000002   	KP$1    001124R     002	PAR$SP  000004   	SPACE = 000040   	.KP$CO  000626R     002
DEL   = 000177   	KP$3    001236R     002	PFXDSP  000502R     003	STRCPY= ****** GX	.KP$MI  002710R     002
DELIMI  000036R     003	KP$4    001352R     002	PFXLST  000476R     003	SUCCS$= 000001   	.LFPRO  002736R     002
DN$MOD= 000004   	KP$5    001364R     002	PF$1    000446R     002	TAB   = 000011   	.PF$4   002710R     002
DOESC   000220R     002

. ABS.	000000    000	(RW,I,GBL,ABS,OVR)
      	000000    001	(RW,I,LCL,REL,CON)
$CODE 	003526    002	(RO,I,LCL,REL,CON)
$PDATA	000530    003	(RO,D,LCL,REL,CON)
Errors detected:  0

*** Assembler statistics


Work  file  reads: 0
Work  file writes: 0
Size of work file: 10958 Words  ( 43 Pages)
Size of core pool: 12800 Words  ( 50 Pages)
Operating  system: RT-11

Elapsed time: 00:00:00.18
KRTEDI,KRTEDI=KRTEDI
