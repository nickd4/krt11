KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01
Table of contents

    2-   1	KRTMAC	Various handy constants and macros
    4-   2	Utility macros
    5-   4	Local data
    6-   3	BASIC+ CVT$$ function	; /62/ unused functions pulled..
    7-   2	Get length of .asciz string
    8-   2	Write a right justified decimal number to TT
    9-   2	The real number conversion subroutine
   10-   2	Simple (non-wildcarded) string comparison
   11-   2	Convert rad50 word to 3 ascii bytes
   12-   2	16-bit integer to ascii conversion routines	; /BBS/
   13-   2	32-bit integer to ascii from RSX SYSLIB.OLB
   14-   2	Decimal ascii to integer	; /BBS/ made this unsigned..
   15-   2	Octal ascii to integer
   16-   2	Integer to ascii octal conversion
   17-   2	Write integer in (r5) to TT as octal number
   18-   2	Copy an .asciz string
   19-   2	STRCAT and STRCPY
   20-   2	Control or uncontrol a char
   21-   2	Scan a string for a character
   22-   2	Upper case one arg, or all of them  ; /BBS/ added
   23-   2	Integer to decimal ascii conversion  ; /BBS/ added
   24-   2	Unformat a string, inverse of PRSARG
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 1


      1						.title	KRTSUB	Commonly used subroutines
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	move unfmts here so KRTMDM can live in KRTCVT's overlay ...
      7
      8					; /62/	27-Jul-93  Billy Youdelman  V03.62
      9					;
     10					;	remove unused code to save memory
     11
     12					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     13					;
     14					;	added a couple upper case routines
     15					;	moved itoa here
     16					;	add support for non-EIS CPUs
     17
     18					;	Brian Nelson  01-Dec-83  13:19:14
     19					;
     20					;	Copyright 1983 Change Software, Inc.
     21					;
     22					;	This software is furnished under a license and may
     23					;	be  used  and  copied  only in accordance with the
     24					;	terms of such license and with  the  inclusion  of
     25					;	the  above copyright notice.  This software or any
     26					;	other copies thereof may not be provided or other-
     27					;	wise made available to any other person.  No title
     28					;	to and ownership of the software is hereby  trans-
     29					;	ferred.
     30					;
     31					;	The information in this  software  is  subject  to
     32					;	change  without notice and should not be construed
     33					;	as a commitment by the author.
     34
     35
     36						.include "IN:KRTMAC.MAC"
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 2
KRTMAC	Various handy constants and macros

      1						.sbttl	KRTMAC	Various handy constants and macros
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	add support for SET ATTRIBUTES
      7					;	add flag to suspend logging to a disk file
      8					;	make $LN$MAX 132. bytes for EIS assembly
      9					;	pulled message macro, no longer used..
     10
     11					; /62/	27-Jul-93  Billy Youdelman  V03.62
     12					;
     13					;	move dispatch macro to KRTSER
     14					;	move erbfsiz here from KRTPAK
     15					;	condense logging (debug) modes
     16					;	increase efficiency of incm64 macro
     17					;	increase MAXLNG (long-packet size) to 1920.
     18					;	reduce MAXLNG to 600. for NONEIS assembly, so pgm loads under FB..
     19					;	ditto for ALSIZE (phone # buffer) and LN$CNT (SL # of lines saved)
     20
     21					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     22					;
     23					;	modified message macro to call .newline instead of saving CR/LF
     24					;	and null for each new line, knocking 1042. bytes off the size
     25					;	of this version..  also changed ".print" emulation to wrtall,
     26					;	for a similar savings in compiled program size.
     27					;
     28					;	dump raw I/O logging from log$al (SET DEB ALL) - too confusing
     29					;	also pulled log$rp out and made it a completely separate item..
     30					;
     31					;	added a couple upper case macros
     32
     33					;	include file for Kermit-11
     34					;
     35					;	Brian Nelson  01-Dec-83  13:56:12
     36
     37						.NLIST	BEX
     38						.LIST	MEB			; /62/
     39
     40		000001 				KRTINC	=	1		; for .include error checking
     41
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 3
KRTMAC	Various handy constants and macros

      1
      2	000000					.psect	$code	,ro,i,lcl,rel,con ; psect ordering..
      3	000000					.psect	$pdata	,ro,d,lcl,rel,con
      4
      5					;	various ascii chars
      6		000001 				SOH	=   1		; default packet start of header
      7		000007 				BELL	=   7		; beep
      8		000010 				BS	=  10		; backspace
      9		000011 				TAB	=  11		; tab
     10		000012 				LF	=  12		; line feed
     11		000014 				FF	=  14		; form feed
     12		000015 				CR	=  15		; carriage return
     13		000016 				CTRL$N	=  16		; ^N VT-100 line drawing on
     14		000017 				CTRL$O	=  17		; ^O VT-100 line drawing off
     15		000021 				XON	=  'Q&37	; ^Q
     16		000023 				XOFF	=  'S&37	; ^S
     17		000033 				ESC	=  33		; escape
     18		000040 				SPACE	=  40
     19		000054 				COMMA	=  54
     20		000056 				DOT	=  56		; /63/
     21		000073 				SCOLON	=  73		; /63/
     22		000176 				TILDE	= 176		; /63/
     23		000177 				DEL	= 177		; delete
     24
     25					;	system data locations
     26		000044 				JSW	= 44		; job status word
     27		000052 				ERRBYT	= 52		; emt error byte
     28		000053 				USERRB	= 53		; /62/ user error byte
     29		000001 					SUCCS$	=  1	; no error
     30		000002 					WARN$	=  2	; warning
     31		000004 					ERROR$	=  4	; error
     32		000010 					SEVER$	= 10	; sever error
     33		000020 					FATAL$	= 20	; fatal error
     34
     35					;	byte offsets into SINIT parameter vector
     36		000000 				P.SPSIZ	= 0		; set packet length
     37		000001 				P.TIME	= 1		; time-out
     38		000002 				P.NPAD	= 2		; number of pad chars
     39		000003 				P.PADC	= 3		; the pad character
     40		000004 				P.EOL	= 4		; eol char
     41		000005 				P.QCTL	= 5		; control char quoting
     42		000006 				P.QBIN	= 6		; 8-bit quote
     43		000007 				P.CHKT	= 7		; checksum type
     44		000010 				P.REPT	= 10		; repeated character prefix
     45		000011 				P.CAPAS	= 11		; capability bitmask
     46		000010 					CAPA.A	= 10	; attribute handling
     47		000002 					CAPA.L	= 2	; /42/ long packets
     48		000004 					CAPA.S	= 4	; /42/ sliding windows
     49		000012 				P.WINDS	= 12		; /43/ window size, # of packets
     50		000013 				P.MXL1	= 13		; /43/ high order of long packet size
     51		000014 				P.MXL2	= 14		; /43/ low order of long packet size
     52		000017 				P.VEND	= 17		; end of parameter vector
     53
     54					; /62/	bits in doattr (file attribute processing)
     55		000001 				AT.CDT	=: 1		; create date
     56		000002 				AT.INF	=: 2		; /63/ system specific info
     57		000004 				AT.LEN	=: 4		; length
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 3-1
KRTMAC	Various handy constants and macros

     58		000010 				AT.PRO	=: 10		; file protection
     59		000020 				AT.SYS	=: 20		; system ID
     60		000040 				AT.TYP	=: 40		; file type
     61		000100 				AT.XLE	=: 100		; exact length in bytes
     62		100000 				AT.ON	=: 100000	; /63/ do attribute processing
     63		000177 				AT.ALL	=: AT.CDT!AT.INF!AT.LEN!AT.PRO!AT.SYS!AT.TYP!AT.XLE
     64
     65					;	bits in trace (debug status word)
     66		000001 				LOG$PA	= 1		; log all packets
     67		000002 				LOG$CO	= 2		; /62/ CONNECT logging to disk
     68		000004 				LOG$RP	= 4		; /62/ rpack chars to TT
     69		000010 				LOG$IO	= 10		; /62/ everything received or sent
     70		000020 				LOG$DE	= 20		; /62/ debugging to TT
     71		040000 				LOG$ON	= 40000		; /63/ set to write to disk, clear to suspend
     72		100000 				LOG$OP	= 100000	; logfile is open
     73		000003 				LOG$AL	= LOG$PA!LOG$CO	; /62/ ALL
     74
     75					;	parity options
     76		000000 				PAR$NO	=: 0		; none
     77		000001 				PAR$OD	=: 1		; odd
     78		000002 				PAR$EV	=: 2		; even
     79		000003 				PAR$MA	=: 3		; mark
     80		000004 				PAR$SP	=: 4		; space
     81
     82					;	file types
     83		177777 				TERMINAL=: -1		; file to term ala xreply, not to disk
     84		000000 				TEXT	=:  0		; normal ascii text files
     85		000001 				BINARY	=:  1		; image mode
     86		000002 				DECNAT	=:  2		; /52/ 8-bit text files
     87
     88					;	terminal types
     89		000000 				NOSCOPE	= 0		; /BBS/ hard copy terminal
     90		000001 				TTY	= 1		; a dumb tube terminal
     91		000002 				VT100	= 2		; itself
     92		000003 				VT200	= 3		; ditto..
     93
     94					;	supported CVT$$ cvt_bit_pattern bits
     95		000004 				C.CRLF	= 4		; discard CR LF FF ESC
     96		000010 				C.LSPA	= 10		; discard leading spaces and tabs
     97		000020 				C.SSPA	= 20		; reduce spaces and tabs to a single space
     98		000040 				C.LCUC	= 40		; lower case to upper case
     99		000200 				C.TSPA	= 200		; discard trailing spaces and tabs
    100
    101		000034 				CON$ESC	=  '\-100	; default CONNECT escape char
    102		000170 				ERBFSIZ	=  120.		; /62/ error msg text buff size
    103		000136 				MAXPAK	=:  94.		; /63/ max_packet_length - max_checksum_length
    104
    105						.if df	NONEIS		; /62/ using NONEIS for convenience..
    106						ALSIZE	=   1000	; /63/ bufsiz for SET DIAL/PHO NUM
    107						LN$CNT	=      3.	; /62/ save/recall 3. commands
    108						LN$MAX	=     80.	; /63/ max command line length
    109						MAXLNG	=    600.	; /63/ so image is small enuff to run
    110						.iff
    111		002000 				ALSIZE	=   2000	; /62/ bufsiz for SET DIAL/PHO NUM
    112		000012 				LN$CNT	=     10.	; /63/ save/recall 10. commands
    113		000204 				LN$MAX	=    132.	; /63/ max command line length
    114		003600 				MAXLNG	=   1920.	; /63/ use max long-packet buff size
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 3-2
KRTMAC	Various handy constants and macros

    115						.endc
    116		003614 				$ALLSIZ	= <MAXLNG+14>&177776 ; /62/ make it this for safety
    117
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 4
KRTMAC	Various handy constants and macros

      1
      2						.sbttl	Utility macros
      3
      4						.macro	.br to		; /63/ added
      5						.if df	to
      6						.if ne	to-.
      7						.error	<; not at location to;>
      8						.endc
      9						.endc
     10						.endm	.br
     11
     12						.macro	.chksp	arg
     13						.ntype	$$5	,arg
     14						.iif eq <<$$5&7>-6> .error arg <; Illegal use of SP (r6) in call>
     15						.endm	.chksp
     16
     17						.macro	calls	name	,arglst
     18					;	subroutine call with arguments passed in an area pointed to by r5
     19					;	(as with F4 and BP2).  all args are pushed onto the stack in the
     20					;	order specified.  r5 points to the sp before the call and is saved
     21					;	and restored.
     22						$$ = 0				; init # of args count
     23						  .irp x ,<arglst>		; count up # of args passed
     24						  $$ = $$+1			; one at a time
     25						  .endr				; got it
     26						.if eq $$			; no args present?
     27						jsr	pc	,name		; if so, substitute a simple call
     28						.iff				; at least one arg in <arglst>
     29						mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
     30						  .if eq $$-1			; is it one or more than one arg?
     31						  .chksp	arglst		; one arg, check for legal SP modes
     32						  mov	arglst	,-(sp)		; doing it thusly generates less code
     33						  mov	sp	,r5		; set pointer to argument list
     34						  jsr	pc	,name		; call the subroutine
     35						  tst	(sp)+			; pop parameter list from stack
     36						  mov	(sp)+	,r5		; /63/ restore r5
     37						  .iff				; arg_count > 1
     38						  $$2 = $$			; extract the args in
     39						    .rept	$$		; reverse order so that
     40						    $$1 = 0			; we might save a little
     41						      .irp x ,<arglst>		; core (four words)
     42						      $$1 = $$1+1		; scan the arg list until we come to
     43						        .if eq $$2-$$1		; the last one before one we just did
     44						        .chksp	x		; check for SP addressing mode
     45						        mov	x	,-(sp)	; push it
     46						        .mexit			; and exit the .irp
     47						        .endc
     48						      .endr
     49						    $$2 = $$2-1			; backwards to previous arg
     50						    .endr
     51						  mov	sp	,r5		; set up the argument list pointer
     52						  jsr	pc	,name		; and go to the routine
     53						  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
     54						  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
     55						  mov	(sp)+	,r5		; /63/ restore r5
     56						  .endc
     57						.endc
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 4-1
Utility macros

     58						.endm	calls
     59
     60						.macro	ctl	src ,dst
     61						clr	-(sp)
     62						bisb	src	,@sp
     63						call	l$xor
     64						movb	(sp)+	,dst
     65						.endm	ctl
     66
     67						.macro	copyz	from ,to ,maxlen
     68						.if  b	<maxlen>
     69						clr	-(sp)
     70						.iff
     71						mov	maxlen	,-(sp)
     72						.endc
     73						mov	from	,-(sp)
     74						mov	to	,-(sp)
     75						call	copyz$
     76						.endm	copyz
     77
     78						.macro	deccvt	val ,buf ,width
     79						mov	r5	,-(sp)
     80						.if  b	<width>
     81						clr	-(sp)
     82						.iff
     83						mov	width	,-(sp)
     84						.endc
     85						mov	val	,-(sp)
     86						mov	buf	,-(sp)
     87						mov	sp	,r5
     88						call	l$cvtnum
     89						add	#6	,sp
     90						mov	(sp)+	,r5
     91						.endm	deccvt
     92
     93						.macro	decout	val
     94						mov	r5	,-(sp)
     95						mov	val	,-(sp)		; /62/ l$wrdec pops this buffer
     96						mov	sp	,r5
     97						call	l$wrdec
     98						mov	(sp)+	,r5
     99						.endm	decout
    100
    101						.macro	direrr	val
    102						mov	val	,-(sp)
    103						call	direr$
    104						.endm	direrr
    105
    106						.macro	incm64	val
    107						inc	val
    108						bic	#^c<77>	,val		; /62/ faster
    109						.endm	incm64
    110
    111						.macro	indexm	reg		; check for auto increment/decrement
    112						.ntype	$$$0	,reg		; modes for macros that can't have..
    113						.if  ne	$$$0-27			; always allow pc autoincrement
    114						$$$0 =	<$$$0&177770>/10	; ..these modes in their arg list
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 4-2
Utility macros

    115						.ift				; get the mode into 0..7
    116						  .if  ge $$$0-2		; if mode >=2 and mode <=5 then error
    117						  .iif ge <5-$$$0> .error      <; Can't use auto inc/dec mode here>
    118						  .endc
    119						.endc
    120						.endm	indexm
    121
    122						.macro	ixor	reg ,dst
    123					;	get around the mode restrictions for the hardware XOR instruction
    124					;	and fix for RT-11 systems that don't have the EIS chip option
    125						.chksp	reg			; can't allow sp args
    126						.chksp	dst			; in either register
    127						indexm	reg			; check for allowed
    128						indexm	dst			; addressing mode
    129						mov	reg	,-(sp)		; it's much simpler to do this
    130						bic	dst	,@sp		; for all RT-11 systems rather
    131						bic	reg	,dst		; than to be selective
    132						bis	(sp)+	,dst		; done
    133						.endm	ixor
    134
    135						.macro	.newline		; print CR/LF on TT
    136						call	l$pcrlf
    137						.endm	.newline
    138
    139						.macro	octout	val
    140						calls	l$wroct	,<val>
    141						.endm	octout
    142
    143						.macro	prsbuf	dst
    144						mov	dst	,r0
    145						call	prsarg
    146						.endm	prsbuf
    147
    148						.macro	rpack	len.a ,pakn.a ,msg.a ,max.len	; /62/
    149						sub	#10	,sp
    150						mov	sp	,r1
    151						calls	rpack$	,<msg.a,r1,max.len>
    152						mov	(r1)+	,len.a
    153						mov	(r1)+	,pakn.a
    154						mov	@r1	,r1
    155						add	#10	,sp
    156						.endm	rpack
    157
    158						.macro	save	list
    159						.if  b	<list>
    160						 save	<r0,r1,r2,r3,r4,r5>
    161						.iff
    162						.irp	x ,<list>
    163						 mov	x	,-(sp)
    164						.endr
    165						.endc
    166						.endm	save
    167
    168						.macro	scan	ch ,str
    169						mov	str	,-(sp)
    170						clr	-(sp)
    171						bisb	ch	,@sp
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 4-3
Utility macros

    172						call	scanch
    173						.endm	scan
    174
    175						.macro	setpar	src ,dst
    176						movb	src	,-(sp)
    177						call	dopari
    178						movb	(sp)+	,dst
    179						.endm	setpar
    180
    181						.macro	spack	type ,pnum ,len ,msg
    182						.if  b	<len>
    183						.iif nb	<msg>	.error	<; bad call to SPACK macro>
    184						calls	spack$	,<type,pnum,#0,#null>
    185						.iff
    186						calls	spack$	,<type,pnum,len,msg>
    187						.endc
    188						.endm	spack
    189
    190						.macro	strcat	dst ,src
    191						mov	src	,-(sp)
    192						mov	dst	,-(sp)
    193						jsr	pc	,strcat
    194						.endm	strcat
    195
    196						.macro	strcpy	dst ,src
    197						mov	src	,-(sp)
    198						mov	dst	,-(sp)
    199						jsr	pc	,strcpy
    200						.endm	strcpy
    201
    202						.macro	strlen	string
    203						mov	string	,r0
    204						call	l$len
    205						.endm	strlen
    206
    207						.macro	textsrc	text
    208						.if  b	<text>
    209						clr	getcroutine		; /62/ reset to file I/O
    210						clr	tgetaddr
    211						.iff
    212						mov	#tgetcr0,getcroutine
    213						mov	text	,tgetaddr
    214						.endc
    215						.endm	textsrc
    216
    217						.macro	tochar	src ,dst
    218						clr	-(sp)
    219						bisb	src	,@sp
    220						add	#40	,@sp
    221						movb	(sp)+	,dst
    222						.endm	tochar
    223
    224						.macro	unchar	src ,dst
    225						clr	-(sp)
    226						bisb	src	,@sp
    227						sub	#40	,@sp
    228						movb	(sp)+	,dst
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 4-4
Utility macros

    229						.endm	unchar
    230
    231						.macro	unsave	list
    232						.if b <list>
    233						unsave	<r5,r4,r3,r2,r1,r0>
    234						.iff
    235						.irp	x ,<list>
    236						 mov	(sp)+	,x
    237						.endr
    238						.endc
    239						.endm	unsave
    240
    241						.macro	upcase	s		; /BBS/ added ..
    242						mov	s	,r0
    243						call	upcase			; /BBS/ upcase until null terminator
    244						.endm	upcase
    245
    246						.macro	upone	s		; /BBS/ added ..
    247						mov	s	,r0
    248						call	upone			; /BBS/ upcase only to next delimiter
    249						.endm	upone
    250
    251						.macro	wrtall	arg		; IO.WAL for an .asciz string
    252						mov	arg	,-(sp)		; pass the address
    253						call	wrtall			; do it
    254						.endm	wrtall
    255
    256						.macro	xor	reg ,dst
    257						ixor	reg	,dst
    258						.endm	xor
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 5
Utility macros

      1						.iif ndf  KRTINC  .error	<; .include for IN:KRTMAC.MAC failed>
      2
      3
      4						.sbttl	Local data
      5
      6	000000					.psect	$pdata		; /63/ consolidate local data
      7	000000	001750 	000144 		X4$:	.word	1000., 100.	; do "thousands," "hundreds," then..
      8	000004	000012 	000001 	000000 	X2$:	.word	10., 1., 0	; do "tens," "ones," null terminator
      9	000012	   015 	   012 	   014 	junkch:	.byte	cr ,lf ,ff ,esc	; for the c.crlf option
     10	000016	   000 				.byte	0		; terminator
     11	000017	   040 	   101 	   102 	radchr:	.ascii	" ABCDEFGHIJKLMNOPQRSTUVWXYZ$.?0123456789"
     12						.even
     13
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 6
Local data

      1
      2	000000					.psect	$code
      3						.sbttl	BASIC+ CVT$$ function	; /62/ unused functions pulled..
      4
      5					;	calls	cvt$$	,<addr(input),len(input),val(cvt_bit_pattern)>
      6					;
      7					;	returns:  addr(input)	= trimmed string
      8					;		    r0		= length of what's left
      9
     10						; supported cvt_bit_pattern bits
     11		000004 				C.CRLF	=	4	; discard CR LF FF ESC
     12		000010 				C.LSPA	=	10	; discard leading spaces and tabs
     13		000020 				C.SSPA	=	20	; reduce spaces and tabs to a single space
     14		000040 				C.LCUC	=	40	; convert lower case to upper case
     15		000200 				C.TSPA	=	200	; discard trailing spaces and tabs
     16
     17						; offsets into local work space on stack
     18		000000 				PAT	=	0	; cvt_bit_pattern
     19		000002 				LASTCH	=	2	; last character
     20		000004 				SADDR	=	4	; string address
     21		000006 				LSIZE	=	6	; work space size (for the above 3 words)
     22
     23	000000				cvt$$::	save	<r1,r2,r3,r4,r5>
	000000	010146 				 mov	r1	,-(sp)
	000002	010246 				 mov	r2	,-(sp)
	000004	010346 				 mov	r3	,-(sp)
	000006	010446 				 mov	r4	,-(sp)
	000010	010546 				 mov	r5	,-(sp)
     24	000012	162706 	000006 			sub	#lsize	,sp		; allocate some work space
     25	000016	010604 				mov	sp	,r4		; point to it
     26	000020	012502 				mov	(r5)+	,r2		; the string address for output
     27	000022	010264 	000004 			mov	r2	,saddr(r4)	; and save it for a while
     28	000026	012501 				mov	(r5)+	,r1		; get the string length also
     29	000030	012564 	000000 			mov	(r5)+	,pat(r4)	; and finally the bit pattern
     30	000034	105064 	000002 			clrb	lastch(r4)		; no previous character please
     31	000040	010205 				mov	r2	,r5		; where to get the input string
     32	000042	005701 				tst	r1			; the length
     33	000044	001476 				beq	90$			; nothing to do
     34
     35	000046	005003 			10$:	clr	r3			; avoid the movb sxt please
     36	000050	152503 				bisb	(r5)+	,r3		; get the next character
     37
     38	000052	032764 	000010 	000000 		bit	#c.lspa	,pat(r4)	; how about removing spaces and tabs?
     39	000060	001021 				bne	30$			; if ne, yes
     40
     41	000062	032764 	000020 	000000 		bit	#c.sspa	,pat(r4)	; embedded tabs/spaces = just a space?
     42	000070	001426 				beq	40$			; no
     43	000072	120327 	000011 			cmpb	r3	,#tab		; yes, if this char is a tab
     44	000076	001002 				bne	20$			; then make it into
     45	000100	112703 	000040 			movb	#space	,r3		; a space first please
     46	000104	126427 	000002 	000040 	20$:	cmpb	lastch(r4),#space	; was the last char a space?
     47	000112	001404 				beq	30$			; or a tab?
     48	000114	126427 	000002 	000011 		cmpb	lastch(r4),#tab		; please check both
     49	000122	001011 				bne	40$			; no
     50	000124	120327 	000040 		30$:	 cmpb	r3	,#space		; is the current character a space?
     51	000130	001440 				 beq	80$			; /62/ no
     52	000132	120327 	000011 			 cmpb	r3	,#tab		; not a space, try a horizontal tab
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 6-1
BASIC+ CVT$$ function	; /62/ unused functions pulled..

     53	000136	001435 				 beq	80$			; /62/ char was a tab, ignore it
     54	000140	042764 	000010 	000000 		  bic	#c.lspa	,pat(r4)	; for leading spaces and tabs
     55
     56	000146	032764 	000004 	000000 	40$:	bit	#c.crlf	,pat(r4)	; ignore FF, ESC, CR, LF?
     57	000154	001411 				beq	60$			; no
     58
     59	000156	012700 	000012'			mov	#junkch	,r0		; ya, get the address of the spec
     60	000162	105703 				tstb	r3			; is the current char a null?
     61	000164	001422 				beq	80$			; yes, please skip it then
     62	000166	105710 			50$:	tstb	@r0			; anything left in the list?
     63	000170	001403 				beq	60$			; no
     64	000172	120320 				cmpb	r3	,(r0)+		; see if we have a match
     65	000174	001416 				beq	80$			; /62/ if so, we will skip the char
     66	000176	000773 				br	50$			; no, next check please
     67
     68	000200	032764 	000040 	000000 	60$:	bit	#c.lcuc	,pat(r4)	; how about converting lower
     69	000206	001410 				beq	70$			; case to upper case?
     70	000210	120327 	000172 			cmpb	r3	,#'z!40		; try against a lower case "z"
     71	000214	101005 				bhi	70$			; it's higher than that
     72	000216	120327 	000141 			cmpb	r3	,#'a!40		; if less than a lower z, try
     73	000222	103402 				blo	70$			; against a lower case "a"
     74	000224	142703 	000040 			 bicb	#40	,r3		; char is in range, translate
     75
     76	000230	110322 			70$:	movb	r3	,(r2)+		; if all ok, return the char
     77	000232	110364 	000002 		80$:	movb	r3	,lastch(r4)	; please save the last char
     78	000236	005301 				dec	r1			; and go back
     79	000240	003302 				bgt	10$			; for some more
     80
     81	000242	010200 			90$:	mov	r2	,r0		; current pointer
     82	000244	166400 	000004 			sub	saddr(r4),r0		; return the length of what's left
     83	000250	003416 				ble	120$			; nothing left to do
     84	000252	032764 	000200 	000000 		bit	#c.tspa	,pat(r4)	; remove trailing blanks?
     85	000260	001412 				beq	120$			; no
     86	000262	016401 	000004 			mov	saddr(r4),r1		; address of the string
     87	000266	060001 				add	r0	,r1		; point to end of string+1
     88	000270	124127 	000040 		100$:	cmpb	-(r1)	,#space		; try for a space first
     89	000274	001403 				beq	110$			; found one..
     90	000276	121127 	000011 			cmpb	(r1)	,#tab		; not a space, try a tab
     91	000302	001001 				bne	120$			; not a tab
     92	000304	077007 			110$:	sob	r0	,100$		; tab or space, check next
     93	000306	062706 	000006 		120$:	add	#lsize	,sp		; pop small work area
     94	000312					unsave	<r5,r4,r3,r2,r1>
	000312	012605 				 mov	(sp)+	,r5
	000314	012604 				 mov	(sp)+	,r4
	000316	012603 				 mov	(sp)+	,r3
	000320	012602 				 mov	(sp)+	,r2
	000322	012601 				 mov	(sp)+	,r1
     95	000324	000207 				return
     96
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 7
BASIC+ CVT$$ function	; /62/ unused functions pulled..

      1
      2						.sbttl	Get length of .asciz string
      3
      4					;	input:	 r0	= address of .asciz string
      5					;	output:	 r0	= length of it
      6
      7	000326	010046 			l$len::	mov	r0	,-(sp)		; save start address to calc length
      8	000330	105720 			10$:	tstb	(r0)+			; look for a null character
      9	000332	001376 				bne	10$			; this wasn't it, keep going
     10	000334	162600 				sub	(sp)+	,r0		; subtract start address from current
     11	000336	005300 				dec	r0			; pointer less 1 returns the length
     12	000340	000207 				return
     13
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 8
Get length of .asciz string

      1
      2						.sbttl	Write a right justified decimal number to TT
      3
      4		000006 				DFWIDTH	= 6			; default width
      5
      6					;	input:   (r5)	= number to write
      7
      8	000342				l$wrdec::save	<r1,r4,r5>
	000342	010146 				 mov	r1	,-(sp)
	000344	010446 				 mov	r4	,-(sp)
	000346	010546 				 mov	r5	,-(sp)
      9	000350	012701 	000006 			mov	#dfwidth,r1		; the width
     10	000354	010104 				mov	r1	,r4		; save for a moment
     11	000356	062701 	000006 			add	#6	,r1		; make it round up to even number
     12	000362	042701 	000001 			bic	#1	,r1		; at last...
     13	000366	010446 				mov	r4	,-(sp)		; /62/ the field width please
     14	000370	011546 				mov	@r5	,-(sp)		; and the number to print out
     15	000372	010605 				mov	sp	,r5		; setup the parameter list address
     16	000374	005745 				tst	-(r5)			; make room for the buffer on
     17	000376	160106 				sub	r1	,sp		; the stack
     18	000400	010615 				mov	sp	,@r5		; insert the buffer address
     19	000402	004767 	000030 			call	l$cvtnum		; and convert the number
     20	000406	061504 				add	(r5)	,r4		; find end of buffer
     21	000410	105014 				clrb	(r4)			; null terminate
     22	000412					wrtall	(r5)			; print it out
	000412	011546 				mov	(r5)	,-(sp)		; pass the address
	000414	004767 	000000G			call	wrtall			; do it
     23	000420	060106 				add	r1	,sp		; pop buffer
     24	000422	022626 				cmp	(sp)+	,(sp)+		; pop width and number buffers
     25	000424					unsave	<r5,r4,r1>
	000424	012605 				 mov	(sp)+	,r5
	000426	012604 				 mov	(sp)+	,r4
	000430	012601 				 mov	(sp)+	,r1
     26	000432	012616 				mov	(sp)+	,(sp)		; put return address where number was
     27	000434	000207 				return
     28
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 9
Write a right justified decimal number to TT

      1
      2						.sbttl	The real number conversion subroutine
      3
      4					;	input:	 (r5)	= buffer address
      5					;		2(r5)	= value to print, string will be right justified
      6					;		4(r5)	= field width, if zero will be set to dfwidth
      7
      8	000436				l$cvtnum::save	<r0,r1,r2,r3,r4>
	000436	010046 				 mov	r0	,-(sp)
	000440	010146 				 mov	r1	,-(sp)
	000442	010246 				 mov	r2	,-(sp)
	000444	010346 				 mov	r3	,-(sp)
	000446	010446 				 mov	r4	,-(sp)
      9	000450	011502 				mov	(r5)	,r2		; the buffer address to use
     10	000452	016503 	000004 			mov	4(r5)	,r3		; the field width to use
     11	000456	003002 				bgt	10$			; non-zero
     12	000460	012703 	000006 			 mov	#dfwidth,r3		; zero, use default width
     13	000464	010301 			10$:	mov	r3	,r1		; put it here to clear buffer
     14	000466	112722 	000040 		20$:	movb	#space	,(r2)+		; fill the buffer with blanks
     15	000472	077103 				sob	r1	,20$		; for "width" number of chars
     16	000474	010304 				mov	r3	,r4		; save buffer size also
     17	000476	016501 	000002 			mov	2(r5)	,r1		; get the value to print out
     18	000502	100001 				bpl	30$			; it's a positive number
     19	000504	005401 				 neg	r1			; it wasn't positive, but it is now..
     20	000506	005000 			30$:	clr	r0			; set up for the divide by 10
     21	000510	071027 	000012 			div	#10.	,r0		; remainder in r1, quotient r0
     22	000514	062701 	000060 			add	#'0	,r1		; convert remainder to character
     23	000520	020215 				cmp	r2	,@r5		; overflowed the buffer at all?
     24	000522	001416 				beq	50$			; yes, get out of here!
     25	000524	110142 				movb	r1	,-(r2)		; and return the character now
     26	000526	010001 				mov	r0	,r1		; copy the quotient
     27	000530	001403 				beq	40$			; it was zero
     28	000532	077313 				sob	r3	,30$		; more to do, go back for it
     29	000534	005701 				tst	r1			; something left over by chance?
     30	000536	001010 				bne	50$			; yes, that's a definite error
     31	000540	005765 	000002 		40$:	tst	2(r5)			; was this a negative number?
     32	000544	100007 				bpl	60$			; /62/ no, exit
     33	000546	020215 				cmp	r2	,@r5		; yes, room left for a "-" sign?
     34	000550	001403 				beq	50$			; no, flag an error please
     35	000552	112742 	000055 			 movb	#'-	,-(r2)		; yes, insert a minus symbol
     36	000556	000402 				br	60$
     37	000560	112712 	000052 		50$:	movb	#'*	,@r2		; field overflow, place a "*" in
     38	000564				60$:	unsave	<r4,r3,r2,r1,r0>	; beginning of the buffer
	000564	012604 				 mov	(sp)+	,r4
	000566	012603 				 mov	(sp)+	,r3
	000570	012602 				 mov	(sp)+	,r2
	000572	012601 				 mov	(sp)+	,r1
	000574	012600 				 mov	(sp)+	,r0
     39	000576	000207 				return
     40
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 10
The real number conversion subroutine

      1
      2						.sbttl	Simple (non-wildcarded) string comparison
      3
      4					;	input:   (r5)	= address of the first string
      5					;		2(r5)	= length of the first string
      6					;		4(r5)	= address of the second string, the one to find
      7					;		6(r5)	= length of the second string
      8					;	output:   r0	if > 0 then r0=position of second in first
      9					;			if = 0 the second is not a substring
     10
     11	000600				instr::	save	<r1,r2,r3,r4>
	000600	010146 				 mov	r1	,-(sp)
	000602	010246 				 mov	r2	,-(sp)
	000604	010346 				 mov	r3	,-(sp)
	000606	010446 				 mov	r4	,-(sp)
     12	000610	011500 				mov	(r5)	,r0		; address of first string
     13	000612	016501 	000004 			mov	4(r5)	,r1		; address of second one
     14	000616	016502 	000006 			mov	6(r5)	,r2		; length of second one
     15	000622	003434 				ble	60$			; a null string..
     16	000624	016504 	000002 			mov	2(r5)	,r4		; the length of first
     17	000630	003431 				ble	60$			; a null string..
     18	000632	160204 				sub	r2	,r4		; convert to looping counter
     19	000634	005003 				clr	r3			; the real loop counter
     20
     21	000636	020304 			10$:	cmp	r3	,r4		; are we done yet?
     22	000640	003025 				bgt	60$			; yes, if r3 > r4
     23
     24	000642	122011 				  cmpb	(r0)+	,(r1)		; see if current character in
     25	000644	001021 				  bne	50$			; matches first one in second
     26
     27	000646					    save	<r0,r1,r2>	; found first character match
	000646	010046 				 mov	r0	,-(sp)
	000650	010146 				 mov	r1	,-(sp)
	000652	010246 				 mov	r2	,-(sp)
     28	000654	005201 				    inc	r1			; point to the next character
     29	000656	005302 				    dec	r2			; length of pattern thats left
     30	000660	003403 				    ble	30$			; in case the len(pattern)=1
     31
     32	000662	122021 			20$:	    cmpb	(r0)+ , (r1)+	; check the rest of the pattern
     33	000664	001006 				    bne	40$			; not a match..
     34	000666	077203 				    sob	r2	,20$		; loop for len(pattern)-1
     35	000670	010300 			30$:	    mov	r3	,r0		; the current loop count
     36	000672	005200 				    inc	r0			; point to the next character
     37	000674	062706 	000006 			    add	#6	,sp		; fix the stack from save <r0,r1,r2>
     38	000700	000406 				    br	70$
     39
     40	000702				40$:	    unsave	<r2,r1,r0>	; the match failed, restore the
	000702	012602 				 mov	(sp)+	,r2
	000704	012601 				 mov	(sp)+	,r1
	000706	012600 				 mov	(sp)+	,r0
     41	000710	005203 			50$:	  inc	r3			; pointers and go try the next
     42	000712	000751 				br	10$			; character in the first string
     43
     44	000714	005000 			60$:	clr	r0			; no match
     45	000716				70$:	unsave	<r4,r3,r2,r1>
	000716	012604 				 mov	(sp)+	,r4
	000720	012603 				 mov	(sp)+	,r3
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 10-1
Simple (non-wildcarded) string comparison

	000722	012602 				 mov	(sp)+	,r2
	000724	012601 				 mov	(sp)+	,r1
     46	000726	000207 				return
     47
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 11
Simple (non-wildcarded) string comparison

      1
      2						.sbttl	Convert rad50 word to 3 ascii bytes
      3
      4					;	input:	 (r5)	= address of where to put ascii chars
      5					;		2(r5)	= the value of rad 50 word
      6
      7	000730				rdtoa::	save	<r0,r1,r3>
	000730	010046 				 mov	r0	,-(sp)
	000732	010146 				 mov	r1	,-(sp)
	000734	010346 				 mov	r3	,-(sp)
      8	000736	016501 	000002 			mov	2(r5)	,r1		; go get the rad50 character
      9	000742	011503 				mov	(r5)	,r3		; where to put the characters
     10	000744	005000 				clr	r0			; prepare for divide
     11	000746	071027 	003100 			div	#50*50	,r0		; get first char
     12	000752	116023 	000017'			movb	radchr(r0),(r3)+	; put in buffer
     13	000756	005000 				clr	r0			; another divide
     14	000760	071027 	000050 			div	#50	,r0		; this one gives char 2
     15	000764	116023 	000017'			movb	radchr(r0),(r3)+	; put this in buffer
     16	000770	116123 	000017'			movb	radchr(r1),(r3)+	; and also char 3
     17	000774					unsave	<r3,r1,r0>
	000774	012603 				 mov	(sp)+	,r3
	000776	012601 				 mov	(sp)+	,r1
	001000	012600 				 mov	(sp)+	,r0
     18	001002	000207 				return
     19
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 12
Convert rad50 word to 3 ascii bytes

      1
      2						.sbttl	16-bit integer to ascii conversion routines	; /BBS/
      3
      4	001004	010046 			L10012::MOV	R0	,-(SP)	; convert integer in r0
      5	001006	005000 				CLR	R0		; to ascii in buffer @r1
      6	001010	005200 			L10016:	INC	R0
      7	001012	162716 	000012 			SUB	#12	,(SP)
      8	001016	103374 				BCC	L10016
      9	001020	062716 	000072 			ADD	#72	,(SP)
     10	001024	005300 				DEC	R0
     11	001026	001402 				BEQ	L10042
     12	001030	004767 	177750 			JSR	PC	,L10012
     13	001034	112621 			L10042:	MOVB	(SP)+	,(R1)+	; r1 is left at end of the string on exit..
     14	001036	000207 				RTS	PC
     15
     16	001040	010046 			L10266::MOV	R0	,-(SP)	; print integer in r0
     17	001042	005000 				CLR	R0		; as decimal number on TT
     18	001044	005200 			L10272:	INC	R0
     19	001046	162716 	000012 			SUB	#12	,(SP)
     20	001052	103374 				BCC	L10272
     21	001054	062716 	000072 			ADD	#72	,(SP)
     22	001060	005300 				DEC	R0
     23	001062	001402 				BEQ	L10316
     24	001064	004767 	177750 			JSR	PC	,L10266
     25	001070	112600 			L10316:	MOVB	(SP)+	,R0
     26	001072	000167 	000000G			jmp	writ1ch
     27
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 13
16-bit integer to ascii conversion routines	; /BBS/

      1
      2						.sbttl	32-bit integer to ascii from RSX SYSLIB.OLB
      3
      4					;	clr	r2			; suppress leading 0s in $CDDMG output
      5					;	mov	#xblock	,r1		; address of 32-bit (two words) number
      6					;	mov	#sizbuf	,r0		; address of ascii output buff
      7					;	call	$cddmg			; convert 32-bit integer to ascii
      8					;	clrb	@r0			; null terminate the ascii string
      9
     10	001076	004567 	000252 		$CDDMG::JSR	R5	,$SAVRG
     11	001102	010003 				MOV	R0	,R3
     12	001104	012704 	023420 			MOV	#23420	,R4
     13	001110	012705 	000012 			MOV	#12	,R5
     14	001114	005702 				TST	R2
     15	001116	001401 				BEQ	C00024
     16	001120	052705 	001000 		C00022:	BIS	#1000	,R5
     17		001122'			C00024=	C00022+2
     18	001124	021104 				CMP	(R1)	,R4
     19	001126	103025 				BCC	C00104
     20	001130	012100 				MOV	(R1)+	,R0
     21	001132	011101 				MOV	(R1)	,R1
     22	001134	071004 				DIV	R4	,R0
     23	001136	010146 				MOV	R1	,-(SP)
     24	001140	010001 				MOV	R0	,R1
     25	001142	001407 				BEQ	C00064
     26	001144	012702 	024000 			MOV	#24000	,R2
     27	001150	004767 	000014 			CALL	C00072
     28	001154	052705 	001000 			BIS	#1000	,R5
     29	001160	010003 				MOV	R0	,R3
     30	001162	012601 			C00064:	MOV	(SP)+	,R1
     31	001164	012702 	020000 			MOV	#20000	,R2
     32	001170	010300 			C00072:	MOV	R3	,R0
     33	001172	050502 				BIS	R5	,R2
     34	001174	004767 	000016 			CALL	$CBTA
     35	001200	000405 				BR	C00116
     36	001202	012702 	000005 		C00104:	MOV	#5	,R2
     37	001206	112720 	000052 		C00110:	MOVB	#52	,(R0)+
     38	001212	077203 				SOB	R2	,C00110
     39	001214	000207 			C00116:	RETURN
     40
     41	001216	004567 	000132 		$CBTA:	JSR	R5	,$SAVRG
     42	001222	110205 				MOVB	R2	,R5
     43	001224	105002 				CLRB	R2
     44	001226	000302 				SWAB	R2
     45	001230	006202 				ASR	R2
     46	001232	103005 				BCC	E00134
     47	001234	005701 				TST	R1
     48	001236	100003 				BPL	E00134
     49	001240	005401 				NEG	R1
     50	001242	112720 	000055 			MOVB	#55	,(R0)+
     51	001246	010004 			E00134:	MOV	R0	,R4
     52	001250	006002 				ROR	R2
     53	001252	006002 				ROR	R2
     54	001254	006003 				ROR	R3
     55	001256	105003 				CLRB	R3
     56	001260	150203 				BISB	R2	,R3
     57	001262	105002 				CLRB	R2
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 13-1
32-bit integer to ascii from RSX SYSLIB.OLB

     58	001264	152702 	000060 			BISB	#60	,R2
     59	001270	010100 				MOV	R1	,R0
     60	001272	010001 			E00160:	MOV	R0	,R1
     61	001274	005000 				CLR	R0
     62	001276	071005 				DIV	R5	,R0
     63	001300	020127 	000011 			CMP	R1	,#11
     64	001304	101402 				BLOS	E00200
     65	001306	062701 	000007 			ADD	#7	,R1
     66	001312	060201 			E00200:	ADD	R2	,R1
     67	001314	010146 				MOV	R1	,-(SP)
     68	001316	105303 				DECB	R3
     69	001320	003412 				BLE	E00234
     70	001322	005700 				TST	R0
     71	001324	001006 				BNE	E00230
     72	001326	005702 				TST	R2
     73	001330	100006 				BPL	E00234
     74	001332	005703 				TST	R3
     75	001334	100002 				BPL	E00230
     76	001336	042702 	000020 			BIC	#20	,R2
     77	001342	004767 	177724 		E00230:	CALL	E00160
     78	001346	112624 			E00234:	MOVB	(SP)+	,(R4)+
     79	001350	010400 				MOV	R4	,R0
     80	001352	000207 				RETURN
     81
     82	001354	010446 			$SAVRG:	MOV	R4	,-(SP)
     83	001356	010346 				MOV	R3	,-(SP)
     84	001360	010546 				MOV	R5	,-(SP)
     85	001362	016605 	000006 			MOV	6(SP)	,R5
     86	001366	004736 				CALL	@(SP)+
     87	001370	012603 				MOV	(SP)+	,R3
     88	001372	012604 				MOV	(SP)+	,R4
     89	001374	012605 				MOV	(SP)+	,R5
     90	001376	000207 				RETURN
     91
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 14
32-bit integer to ascii from RSX SYSLIB.OLB

      1
      2						.sbttl	Decimal ascii to integer	; /BBS/ made this unsigned..
      3
      4					;	input:	 (r5)	= address of .asciz decimal number string to convert
      5					;	output:	  r1	= binary value of the string
      6					;		  r0	= if <>, not a number
      7
      8	001400				l$val::	save	<r3>
	001400	010346 				 mov	r3	,-(sp)
      9	001402	005001 				clr	r1			; initialize the result
     10	001404	011503 				mov	(r5)	,r3		; the address of the string
     11	001406	112300 			10$:	movb	(r3)+	,r0		; /62/ next char
     12	001410	001420 				beq	30$			; if null, exit please
     13	001412	020027 	000056 			cmp	r0	,#dot		; /63/ a decimal point?
     14	001416	001415 				beq	30$			; /63/ ya, number has ended..
     15	001420	162700 	000072 			sub	#'9+1	,r0		; /62/ convert ascii byte
     16	001424	062700 	000012 			add	#9.+1	,r0		; /62/ to an integer
     17	001430	103005 				bcc	20$			; /62/ not a number
     18	001432	070127 	000012 			mul	#10.	,r1		; /62/ bump accumulator by tens
     19	001436	103402 				bcs	20$			; /62/ overflowed, bail out..
     20	001440	060001 				add	r0	,r1		; /62/ add in result from this pass
     21	001442	103361 				bcc	10$			; /62/ ok, try the next byte
     22	001444	012700 	000000G		20$:	mov	#er$bad	,r0		; /63/ illegal number, flag an error
     23	001450	000401 				br	40$
     24	001452	005000 			30$:	clr	r0			; indicate success
     25	001454				40$:	unsave	<r3>
	001454	012603 				 mov	(sp)+	,r3
     26	001456	000207 				return
     27
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 15
Decimal ascii to integer	; /BBS/ made this unsigned..

      1
      2						.sbttl	Octal ascii to integer
      3
      4					;	input:	 (r5)	= address of .asciz octal number string to convert
      5					;	output:	  r1	= binary value of the string
      6					;		  r0	= if <>, not a number
      7
      8	001460				octval::save	<r3>			; /62/ all new..
	001460	010346 				 mov	r3	,-(sp)
      9	001462	005001 				clr	r1			; initialize the result
     10	001464	011503 				mov	(r5)	,r3		; the address of the string
     11	001466	112300 			10$:	movb	(r3)+	,r0		; next char
     12	001470	001414 				beq	30$			; if null, exit please
     13	001472	162700 	000070 			sub	#'7+1	,r0		; convert ascii byte
     14	001476	062700 	000010 			add	#7+1	,r0		; to an integer
     15	001502	103004 				bcc	20$			; not an octal number
     16	001504	072127 	000003 			ash	#3	,r1		; bump accumulator * 8
     17	001510	060001 				add	r0	,r1		; add in result from this pass
     18	001512	000765 				br	10$
     19	001514	012700 	000000G		20$:	mov	#er$bad	,r0		; /63/ illegal number, flag an error
     20	001520	000401 				br	40$
     21	001522	005000 			30$:	clr	r0			; indicate success
     22	001524				40$:	unsave	<r3>
	001524	012603 				 mov	(sp)+	,r3
     23	001526	000207 				return
     24
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 16
Octal ascii to integer

      1
      2						.sbttl	Integer to ascii octal conversion
      3
      4					;	input:	 (r5)	= buffer address
      5					;		2(r5)	= binary number to write as ascii string in above
      6
      7	001530				l$otoa::save	<r0,r1,r2>		; /62/ all new..
	001530	010046 				 mov	r0	,-(sp)
	001532	010146 				 mov	r1	,-(sp)
	001534	010246 				 mov	r2	,-(sp)
      8	001536	011501 				mov	(r5)	,r1		; the buffer for ascii output
      9	001540	016500 	000002 			mov	2(r5)	,r0		; the binary number to convert
     10	001544	012702 	000006 			mov	#6	,r2		; loop 6 times, zero filling..
     11	001550	004767 	000012 			call	10$			; call conversion routine
     12	001554	105011 				clrb	(r1)			; add null termination byte
     13	001556					unsave	<r2,r1,r0>
	001556	012602 				 mov	(sp)+	,r2
	001560	012601 				 mov	(sp)+	,r1
	001562	012600 				 mov	(sp)+	,r0
     14	001564	000207 				return
     15
     16	001566	010046 			10$:	mov	r0	,-(sp)		; copy of the number
     17	001570	042716 	177770 			bic	#^c<7>	,(sp)		; mask for lower 3 bits
     18	001574	062716 	000060 			add	#60	,(sp)		; make result an ascii digit
     19	001600	006000 				ror	r0			; rotate next group of 3 bits into low
     20	001602	006200 				asr	r0			; order bits of r0..
     21	001604	006200 				asr	r0
     22	001606	005302 				dec	r2			; loop for six passes
     23	001610	001402 				beq	20$			; we are done
     24	001612	004767 	177750 			call	10$			; if not, call ourself
     25	001616	112621 			20$:	movb	(sp)+	,(r1)+		; last in first out back to text buff
     26	001620	000207 				return
     27
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 17
Integer to ascii octal conversion

      1
      2						.sbttl	Write integer in (r5) to TT as octal number
      3
      4	001622				l$wroc::save	<r0>
	001622	010046 				 mov	r0	,-(sp)
      5	001624	162706 	000010 			sub	#10	,sp		; use stack for a buffer
      6	001630	010600 				mov	sp	,r0		; pointer to said buffer
      7	001632					calls	l$otoa	,<r0,(r5)>	; call the conversion subroutine
	001632	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001634	011546 				        mov	(r5)	,-(sp)	; push it
	001636	010046 				        mov	r0	,-(sp)	; push it
	001640	010605 				  mov	sp	,r5		; set up the argument list pointer
	001642	004767 	177662 			  jsr	pc	,l$otoa		; and go to the routine
	001646	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	001650	012605 				  mov	(sp)+	,r5		; /63/ restore r5
      8	001652					wrtall	r0			; display the number on terminal
	001652	010046 				mov	r0	,-(sp)		; pass the address
	001654	004767 	000000G			call	wrtall			; do it
      9	001660	062706 	000010 			add	#10	,sp		; dump the buffer
     10	001664					unsave	<r0>
	001664	012600 				 mov	(sp)+	,r0
     11	001666	000207 				return
     12
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 18
Write integer in (r5) to TT as octal number

      1
      2						.sbttl	Copy an .asciz string
      3
      4					;	input:	2(sp)	= destination string address
      5					;		4(sp)	= source string address
      6					;		6(sp)	= length to copy or zero for max
      7
      8	001670				copyz$::save	<r0,r1>
	001670	010046 				 mov	r0	,-(sp)
	001672	010146 				 mov	r1	,-(sp)
      9	001674	005766 	000012 			tst	4+6(sp)			; see if a maxlen was passed
     10	001700	001003 				bne	10$			; yes
     11	001702	012766 	077777 	000012 		mov	#77777	,4+6(sp)	; no, say we can have max int chars
     12	001710	016600 	000010 		10$:	mov	4+4(sp)	,r0		; source string address
     13	001714	016601 	000006 			mov	4+2(sp)	,r1		; destination string address
     14	001720	112021 			20$:	movb	(r0)+	,(r1)+		; copy a byte
     15	001722	001404 				beq	30$			; until a null is found
     16	001724	005366 	000012 			dec	4+6(sp)			; or we have copied maxlen number
     17	001730	001373 				bne	20$			; of characters over
     18	001732	105041 				clrb	-(r1)			; ensure output .asciz please
     19	001734				30$:	unsave	<r1,r0>			; /63/ move 30$ here
	001734	012601 				 mov	(sp)+	,r1
	001736	012600 				 mov	(sp)+	,r0
     20	001740	011666 	000006 			mov	@sp	,6(sp)		; move return address up
     21	001744	062706 	000006 			add	#6	,sp		; fix the stack
     22	001750	000207 				return
     23
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 19
Copy an .asciz string

      1
      2						.sbttl	STRCAT and STRCPY
      3
      4					;	input:	 (sp)	= return address
      5					;		2(sp)	= destination address
      6					;		4(sp)	= source address
      7					;	output:	  r0	= destination address
      8
      9	001752				strcpy::save	<r1>
	001752	010146 				 mov	r1	,-(sp)
     10	001754	016600 	000004 			mov	2+2(sp)	,r0		; destination address
     11	001760	016601 	000006 			mov	2+4(sp)	,r1		; source .asciz address
     12	001764	112120 			10$:	movb	(r1)+	,(r0)+		; copy until a null
     13	001766	001376 				bne	10$			; not done
     14	001770	016600 	000004 			mov	2+2(sp)	,r0		; return the dst address
     15	001774					unsave	<r1>
	001774	012601 				 mov	(sp)+	,r1
     16	001776	011666 	000004 			mov	(sp)	,4(sp)		; move return address up now
     17	002002	022626 				cmp	(sp)+	,(sp)+		; pop junk
     18	002004	000207 				return
     19
     20	002006				strcat::save	<r1>
	002006	010146 				 mov	r1	,-(sp)
     21	002010	016600 	000004 			mov	2+2(sp)	,r0		; destination address
     22	002014	016601 	000006 			mov	2+4(sp)	,r1		; source .asciz address
     23	002020	105720 			10$:	tstb	(r0)+			; look for the end of the dst string
     24	002022	001376 				bne	10$			; not found yet
     25	002024	005300 				dec	r0			; found it, fix the pointer
     26	002026	112120 			20$:	movb	(r1)+	,(r0)+		; copy until a null
     27	002030	001376 				bne	20$			; not done
     28	002032	016600 	000004 			mov	2+2(sp)	,r0		; return the dst address
     29	002036					unsave	<r1>
	002036	012601 				 mov	(sp)+	,r1
     30	002040	011666 	000004 			mov	(sp)	,4(sp)		; move return address up now
     31	002044	022626 				cmp	(sp)+	,(sp)+		; pop junk
     32	002046	000207 				return
     33
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 20
STRCAT and STRCPY

      1
      2						.sbttl	Control or uncontrol a char
      3
      4	002050				l$xor::	save	<r0>
	002050	010046 				 mov	r0	,-(sp)
      5	002052	016600 	000004 			mov	4(sp)	,r0		; the input
      6	002056					ixor	#100	,r0		; bump up or down 64. in ascii table
	002056	012746 	000100 			mov	#100	,-(sp)		; it's much simpler to do this
	002062	040016 				bic	r0	,@sp		; for all RT-11 systems rather
	002064	042700 	000100 			bic	#100	,r0		; than to be selective
	002070	052600 				bis	(sp)+	,r0		; done
      7	002072	010066 	000004 			mov	r0	,4(sp)		; the output
      8	002076					unsave	<r0>
	002076	012600 				 mov	(sp)+	,r0
      9	002100	000207 				return
     10
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 21
Control or uncontrol a char

      1
      2						.sbttl	Scan a string for a character
      3
      4					;	input:	4(sp)	= string address
      5					;		2(sp)	= character to look for
      6					;	output:	  r0	= position of char in string
      7
      8	002102				scanch::save	<r2>
	002102	010246 				 mov	r2	,-(sp)
      9	002104	016602 	000006 			mov	6(sp)	,r2		; get address of the string
     10	002110	005000 				clr	r0			; initial found position
     11	002112	105712 			10$:	tstb	@r2			; end of the string yet?
     12	002114	001405 				beq	20$			; yes
     13	002116	005200 				inc	r0			; no, pos := succ(pos)
     14	002120	126622 	000004 			cmpb	4(sp)	,(r2)+		; does the ch match the next one?
     15	002124	001372 				bne	10$			; no, try again
     16	002126	000401 				br	30$			; yes, exit loop
     17	002130	005000 			20$:	clr	r0			; failure, return position = 0
     18	002132				30$:	unsave	<r2>
	002132	012602 				 mov	(sp)+	,r2
     19	002134	011666 	000004 			mov	@sp	,4(sp)		; move return address up
     20	002140	022626 				cmp	(sp)+	,(sp)+		; pop stack
     21	002142	000207 				return
     22
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 22
Scan a string for a character

      1
      2						.sbttl	Upper case one arg, or all of them  ; /BBS/ added
      3						.enabl	lsb
      4
      5	002144				upone::	save	<r1,r0>
	002144	010146 				 mov	r1	,-(sp)
	002146	010046 				 mov	r0	,-(sp)
      6	002150	012701 	000040 			mov	#space	,r1		; stop at next space
      7	002154	000403 				br	10$			; share common code
      8
      9	002156				upcase::save	<r1,r0>
	002156	010146 				 mov	r1	,-(sp)
	002160	010046 				 mov	r0	,-(sp)
     10	002162	005001 				clr	r1			; stop at null, do the whole string
     11	002164	121001 			10$:	cmpb	(r0)	,r1		; hit the delimiter yet?
     12	002166	101412 				blos	30$			; yes, exit
     13	002170	121027 	000141 			cmpb	(r0)	,#'a!40		; a small letter?
     14	002174	103405 				blo	20$			; no
     15	002176	121027 	000172 			cmpb	(r0)	,#'z!40		; a small letter?
     16	002202	101002 				bhi	20$			; no
     17	002204	142710 	000040 			bicb	#40	,(r0)		; yes, make it upper case
     18	002210	005200 			20$:	inc	r0			; bump pointer to next char
     19	002212	000764 				br	10$			; and go check it
     20	002214				30$:	unsave	<r0,r1>
	002214	012600 				 mov	(sp)+	,r0
	002216	012601 				 mov	(sp)+	,r1
     21	002220	000207 				return
     22
     23						.dsabl	lsb
     24
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 23
Upper case one arg, or all of them  ; /BBS/ added

      1
      2						.sbttl	Integer to decimal ascii conversion  ; /BBS/ added
      3
      4	002222	012702 	000000'		i4toa::	mov	#X4$	,r2	; four decimal places, or 0000 if need be
      5	002226	000402 				br	itoa		; share the rest
      6	002230	012702 	000004'		i2toa::	mov	#X2$	,r2	; come here for 2 place numbers
      7	002234				itoa:	save	<r0>		; enter here with r2 loaded
	002234	010046 				 mov	r0	,-(sp)
      8	002236	112700 	000057 		10$:	movb	#'0-1	,r0	; initialize the ascii char output register
      9	002242	005200 			20$:	inc	r0		; step thru ascii 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
     10	002244	161203 				sub	(r2)	,r3	; while subtracting divisor from input integer
     11	002246	103375 				bcc	20$		; until less than the divisor is left
     12	002250	062203 				add	(r2)+	,r3	; recover remainder and set for next pass
     13	002252	110021 				movb	r0	,(r1)+	; put ascii equiv in out buff
     14	002254	005712 				tst	(r2)		; done yet?
     15	002256	001367 				bne	10$		; nope, next one, please..
     16	002260					unsave	<r0>
	002260	012600 				 mov	(sp)+	,r0
     17	002262	000207 				rts	pc
     18
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 24
Integer to decimal ascii conversion  ; /BBS/ added

      1
      2						.sbttl	Unformat a string, inverse of PRSARG
      3										; /63/ moved here from KRTCVT so
      4	002264				unfmts::save	<r1,r2,r3,r4>		; /63/ KRTMDM can be in KRTCVT's ovrly
	002264	010146 				 mov	r1	,-(sp)
	002266	010246 				 mov	r2	,-(sp)
	002270	010346 				 mov	r3	,-(sp)
	002272	010446 				 mov	r4	,-(sp)
      5	002274	010003 				mov	r0	,r3		; /63/ copy the address of the data
      6	002276	012704 	000000G			mov	#spare1	,r4		; /63/ (bigger) target buffer
      7	002302	112301 			10$:	movb	(r3)+	,r1		; /63/ get the data
      8	002304	001431 				beq	100$			; all done
      9	002306	120127 	000040 			cmpb	r1	,#space		; control character?
     10	002312	103402 				blo	20$			; yes
     11	002314	110124 				movb	r1	,(r4)+		; no, just copy as is
     12	002316	000423 				br	40$			; and do the next one
     13	002320	112724 	000134 		20$:	movb	#'\	,(r4)+		; control character, insert "\"
     14	002324	005000 				clr	r0			; get setup for conversion
     15	002326	071027 	000010 			div	#10	,r0		; got it
     16	002332	110102 				movb	r1	,r2		; save the LSB
     17	002334	010001 				mov	r0	,r1		; and get the last two out
     18	002336	005000 				clr	r0			; ....
     19	002340	071027 	000010 			div	#10	,r0		; do it
     20	002344	062700 	000060 			add	#'0	,r0		; convert to ascii
     21	002350	062701 	000060 			add	#'0	,r1		; ..ditto
     22	002354	062702 	000060 			add	#'0	,r2		; ....ditto
     23	002360	110024 				movb	r0	,(r4)+		; insert
     24	002362	110124 				movb	r1	,(r4)+		; the
     25	002364	110224 				movb	r2	,(r4)+		; data
     26	002366	000745 			40$:	br	10$			; next please
     27	002370	105014 			100$:	clrb	@r4			; ensure .asciz
     28	002372	012700 	000000G			mov	#spare1	,r0		; /53/ return addr of converted data
     29	002376					unsave	<r4,r3,r2,r1>		; /63/
	002376	012604 				 mov	(sp)+	,r4
	002400	012603 				 mov	(sp)+	,r3
	002402	012602 				 mov	(sp)+	,r2
	002404	012601 				 mov	(sp)+	,r1
     30	002406	000207 				return
     31
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 25
Unformat a string, inverse of PRSARG

      1
      2						.if df NONEIS		; /BBS/ only do this for non-EIS version!
      3
      4						.sbttl	MUL for a non-EIS CPU	; /BBS/ rewrote this ..
      5
      6					; /BBS/	 WARNING:  This routine does _NOT_ set the V bit ala the EIS multiply!
      7
      8					p$mul::	mov	r0	,-(sp)	; this a is SINGLE PRECISION multiply!
      9						mov	r1	,-(sp)	; save regs used here
     10						mov	r2	,-(sp)
     11
     12						mov	10(sp)	,r0	; src, the multiplier
     13						mov	12(sp)	,r1	; reg, the multiplicand
     14						clr	r2		; init the product
     15
     16					10$:	asr	r1		; divide by 2
     17						bcc	20$		; don't add when result is even number
     18						add	r0	,r2	; add asl'd multiplier to product
     19						bcs	30$		; if overflow, bail out leaving carry set..
     20					20$:	asl	r0		; multiply by 2 for the next pass
     21						tst	r1		; anything left to do?  also clears carry..
     22						bne	10$		; ya
     23
     24					30$:	mov	r2	,12(sp)	; done, put product on stack for caller
     25
     26						mov	(sp)+	,r2	; restore everything to as when called
     27						mov	(sp)+	,r1
     28						mov	(sp)+	,r0
     29
     30						mov	(sp)+	,(sp)	; move return address up, calling macro
     31						return			; pushes 2 args on stack but only pops 1
     32
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 26
Unformat a string, inverse of PRSARG

      1
      2						.sbttl	DIV for a non-EIS CPU	; /BBS/ moved here + commented this..
      3
      4					; /BBS/	 WARNING:  This routine does _NOT_ set C or V bits ala the EIS divide!
      5
      6					p$div::	mov	r0	,-(sp)		; patched for double precision input
      7						mov	r1	,-(sp)		; output is SINGLE PRECISION!
      8						mov	r2	,-(sp)		; save all regs used here
      9
     10						mov	10(sp)	,r2		; high word of dividend
     11						mov	12(sp)	,r0		; low word of dividend
     12						mov	14(sp)	,r1		; divisor
     13
     14						mov	#40	,-(sp)		; do 32. iterations for 32. bits
     15						mov	r1	,-(sp)		; the divisor
     16						clr	r1			; init remainder
     17
     18					10$:	asl	r0			; shift dividend (low word then..
     19						rol	r2			; ..hi word) to left 1 bit, and
     20						rol	r1			; into the remainder
     21						cmp	r1	,(sp)		; is remainder now .gt. divisor?
     22						bcs	20$			; no
     23						sub	(sp)	,r1		; ya, subtract divisor from it
     24						inc	r0			; and bump quotient accordingly
     25					20$:	dec	2(sp)			; do next iteration?
     26						bgt	10$			; ya, there is something left to do..
     27
     28						cmp	(sp)+	,(sp)+		; no, pop iterations + divisor buffers
     29
     30						mov	r1	,12(sp)		; the remainder
     31						mov	r0	,14(sp)		; the quotient
     32
     33						mov	(sp)+	,r2		; restore everything to as when called
     34						mov	(sp)+	,r1
     35						mov	(sp)+	,r0
     36
     37						mov	(sp)+	,(sp)		; move return address up, calling
     38						return				; macro pushes 3 args, only pops 2..
     39
     40						.endc
     41
     42		000001 				.end
KRTSUB	Commonly used subroutin	MACRO V05.03b  00:01  Page 26-1
Symbol table

ALSIZE= 002000   	C00064  001162R     002	LN$CNT= 000012   	PAR$MA  000003   	STRCPY  001752RG    002
AT.ALL  000177   	C00072  001170R     002	LN$MAX= 000204   	PAR$NO  000000   	SUCCS$= 000001
AT.CDT  000001   	C00104  001202R     002	LOG$AL= 000003   	PAR$OD  000001   	TAB   = 000011
AT.INF  000002   	C00110  001206R     002	LOG$CO= 000002   	PAR$SP  000004   	TERMIN  177777
AT.LEN  000004   	C00116  001214R     002	LOG$DE= 000020   	PAT   = 000000   	TEXT    000000
AT.ON   100000   	DECNAT  000002   	LOG$IO= 000010   	P.CAPA= 000011   	TILDE = 000176
AT.PRO  000010   	DEL   = 000177   	LOG$ON= 040000   	P.CHKT= 000007   	TTY   = 000001
AT.SYS  000020   	DFWIDT= 000006   	LOG$OP= 100000   	P.EOL = 000004   	UNFMTS  002264RG    002
AT.TYP  000040   	DOT   = 000056   	LOG$PA= 000001   	P.MXL1= 000013   	UPCASE  002156RG    002
AT.XLE  000100   	ERBFSI= 000170   	LOG$RP= 000004   	P.MXL2= 000014   	UPONE   002144RG    002
BELL  = 000007   	ERRBYT= 000052   	LSIZE = 000006   	P.NPAD= 000002   	USERRB= 000053
BINARY  000001   	ERROR$= 000004   	L$CVTN  000436RG    002	P.PADC= 000003   	VT100 = 000002
BS    = 000010   	ER$BAD= ****** GX	L$LEN   000326RG    002	P.QBIN= 000006   	VT200 = 000003
CAPA.A= 000010   	ESC   = 000033   	L$OTOA  001530RG    002	P.QCTL= 000005   	WARN$ = 000002
CAPA.L= 000002   	E00134  001246R     002	L$VAL   001400RG    002	P.REPT= 000010   	WRIT1C= ****** GX
CAPA.S= 000004   	E00160  001272R     002	L$WRDE  000342RG    002	P.SPSI= 000000   	WRTALL= ****** GX
COMMA = 000054   	E00200  001312R     002	L$WROC  001622RG    002	P.TIME= 000001   	XOFF  = 000023
CON$ES= 000034   	E00230  001342R     002	L$XOR   002050RG    002	P.VEND= 000017   	XON   = 000021
COPYZ$  001670RG    002	E00234  001346R     002	L10012  001004RG    002	P.WIND= 000012   	X2$     000004R     003
CR    = 000015   	FATAL$= 000020   	L10016  001010R     002	RADCHR  000017R     003	X4$     000000R     003
CTRL$N= 000016   	FF    = 000014   	L10042  001034R     002	RDTOA   000730RG    002	$ALLSI= 003614
CTRL$O= 000017   	INSTR   000600RG    002	L10266  001040RG    002	SADDR = 000004   	$CBTA   001216R     002
CVT$$   000000RG    002	ITOA    002234R     002	L10272  001044R     002	SCANCH  002102RG    002	$CDDMG  001076RG    002
C.CRLF= 000004   	I2TOA   002230RG    002	L10316  001070R     002	SCOLON= 000073   	$SAVRG  001354R     002
C.LCUC= 000040   	I4TOA   002222RG    002	MAXLNG= 003600   	SEVER$= 000010   	$$    = 000002
C.LSPA= 000010   	JSW   = 000044   	MAXPAK  000136   	SOH   = 000001   	$$$0  = 000000
C.SSPA= 000020   	JUNKCH  000012R     003	NOSCOP= 000000   	SPACE = 000040   	$$1   = 000001
C.TSPA= 000200   	KRTINC= 000001   	OCTVAL  001460RG    002	SPARE1= ****** GX	$$2   = 000000
C00022  001120R     002	LASTCH= 000002   	PAR$EV  000002   	STRCAT  002006RG    002	$$5   = 000000
C00024= 001122R     002	LF    = 000012

. ABS.	000000    000	(RW,I,GBL,ABS,OVR)
      	000000    001	(RW,I,LCL,REL,CON)
$CODE 	002410    002	(RO,I,LCL,REL,CON)
$PDATA	000070    003	(RO,D,LCL,REL,CON)
Errors detected:  0

*** Assembler statistics


Work  file  reads: 0
Work  file writes: 0
Size of work file: 11352 Words  ( 45 Pages)
Size of core pool: 12800 Words  ( 50 Pages)
Operating  system: RT-11

Elapsed time: 00:00:00.14
KRTSUB,KRTSUB=KRTSUB
