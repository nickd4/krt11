KRTATR	Process attribute packe	MACRO V05.03b  00:00
Table of contents

    3-   1	KRTMAC	Various handy constants and macros
    5-   2	Utility macros
    7-   3	Send all attributes in a single packet	; /BBS/ modified to..
    8-   2	Send system type
    9-   2	Send generic file type
   10-   2	Send file protection	; /BBS/ fixed for RT-11
   11-   2	Send file length	; /BBS/
   12-   2	Send system specific info	; /52/ added /BBS/ cleaned up
   13-   2	Get file creation date/time	; /BBS/ added this..
   14-   2	Send file length in bytes  ; /BBS/ all new
   15-   2	Received attribute packet processing
   16-   2	Null attribute handler
   17-   2	Process received length specified in 1024. byte blocks
   18-   2	Received file type
   19-   2	Put create date/time where close can get them later ; /BBS/
   20-   2	Put file protection code where close can get it later ; /BBS/
   21-   2	Received system type
   22-   2	Receive system specific info
   23-   2	Exact file size in bytes (type "1")
   24-   2	Determine if other system is a PDP-11
   25-   2	Clear attributes
   26-   2	32-bit multiply from RSX SYSLIB.OLB
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 1


      1						.title	KRTATR	Process attribute packets
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5
      6					; /62/	27-Jul-93  Billy Youdelman  V03.62
      7					;
      8					;	add 25% to rec'd length for text files from non RT-11/TSX systems
      9
     10					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     11					;
     12					;	modified rx.cdt,sn.cdt to do the "#" date/time attribute
     13					;	hosed unused stuff, added rx.pro,sn.pro for protected file attribute
     14					;
     15					;	added support for date/time/prot file attributes
     16					;	patched open, close and I/O data table to support it..
     17					;
     18					;	modified w$attr to send all attributes in a single packet
     19					;	rx.xle result in at$len no longer overwritten by rx.len
     20					;	added send exact file length in bytes
     21					;	call binary files "BINARY" not "IMAGE" so MS-Kermit is happy
     22
     23					;	Copyright 1984 Change Software, Inc.
     24					;
     25					;	18-Apr-84  11:20:59 Brian Nelson
     26					;	24-Mar-86  12:00:56 BDN	Major revision which has some rather
     27					;				unpleasant compatibility problems with
     28					;				older Kermit-11's.
     29					;	12-Sep-86  10:37:04 BDN Convert for I/D space
     30
     31					;	 This module is intended to be placed into an overlay
     32					;	which MUST be the "ERROR" cotree as the server, which
     33					;	is overlaid in the  "UTILTY"  cotree  can  indirectly
     34					;	call the module through the packet control routines.
     35
     36					;	 The receiving Kermit should ALWAYS get the SYSTEM and
     37					;	EXECUTIVE type attribute packet first so it can decide
     38					;	if it should use the data being sent.
     39
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 2


      1
      2						.include "IN:KRTMAC.MAC"
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 3
KRTMAC	Various handy constants and macros

      1						.sbttl	KRTMAC	Various handy constants and macros
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	add support for SET ATTRIBUTES
      7					;	add flag to suspend logging to a disk file
      8					;	make $LN$MAX 132. bytes for EIS assembly
      9					;	pulled message macro, no longer used..
     10
     11					; /62/	27-Jul-93  Billy Youdelman  V03.62
     12					;
     13					;	move dispatch macro to KRTSER
     14					;	move erbfsiz here from KRTPAK
     15					;	condense logging (debug) modes
     16					;	increase efficiency of incm64 macro
     17					;	increase MAXLNG (long-packet size) to 1920.
     18					;	reduce MAXLNG to 600. for NONEIS assembly, so pgm loads under FB..
     19					;	ditto for ALSIZE (phone # buffer) and LN$CNT (SL # of lines saved)
     20
     21					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     22					;
     23					;	modified message macro to call .newline instead of saving CR/LF
     24					;	and null for each new line, knocking 1042. bytes off the size
     25					;	of this version..  also changed ".print" emulation to wrtall,
     26					;	for a similar savings in compiled program size.
     27					;
     28					;	dump raw I/O logging from log$al (SET DEB ALL) - too confusing
     29					;	also pulled log$rp out and made it a completely separate item..
     30					;
     31					;	added a couple upper case macros
     32
     33					;	include file for Kermit-11
     34					;
     35					;	Brian Nelson  01-Dec-83  13:56:12
     36
     37						.NLIST	BEX
     38						.LIST	MEB			; /62/
     39
     40		000001 				KRTINC	=	1		; for .include error checking
     41
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 4
KRTMAC	Various handy constants and macros

      1
      2	000000					.psect	$code	,ro,i,lcl,rel,con ; psect ordering..
      3	000000					.psect	$pdata	,ro,d,lcl,rel,con
      4
      5					;	various ascii chars
      6		000001 				SOH	=   1		; default packet start of header
      7		000007 				BELL	=   7		; beep
      8		000010 				BS	=  10		; backspace
      9		000011 				TAB	=  11		; tab
     10		000012 				LF	=  12		; line feed
     11		000014 				FF	=  14		; form feed
     12		000015 				CR	=  15		; carriage return
     13		000016 				CTRL$N	=  16		; ^N VT-100 line drawing on
     14		000017 				CTRL$O	=  17		; ^O VT-100 line drawing off
     15		000021 				XON	=  'Q&37	; ^Q
     16		000023 				XOFF	=  'S&37	; ^S
     17		000033 				ESC	=  33		; escape
     18		000040 				SPACE	=  40
     19		000054 				COMMA	=  54
     20		000056 				DOT	=  56		; /63/
     21		000073 				SCOLON	=  73		; /63/
     22		000176 				TILDE	= 176		; /63/
     23		000177 				DEL	= 177		; delete
     24
     25					;	system data locations
     26		000044 				JSW	= 44		; job status word
     27		000052 				ERRBYT	= 52		; emt error byte
     28		000053 				USERRB	= 53		; /62/ user error byte
     29		000001 					SUCCS$	=  1	; no error
     30		000002 					WARN$	=  2	; warning
     31		000004 					ERROR$	=  4	; error
     32		000010 					SEVER$	= 10	; sever error
     33		000020 					FATAL$	= 20	; fatal error
     34
     35					;	byte offsets into SINIT parameter vector
     36		000000 				P.SPSIZ	= 0		; set packet length
     37		000001 				P.TIME	= 1		; time-out
     38		000002 				P.NPAD	= 2		; number of pad chars
     39		000003 				P.PADC	= 3		; the pad character
     40		000004 				P.EOL	= 4		; eol char
     41		000005 				P.QCTL	= 5		; control char quoting
     42		000006 				P.QBIN	= 6		; 8-bit quote
     43		000007 				P.CHKT	= 7		; checksum type
     44		000010 				P.REPT	= 10		; repeated character prefix
     45		000011 				P.CAPAS	= 11		; capability bitmask
     46		000010 					CAPA.A	= 10	; attribute handling
     47		000002 					CAPA.L	= 2	; /42/ long packets
     48		000004 					CAPA.S	= 4	; /42/ sliding windows
     49		000012 				P.WINDS	= 12		; /43/ window size, # of packets
     50		000013 				P.MXL1	= 13		; /43/ high order of long packet size
     51		000014 				P.MXL2	= 14		; /43/ low order of long packet size
     52		000017 				P.VEND	= 17		; end of parameter vector
     53
     54					; /62/	bits in doattr (file attribute processing)
     55		000001 				AT.CDT	=: 1		; create date
     56		000002 				AT.INF	=: 2		; /63/ system specific info
     57		000004 				AT.LEN	=: 4		; length
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 4-1
KRTMAC	Various handy constants and macros

     58		000010 				AT.PRO	=: 10		; file protection
     59		000020 				AT.SYS	=: 20		; system ID
     60		000040 				AT.TYP	=: 40		; file type
     61		000100 				AT.XLE	=: 100		; exact length in bytes
     62		100000 				AT.ON	=: 100000	; /63/ do attribute processing
     63		000177 				AT.ALL	=: AT.CDT!AT.INF!AT.LEN!AT.PRO!AT.SYS!AT.TYP!AT.XLE
     64
     65					;	bits in trace (debug status word)
     66		000001 				LOG$PA	= 1		; log all packets
     67		000002 				LOG$CO	= 2		; /62/ CONNECT logging to disk
     68		000004 				LOG$RP	= 4		; /62/ rpack chars to TT
     69		000010 				LOG$IO	= 10		; /62/ everything received or sent
     70		000020 				LOG$DE	= 20		; /62/ debugging to TT
     71		040000 				LOG$ON	= 40000		; /63/ set to write to disk, clear to suspend
     72		100000 				LOG$OP	= 100000	; logfile is open
     73		000003 				LOG$AL	= LOG$PA!LOG$CO	; /62/ ALL
     74
     75					;	parity options
     76		000000 				PAR$NO	=: 0		; none
     77		000001 				PAR$OD	=: 1		; odd
     78		000002 				PAR$EV	=: 2		; even
     79		000003 				PAR$MA	=: 3		; mark
     80		000004 				PAR$SP	=: 4		; space
     81
     82					;	file types
     83		177777 				TERMINAL=: -1		; file to term ala xreply, not to disk
     84		000000 				TEXT	=:  0		; normal ascii text files
     85		000001 				BINARY	=:  1		; image mode
     86		000002 				DECNAT	=:  2		; /52/ 8-bit text files
     87
     88					;	terminal types
     89		000000 				NOSCOPE	= 0		; /BBS/ hard copy terminal
     90		000001 				TTY	= 1		; a dumb tube terminal
     91		000002 				VT100	= 2		; itself
     92		000003 				VT200	= 3		; ditto..
     93
     94					;	supported CVT$$ cvt_bit_pattern bits
     95		000004 				C.CRLF	= 4		; discard CR LF FF ESC
     96		000010 				C.LSPA	= 10		; discard leading spaces and tabs
     97		000020 				C.SSPA	= 20		; reduce spaces and tabs to a single space
     98		000040 				C.LCUC	= 40		; lower case to upper case
     99		000200 				C.TSPA	= 200		; discard trailing spaces and tabs
    100
    101		000034 				CON$ESC	=  '\-100	; default CONNECT escape char
    102		000170 				ERBFSIZ	=  120.		; /62/ error msg text buff size
    103		000136 				MAXPAK	=:  94.		; /63/ max_packet_length - max_checksum_length
    104
    105						.if df	NONEIS		; /62/ using NONEIS for convenience..
    106						ALSIZE	=   1000	; /63/ bufsiz for SET DIAL/PHO NUM
    107						LN$CNT	=      3.	; /62/ save/recall 3. commands
    108						LN$MAX	=     80.	; /63/ max command line length
    109						MAXLNG	=    600.	; /63/ so image is small enuff to run
    110						.iff
    111		002000 				ALSIZE	=   2000	; /62/ bufsiz for SET DIAL/PHO NUM
    112		000012 				LN$CNT	=     10.	; /63/ save/recall 10. commands
    113		000204 				LN$MAX	=    132.	; /63/ max command line length
    114		003600 				MAXLNG	=   1920.	; /63/ use max long-packet buff size
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 4-2
KRTMAC	Various handy constants and macros

    115						.endc
    116		003614 				$ALLSIZ	= <MAXLNG+14>&177776 ; /62/ make it this for safety
    117
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 5
KRTMAC	Various handy constants and macros

      1
      2						.sbttl	Utility macros
      3
      4						.macro	.br to		; /63/ added
      5						.if df	to
      6						.if ne	to-.
      7						.error	<; not at location to;>
      8						.endc
      9						.endc
     10						.endm	.br
     11
     12						.macro	.chksp	arg
     13						.ntype	$$5	,arg
     14						.iif eq <<$$5&7>-6> .error arg <; Illegal use of SP (r6) in call>
     15						.endm	.chksp
     16
     17						.macro	calls	name	,arglst
     18					;	subroutine call with arguments passed in an area pointed to by r5
     19					;	(as with F4 and BP2).  all args are pushed onto the stack in the
     20					;	order specified.  r5 points to the sp before the call and is saved
     21					;	and restored.
     22						$$ = 0				; init # of args count
     23						  .irp x ,<arglst>		; count up # of args passed
     24						  $$ = $$+1			; one at a time
     25						  .endr				; got it
     26						.if eq $$			; no args present?
     27						jsr	pc	,name		; if so, substitute a simple call
     28						.iff				; at least one arg in <arglst>
     29						mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
     30						  .if eq $$-1			; is it one or more than one arg?
     31						  .chksp	arglst		; one arg, check for legal SP modes
     32						  mov	arglst	,-(sp)		; doing it thusly generates less code
     33						  mov	sp	,r5		; set pointer to argument list
     34						  jsr	pc	,name		; call the subroutine
     35						  tst	(sp)+			; pop parameter list from stack
     36						  mov	(sp)+	,r5		; /63/ restore r5
     37						  .iff				; arg_count > 1
     38						  $$2 = $$			; extract the args in
     39						    .rept	$$		; reverse order so that
     40						    $$1 = 0			; we might save a little
     41						      .irp x ,<arglst>		; core (four words)
     42						      $$1 = $$1+1		; scan the arg list until we come to
     43						        .if eq $$2-$$1		; the last one before one we just did
     44						        .chksp	x		; check for SP addressing mode
     45						        mov	x	,-(sp)	; push it
     46						        .mexit			; and exit the .irp
     47						        .endc
     48						      .endr
     49						    $$2 = $$2-1			; backwards to previous arg
     50						    .endr
     51						  mov	sp	,r5		; set up the argument list pointer
     52						  jsr	pc	,name		; and go to the routine
     53						  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
     54						  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
     55						  mov	(sp)+	,r5		; /63/ restore r5
     56						  .endc
     57						.endc
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 5-1
Utility macros

     58						.endm	calls
     59
     60						.macro	ctl	src ,dst
     61						clr	-(sp)
     62						bisb	src	,@sp
     63						call	l$xor
     64						movb	(sp)+	,dst
     65						.endm	ctl
     66
     67						.macro	copyz	from ,to ,maxlen
     68						.if  b	<maxlen>
     69						clr	-(sp)
     70						.iff
     71						mov	maxlen	,-(sp)
     72						.endc
     73						mov	from	,-(sp)
     74						mov	to	,-(sp)
     75						call	copyz$
     76						.endm	copyz
     77
     78						.macro	deccvt	val ,buf ,width
     79						mov	r5	,-(sp)
     80						.if  b	<width>
     81						clr	-(sp)
     82						.iff
     83						mov	width	,-(sp)
     84						.endc
     85						mov	val	,-(sp)
     86						mov	buf	,-(sp)
     87						mov	sp	,r5
     88						call	l$cvtnum
     89						add	#6	,sp
     90						mov	(sp)+	,r5
     91						.endm	deccvt
     92
     93						.macro	decout	val
     94						mov	r5	,-(sp)
     95						mov	val	,-(sp)		; /62/ l$wrdec pops this buffer
     96						mov	sp	,r5
     97						call	l$wrdec
     98						mov	(sp)+	,r5
     99						.endm	decout
    100
    101						.macro	direrr	val
    102						mov	val	,-(sp)
    103						call	direr$
    104						.endm	direrr
    105
    106						.macro	incm64	val
    107						inc	val
    108						bic	#^c<77>	,val		; /62/ faster
    109						.endm	incm64
    110
    111						.macro	indexm	reg		; check for auto increment/decrement
    112						.ntype	$$$0	,reg		; modes for macros that can't have..
    113						.if  ne	$$$0-27			; always allow pc autoincrement
    114						$$$0 =	<$$$0&177770>/10	; ..these modes in their arg list
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 5-2
Utility macros

    115						.ift				; get the mode into 0..7
    116						  .if  ge $$$0-2		; if mode >=2 and mode <=5 then error
    117						  .iif ge <5-$$$0> .error      <; Can't use auto inc/dec mode here>
    118						  .endc
    119						.endc
    120						.endm	indexm
    121
    122						.macro	ixor	reg ,dst
    123					;	get around the mode restrictions for the hardware XOR instruction
    124					;	and fix for RT-11 systems that don't have the EIS chip option
    125						.chksp	reg			; can't allow sp args
    126						.chksp	dst			; in either register
    127						indexm	reg			; check for allowed
    128						indexm	dst			; addressing mode
    129						mov	reg	,-(sp)		; it's much simpler to do this
    130						bic	dst	,@sp		; for all RT-11 systems rather
    131						bic	reg	,dst		; than to be selective
    132						bis	(sp)+	,dst		; done
    133						.endm	ixor
    134
    135						.macro	.newline		; print CR/LF on TT
    136						call	l$pcrlf
    137						.endm	.newline
    138
    139						.macro	octout	val
    140						calls	l$wroct	,<val>
    141						.endm	octout
    142
    143						.macro	prsbuf	dst
    144						mov	dst	,r0
    145						call	prsarg
    146						.endm	prsbuf
    147
    148						.macro	rpack	len.a ,pakn.a ,msg.a ,max.len	; /62/
    149						sub	#10	,sp
    150						mov	sp	,r1
    151						calls	rpack$	,<msg.a,r1,max.len>
    152						mov	(r1)+	,len.a
    153						mov	(r1)+	,pakn.a
    154						mov	@r1	,r1
    155						add	#10	,sp
    156						.endm	rpack
    157
    158						.macro	save	list
    159						.if  b	<list>
    160						 save	<r0,r1,r2,r3,r4,r5>
    161						.iff
    162						.irp	x ,<list>
    163						 mov	x	,-(sp)
    164						.endr
    165						.endc
    166						.endm	save
    167
    168						.macro	scan	ch ,str
    169						mov	str	,-(sp)
    170						clr	-(sp)
    171						bisb	ch	,@sp
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 5-3
Utility macros

    172						call	scanch
    173						.endm	scan
    174
    175						.macro	setpar	src ,dst
    176						movb	src	,-(sp)
    177						call	dopari
    178						movb	(sp)+	,dst
    179						.endm	setpar
    180
    181						.macro	spack	type ,pnum ,len ,msg
    182						.if  b	<len>
    183						.iif nb	<msg>	.error	<; bad call to SPACK macro>
    184						calls	spack$	,<type,pnum,#0,#null>
    185						.iff
    186						calls	spack$	,<type,pnum,len,msg>
    187						.endc
    188						.endm	spack
    189
    190						.macro	strcat	dst ,src
    191						mov	src	,-(sp)
    192						mov	dst	,-(sp)
    193						jsr	pc	,strcat
    194						.endm	strcat
    195
    196						.macro	strcpy	dst ,src
    197						mov	src	,-(sp)
    198						mov	dst	,-(sp)
    199						jsr	pc	,strcpy
    200						.endm	strcpy
    201
    202						.macro	strlen	string
    203						mov	string	,r0
    204						call	l$len
    205						.endm	strlen
    206
    207						.macro	textsrc	text
    208						.if  b	<text>
    209						clr	getcroutine		; /62/ reset to file I/O
    210						clr	tgetaddr
    211						.iff
    212						mov	#tgetcr0,getcroutine
    213						mov	text	,tgetaddr
    214						.endc
    215						.endm	textsrc
    216
    217						.macro	tochar	src ,dst
    218						clr	-(sp)
    219						bisb	src	,@sp
    220						add	#40	,@sp
    221						movb	(sp)+	,dst
    222						.endm	tochar
    223
    224						.macro	unchar	src ,dst
    225						clr	-(sp)
    226						bisb	src	,@sp
    227						sub	#40	,@sp
    228						movb	(sp)+	,dst
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 5-4
Utility macros

    229						.endm	unchar
    230
    231						.macro	unsave	list
    232						.if b <list>
    233						unsave	<r5,r4,r3,r2,r1,r0>
    234						.iff
    235						.irp	x ,<list>
    236						 mov	(sp)+	,x
    237						.endr
    238						.endc
    239						.endm	unsave
    240
    241						.macro	upcase	s		; /BBS/ added ..
    242						mov	s	,r0
    243						call	upcase			; /BBS/ upcase until null terminator
    244						.endm	upcase
    245
    246						.macro	upone	s		; /BBS/ added ..
    247						mov	s	,r0
    248						call	upone			; /BBS/ upcase only to next delimiter
    249						.endm	upone
    250
    251						.macro	wrtall	arg		; IO.WAL for an .asciz string
    252						mov	arg	,-(sp)		; pass the address
    253						call	wrtall			; do it
    254						.endm	wrtall
    255
    256						.macro	xor	reg ,dst
    257						ixor	reg	,dst
    258						.endm	xor
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 6
Utility macros

      1						.iif ndf  KRTINC  .error	<; .include for IN:KRTMAC.MAC failed>
      2
      3						.mcall	.DATE	,.GTIM		; /BBS/
      4
      5
      6	000000					.psect	$rwdata	,rw,d,lcl,rel,con
      7	000000	000000 			atrctx::.word	0			; /E64/ send attrs context (index)
      8	000002				curatr:	.blkb	200			; current attribute scratch buffer
      9	000202	000000 			day.x:	.word	0			; /BBS/ integer file create day
     10	000204	   000 	   000 	   000 	day.y:	.byte	0 ,0 ,0 ,0		; /BBS/ ascii file create day
     11	000210	000000 			mon.x:	.word	0			; /BBS/ integer file create month
     12	000212	   000 	   000 	   000 	mon.y:	.byte	0 ,0 ,0 ,0		; /BBS/ ascii file create month
     13	000216	   000 	   000 	   000 	sizbuf:	.byte	0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ; /BBS/ sn.xle ascii size
     14	000232	000000 	000000 		xblock:	.word	0 ,0			; /BBS/ buffer for sn.xle, .gtim
     15	000236	000000 			yr.x:	.word	0			; /BBS/ integer file create year
     16	000240	   000 	   000 	   000 	yr.y:	.byte	0 ,0 ,0 ,0 ,0 ,0	; /BBS/ ascii file create year
     17
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 7
Utility macros

      1
      2	000000					.psect	$code
      3						.sbttl	Send all attributes in a single packet	; /BBS/ modified to..
      4
      5					;	W $ A T T R
      6					;
      7					;	input:	 (r5)	= file lun
      8					;		2(r5)	= output packet buffer address
      9					;	output:	  r1	> 0 is packet length, 0 = receiver can't do attributes
     10
     11	000000				w$attr::save	<r2,r3,r4>
	000000	010246 				 mov	r2	,-(sp)
	000002	010346 				 mov	r3	,-(sp)
	000004	010446 				 mov	r4	,-(sp)
     12	000006	005001 				clr	r1			; preset in case other system
     13	000010	132767 	000010 	000011G		bitb	#capa.a	,conpar+p.capas	; can't handle attributes
     14	000016	001434 				beq	40$			; it can't
     15	000020	032767 	100000 	000000G		bit	#at.on	,doattr		; /63/ are attributes enabled?
     16	000026	001430 				beq	40$			; /63/ no
     17	000030	016504 	000002 			mov	2(r5)	,r4		; point to the packet
     18	000034	005067 	000000'			clr	atrctx			; init index
     19
     20	000040	016700 	000000'		10$:	mov	atrctx	,r0		; dispatch on what to send next
     21	000044	006300 				asl	r0			; word indexing
     22	000046	005760 	000000'			tst	watt(r0)		; all done?
     23	000052	001411 				beq	30$			; yes, finish up
     24	000054	036067 	000020'	000000G		bit	at.tx(r0),doattr	; /62/ is this attribute enabled?
     25	000062	001402 				beq	20$			; /62/ no
     26	000064	004770 	000000'			jsr	pc	,@watt(r0)	; do it
     27	000070	005267 	000000'		20$:	inc	atrctx			; index to next subroutine
     28	000074	000761 				br	10$			; loop back for it
     29
     30	000076				30$:	strlen	2(r5)			; get the length and return it
	000076	016500 	000002 			mov	2(r5)	,r0
	000102	004767 	000000G			call	l$len
     31	000106	010001 				mov	r0	,r1		; and say that this packet is for real
     32	000110	005000 			40$:	clr	r0			; no error possible
     33	000112					unsave	<r4,r3,r2>
	000112	012604 				 mov	(sp)+	,r4
	000114	012603 				 mov	(sp)+	,r3
	000116	012602 				 mov	(sp)+	,r2
     34	000120	000207 				return
     35
     36						.save
     37	000000					.psect	$pdata
     38	000000	000122'	000144'	000200'	watt:	.word	sn.sys	,sn.typ	,sn.pro	,sn.len	,sn.inf	,sn.cdt	,sn.xle
     39	000016	000000 			at.rx:	.word	0			; /62/ also terminates watt
     40	000020	000020 	000040 	000010 	at.tx:	.word	at.sys	,at.typ	,at.pro	,at.len	,at.inf	,at.cdt	,at.xle
     41	000122					.restore
     42
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 8
Send all attributes in a single packet	; /BBS/ modified to..

      1
      2						.sbttl	Send system type
      3
      4	000122	112724 	000056 		sn.sys:	movb	#'.	,(r4)+		; the system id attribute
      5	000126	112724 	000042 			movb	#42	,(r4)+		; /49/ length of what follows
      6	000132	112724 	000104 			movb	#'D&137	,(r4)+		; return the vendor code (DEC)
      7	000136	112724 	000102 			movb	#'B&137	,(r4)+		; /BBS/ it's RT-11 for sure here
      8	000142	000437 				br	sn.end			; /63/ go make it .asciz
      9
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 9
Send system type

      1
      2						.sbttl	Send generic file type
      3
      4	000144	112724 	000042 		sn.typ:	movb	#42	,(r4)+		; file type attribute
      5	000150	112724 	000041 			movb	#41	,(r4)+		; /49/ length of what follows
      6	000154	112700 	000101 			movb	#'A&137	,r0		; /BBS/ assume ascii
      7	000160	126727 	000000G	000001 		cmpb	image	,#binary	; is it binary or 8-bit text?
      8	000166	002402 				blt	10$			; /63/ no
      9	000170	112700 	000102 			movb	#'B&137	,r0		; /BBS/ yes, indicate it is..
     10	000174	110024 			10$:	movb	r0	,(r4)+		; /BBS/ put file type in packet
     11	000176	000421 				br	sn.end			; /63/ go make it .asciz
     12
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 10
Send generic file type

      1
      2						.sbttl	Send file protection	; /BBS/ fixed for RT-11
      3
      4	000200				sn.pro:					;	bit_0	=  read
      5										;	bit_1	=  write
      6					; protection codes from "Kermit, A		bit_2	=  execute
      7					; File Transfer Protocol," 1987, for		bit_3	=  append
      8					; the "-" (octal 55) attribute			bit_4	=  delete
      9										;	bit_5	=  directory
     10	000200	112724 	000055 			movb	#55	,(r4)+		; public file protection
     11	000204	112724 	000041 			movb	#41	,(r4)+		; length of what follows
     12	000210	011500 				mov	(r5)	,r0		; get lun
     13	000212	006300 				asl	r0			; word indexing
     14	000214	005760 	000000G			tst	prot.a(r0)		; is it protected?
     15	000220	001003 				bne	10$			; ya
     16	000222	012700 	000077 			mov	#<1!2!4!10!20!40>,r0	; no, set bits 0 thru 5
     17	000226	000402 				br	20$			; continue
     18	000230	012700 	000045 		10$:	mov	#<1!4!40>,r0		; protected, set bits 0,2,5 only
     19	000234	062700 	000040 		20$:	add	#40	,r0		; tochar r0
     20	000240	110024 				movb	r0	,(r4)+		; put it into packet
     21	000242	105014 			sn.end:	clrb	@r4			; .asciz
     22	000244	000207 				return
     23
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 11
Send file protection	; /BBS/ fixed for RT-11

      1
      2						.sbttl	Send file length	; /BBS/
      3
      4	000246	011501 			sn.len:	mov	(r5)	,r1		; lun open to the file
      5	000250	006301 				asl	r1			; word indexing
      6	000252	016101 	000000G			mov	sizof(r1),r1		; get file size
      7	000256	005201 				inc	r1			; accommodate rounding to
      8	000260	006201 				asr	r1			; 1024. byte blocks, not 512.
      9	000262	001001 				bne	10$			; /BBS/ something is left of size..
     10	000264	005201 				inc	r1			; /BBS/ no, make it at least one block
     11	000266	112724 	000041 		10$:	movb	#41	,(r4)+		; attribute type (file size)
     12	000272	112724 	000045 			movb	#45	,(r4)+		; length of the number
     13	000276					deccvt	r1	,r4	,#5	; convert to ascii
	000276	010546 				mov	r5	,-(sp)
	000300	012746 	000005 			mov	#5	,-(sp)
	000304	010146 				mov	r1	,-(sp)
	000306	010446 				mov	r4	,-(sp)
	000310	010605 				mov	sp	,r5
	000312	004767 	000000G			call	l$cvtnum
	000316	062706 	000006 			add	#6	,sp
	000322	012605 				mov	(sp)+	,r5
     14	000324	012700 	000005 			mov	#5	,r0		; for 5 chars
     15	000330	121427 	000040 		20$:	cmpb	@r4	,#space		; if a space, then make it a "0"
     16	000334	001002 				bne	30$			; not a space
     17	000336	112714 	000060 			movb	#'0	,@r4		; it was a space
     18	000342	005204 			30$:	inc	r4			; next
     19	000344	077007 				sob	r0	,20$		; please
     20	000346	000735 			40$:	br	sn.end			; /63/ go make it .asciz
     21
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 12
Send file length	; /BBS/

      1
      2						.sbttl	Send system specific info	; /52/ added /BBS/ cleaned up
      3
      4	000350	112724 	000060 		sn.inf:	movb	#'0	,(r4)+		; DEC-specific file type
      5	000354	112724 	000042 			movb	#42	,(r4)+		; length of data to follow
      6	000360	112724 	000042 			movb	#42	,(r4)+		; sending extended file type
      7	000364	016700 	000000G			mov	image	,r0		; use this to index to it
      8	000370	116024 	000036'			movb	sn$inf(r0),(r4)+	; /63/ insert it
      9	000374	000722 				br	sn.end			; /63/ go make it .asciz
     10
     11						.save
     12	000036					.psect	$pdata
     13	000036	   101 	   111 	   116 	sn$inf:	.byte	'A&137	,'I&137	,'N&137
     14						.even
     15	000376					.restore
     16
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 13
Send system specific info	; /52/ added /BBS/ cleaned up

      1
      2						.sbttl	Get file creation date/time	; /BBS/ added this..
      3
      4	000376				sn.cdt:	save	<r4>			; pointer to current position in buff
	000376	010446 				 mov	r4	,-(sp)
      5	000400	011504 				mov	(r5)	,r4		; channel
      6	000402	006304 				asl	r4			; word offsets
      7	000404	016400 	000000G			mov	date.a(r4),r0		; recover current file's date
      8	000410	012701 	000002'			mov	#curatr	,r1		; the result address
      9
     10	000414	010003 				mov	r0	,r3		; copy the date to extract
     11	000416	042703 	177740 			bic	#^c<37>	,r3		; the year
     12	000422	062703 	003664 			add	#1972.	,r3		; plus the bias please
     13	000426	010002 				mov	r0	,r2		; copy the date
     14	000430	042702 	037777 			bic	#^c<140000>,r2		; extend max year w/two hi bits
     15	000434	000302 				swab	r2			; two hi bits now are bits 7,6
     16	000436	006202 				asr	r2			; shift to bits 6,5 (true value)
     17	000440	060203 				add	r2	,r3		; add to total years
     18	000442	004767 	000000G			call	i4toa			; do all 4 digits of year
     19
     20	000446	010003 				mov	r0	,r3		; copy to extract months
     21	000450	000303 				swab	r3			; get the month to bits 7..2
     22	000452	006203 				asr	r3			; now bits 6..1
     23	000454	006203 				asr	r3			; now bits 5..0
     24	000456	042703 	177740 			bic	#^c<37>	,r3		; hose everything else
     25	000462	004767 	000000G			call	i2toa			; write ascii to out buff
     26
     27	000466	010003 				mov	r0	,r3		; copy to extract day of month
     28	000470	072327 	000003 			ash	#3	,r3		; /62/ shift left 3 places
     29	000474	000303 				swab	r3			; then swap bytes to get
     30	000476	042703 	177740 			bic	#^c<37>	,r3		; the date
     31	000502	004767 	000000G			call	i2toa			; write ascii to out buff
     32
     33	000506	005767 	000000G			tst	tsxsav			; only do file time under TSX
     34	000512	001434 				beq	10$			; it's not TSX
     35	000514	112721 	000040 			movb	#space	,(r1)+		; a space delimiter between date,time
     36
     37	000520	016403 	000000G			mov	time.a(r4),r3		; recover current file's time
     38	000524	005002 				clr	r2			; clear hi word for upcoming divide
     39	000526	071227 	000024 			div	#20.	,r2		; get # of 3-sec units since midnight
     40	000532	010346 				mov	r3	,-(sp)		; put on stack
     41	000534	006303 				asl	r3			; 2x secs
     42	000536	060316 				add	r3	,(sp)		; plus 1x = 3x = number_of_seconds
     43	000540	010203 				mov	r2	,r3		; get rest of time
     44	000542	005002 				clr	r2			; set up for next divide
     45	000544	071227 	000074 			div	#60.	,r2		; get number of minutes
     46	000550	010346 				mov	r3	,-(sp)		; and save on stack
     47	000552	010203 				mov	r2	,r3		; this is the number of hours
     48	000554	004767 	000000G			call	i2toa			; write ascii to out buff
     49	000560	112721 	000072 			movb	#':	,(r1)+		; a colon into the buffer
     50	000564	012603 				mov	(sp)+	,r3		; recover minutes
     51	000566	004767 	000000G			call	i2toa			; write ascii to out buff
     52	000572	112721 	000072 			movb	#':	,(r1)+		; a colon into the buffer
     53	000576	012603 				mov	(sp)+	,r3		; recover secs
     54	000600	004767 	000000G			call	i2toa			; write ascii to out buff
     55
     56	000604	105011 			10$:	clrb	@r1			; .asciz
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 13-1
Get file creation date/time	; /BBS/ added this..

     57	000606					unsave	<r4>			; recover packet buffer pointer
	000606	012604 				 mov	(sp)+	,r4
     58	000610	012701 	000002'			mov	#curatr	,r1		; pointer to string just built
     59	000614					strlen	r1			; get length of string
	000614	010100 				mov	r1	,r0
	000616	004767 	000000G			call	l$len
     60	000622	062700 	000040 			add	#40	,r0		; encode length (tochar..)
     61	000626	112724 	000043 			movb	#'#	,(r4)+		; file create time/date data
     62	000632	110024 				movb	r0	,(r4)+		; put length into packet buffer
     63	000634	112124 			20$:	movb	(r1)+	,(r4)+		; then copy data into it
     64	000636	001376 				bne	20$			; until null
     65	000640	005304 				dec	r4			; bump pointer back to the null
     66	000642	000207 				return
     67
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 14
Get file creation date/time	; /BBS/ added this..

      1
      2						.sbttl	Send file length in bytes  ; /BBS/ all new
      3
      4	000644	011503 			sn.xle:	mov	(r5)	,r3		; file open on this chan
      5	000646	006303 				asl	r3			; word indexing
      6	000650	005002 				clr	r2			; double precision, init high word
      7	000652	016303 	000000G			mov	sizof(r3),r3		; size in the accumulator low word
      8	000656	001001 				bne	10$			; something is there
      9	000660	005203 				inc	r3			; make it at least one block
     10	000662	012700 	001000 		10$:	mov	#512.	,r0		; setup call to $dmul, size*512.
     11	000666	004767 	001516 			call	$dmul			; double precision multiply
     12	000672	010067 	000232'			mov	r0	,xblock		; save hi word
     13	000676	010167 	000234'			mov	r1	,xblock+2	; save low word
     14	000702	005002 				clr	r2			; suppress leading zeros in output
     15	000704	012701 	000232'			mov	#xblock	,r1		; address of 32-bit number
     16	000710	012700 	000216'			mov	#sizbuf	,r0		; address of out buff for ascii
     17	000714	004767 	000000G			call	$cddmg			; convert 32-bit integer to ascii
     18	000720	105010 				clrb	@r0			; null terminate the string
     19	000722	122767 	000052 	000216'		cmpb	#'*	,sizbuf		; did $cddmg overflow?
     20	000730	001415 				beq	30$			; ya, bail out..
     21	000732					strlen	#sizbuf			; get its length
	000732	012700 	000216'			mov	#sizbuf	,r0
	000736	004767 	000000G			call	l$len
     22	000742	112724 	000061 			movb	#61	,(r4)+		; attribute type (exact size in bytes)
     23	000746	062700 	000040 			add	#40	,r0		; tochar the string length
     24	000752	110024 				movb	r0	,(r4)+		; stuff into the attribute string
     25	000754	012700 	000216'			mov	#sizbuf	,r0		; get pointer to the length string
     26	000760	112024 			20$:	movb	(r0)+	,(r4)+		; then copy ascii'd length into attr$
     27	000762	001376 				bne	20$			; until hitting the null terminator
     28	000764	000207 			30$:	return
     29
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 15
Send file length in bytes  ; /BBS/ all new

      1
      2						.sbttl	Received attribute packet processing
      3
      4					;	R $ A T T R
      5					;
      6					;	input:	 (r5)	= packet buffer address
      7					;	output:	  r0	= if <>, error code
      8
      9	000766				r$attr::save	<r1,r2,r5>		; /BBS/ cleaned this up a bit..
	000766	010146 				 mov	r1	,-(sp)
	000770	010246 				 mov	r2	,-(sp)
	000772	010546 				 mov	r5	,-(sp)
     10	000774	032767 	100000 	000000G		bit	#at.on	,doattr		; /63/ attribute processing enabled?
     11	001002	001477 				beq	70$			; /62/ nope
     12	001004	011505 				mov	@r5	,r5		; /49/ get packet data address
     13
     14	001006	112500 			10$:	movb	(r5)+	,r0		; /49/ attribute type code
     15	001010	001447 				beq	60$			; /49/ nothing there..
     16	001012	112501 				movb	(r5)+	,r1		; /49/ get length field next
     17	001014	001445 				beq	60$			; /49/ nothing there..
     18	001016	120027 	000056 			cmpb	r0	,#'.		; /49/ if this is an OLD Kermit-11
     19	001022	001006 				bne	20$			; /49/ with the invalid system type
     20	001024	120127 	000104 			cmpb	r1	,#'D&137	; /49/ format then we have to fix it
     21	001030	001003 				bne	20$			; /49/ it is not..
     22	001032	005305 				dec	r5			; /49/ it is, we'd been forgetting to
     23	001034	012701 	000042 			mov	#42	,r1		; /49/ include the length field
     24
     25	001040	162701 	000040 		20$:	sub	#40	,r1		; /49/ convert length to integer
     26	001044	003431 				ble	60$			; /BBS/ nothing there
     27	001046	012702 	000002'			mov	#curatr	,r2		; /49/ copy current attribute argument
     28	001052	112522 			30$:	movb	(r5)+	,(r2)+		; /49/ over to a save area now
     29	001054	077102 				sob	r1	,30$		; /49/ next please
     30	001056	105022 				clrb	(r2)+			; /49/ ensure .asciz please
     31	001060	010546 				mov	r5	,-(sp)		; /49/ make sure the r5 context saved
     32	001062					scan	r0	,#attrty	; look for the attribute packet type?
	001062	012746 	000042'			mov	#attrty	,-(sp)
	001066	005046 				clr	-(sp)
	001070	150016 				bisb	r0	,@sp
	001072	004767 	000000G			call	scanch
     33	001076	006300 				asl	r0			; simple to do
     34	001100	036067 	000016'	000000G		bit	at.rx(r0),doattr	; /62/ is this attribute enabled?
     35	001106	001002 				bne	40$			; /62/ ya
     36	001110	005000 				clr	r0			; /62/ no, check for
     37	001112	000402 				br	50$			; /62/ more attributes
     38	001114	004770 	000052'		40$:	jsr	pc	,@attrds(r0)	; process the attribute packet now
     39	001120	012605 			50$:	mov	(sp)+	,r5		; /49/ restore the r5 context now
     40	001122	005700 				tst	r0			; success?
     41	001124	001730 				beq	10$			; yes
     42	001126	000426 				br	80$			; no, exit with error in r0
     43
     44	001130	004767 	001210 		60$:	call	ispdp			; /62/ if other end is RT-11 or TSX..
     45	001134	020027 	000004 			cmp	r0	,#4		; /62/ well?
     46	001140	001420 				beq	70$			; /62/ it is, so file sizes are exact
     47	001142	026727 	000000G	000001 		cmp	image	,#binary	; /62/ then if file type isn't binary
     48	001150	001414 				beq	70$			; /62/ it is, image size is always ok
     49	001152	016700 	000000G			mov	at$len	,r0		; /62/ otherwise save the passed size
     50	001156	001412 				beq	80$			; /62/ nothing was there, r0 is clear
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 15-1
Received attribute packet processing

     51	001160	006200 				asr	r0			; /62/ divide by two
     52	001162	006200 				asr	r0			; /62/ now it's by four, 25% of total
     53	001164	005200 				inc	r0			; /62/ bump one more block to be sure
     54	001166	060067 	000000G			add	r0	,at$len		; /62/ now bump requested space by 25%
     55	001172	103003 				bcc	70$			; /62/ result didn't overflow
     56	001174	012767 	177731 	000000G		mov	#65497.	,at$len		; /62/ it did, try the max possible..
     57	001202	005000 			70$:	clr	r0			; packet format error or end of data
     58	001204				80$:	unsave	<r5,r2,r1>
	001204	012605 				 mov	(sp)+	,r5
	001206	012602 				 mov	(sp)+	,r2
	001210	012601 				 mov	(sp)+	,r1
     59	001212	000207 				return
     60
     61						.save
     62	000042					.psect	$pdata
     63	000042	   056 	   042 	   055 	attrty:	.byte	56	,42	,55	,41	,60	,43	,61
     64	000051	   000 				.byte	0
     65						.even
     66	000052	001214'			attrds:	.word	rx.$$			; /62/ must conform to at.rx
     67	000054	002142'	001302'	002106'		.word	rx.sys	,rx.typ	,rx.pro	,rx.len	,rx.inf	,rx.cdt	,rx.xle
     68	001214					.restore
     69
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 16
Received attribute packet processing

      1
      2						.sbttl	Null attribute handler
      3
      4	001214	005000 			rx.$$:	clr	r0			; /49/ ignore unknown attribute types
      5	001216	000207 				return
      6
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 17
Null attribute handler

      1
      2						.sbttl	Process received length specified in 1024. byte blocks
      3
      4	001220	005767 	000000G		rx.len:	tst	at$len			; /BBS/ size from rx.xle already here?
      5	001224	001024 				bne	40$			; /BBS/ ya, use it instead of this
      6	001226	012702 	000002'			mov	#curatr	,r2		; /49/ where we saved attributes
      7	001232	005001 				clr	r1			; init the accumulator
      8	001234	105712 			10$:	tstb	@r2			; EOL?
      9	001236	001414 				beq	30$			; yep
     10	001240	121227 	000040 			cmpb	@r2	,#space		; ignore leading spaces please
     11	001244	001407 				beq	20$			; yes, a space
     12	001246	005046 				clr	-(sp)			; avoid sxt
     13	001250	151216 				bisb	@r2	,@sp		; get the next digit please
     14	001252	162716 	000060 			sub	#'0	,@sp		; and convert to decimal
     15	001256	070127 	000012 			mul	#12	,r1		; shift accum over 10.
     16	001262	062601 				add	(sp)+	,r1		; add in the current digit
     17	001264	005202 			20$:	inc	r2			; next ch please
     18	001266	000762 				br	10$			; /49/ Next please
     19	001270	006301 			30$:	asl	r1			; convert 1024. blocks to 512. blocks
     20	001272	010167 	000000G			mov	r1	,at$len		; save it please
     21	001276	005000 			40$:	clr	r0			; success
     22	001300	000207 				return
     23
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 18
Process received length specified in 1024. byte blocks

      1
      2						.sbttl	Received file type
      3
      4	001302	005767 	000000G		rx.typ:	tst	doauto			; /BBS/ auto file type enabled?
      5	001306	001004 				bne	10$			; /BBS/ ya
      6	001310	016767 	000000G	000000G		mov	$image	,image		; /BBS/ no, use what's SET
      7	001316	000413 				br	30$
      8	001320	126727 	000002'	000102 	10$:	cmpb	curatr	,#'B&137	; binary?
      9	001326	001404 				beq	20$			; yes
     10	001330	126727 	000002'	000111 		cmpb	curatr	,#'I&137	; image?
     11	001336	001003 				bne	30$			; no
     12	001340	012767 	000001 	000000G	20$:	mov	#binary	,image		; flag for image mode
     13	001346	005000 			30$:	clr	r0			; success
     14	001350	000207 				return
     15
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 19
Received file type

      1
      2						.sbttl	Put create date/time where close can get them later ; /BBS/
      3
      4	001352	005046 			rx.cdt:	clr	-(sp)			; init 2 digit year flag
      5	001354					scan	#space	,#curatr	; find the space between date and time
	001354	012746 	000002'			mov	#curatr	,-(sp)
	001360	005046 				clr	-(sp)
	001362	152716 	000040 			bisb	#space	,@sp
	001366	004767 	000000G			call	scanch
      6	001372	005700 				tst	r0			; get it?
      7	001374	001010 				bne	10$			; ya..
      8	001376					strlen	#curatr			; no time is there
	001376	012700 	000002'			mov	#curatr	,r0
	001402	004767 	000000G			call	l$len
      9	001406	020027 	000007 			cmp	r0	,#7		; 2 or 4 digit year?
     10	001412	003004 				bgt	20$			; it's 4
     11	001414	000404 				br	30$			; it's 2
     12
     13	001416	020027 	000010 		10$:	cmp	r0	,#10		; 2 or 4 digit year?
     14	001422	002401 				blt	30$			; 2 digits
     15	001424	010616 			20$:	mov	sp	,(sp)		; 4 digits, set flag
     16	001426	012701 	000002'		30$:	mov	#curatr	,r1		; pointer to date/time packet data
     17	001432	012700 	000240'			mov	#yr.y	,r0		; extract the ascii year here
     18	001436	004767 	000402 			call	mov2b			; copy two bytes
     19	001442	005726 				tst	(sp)+			; two or four digit year string?
     20	001444	001402 				beq	40$			; just two
     21	001446	004767 	000372 			call	mov2b			; copy two bytes
     22	001452	012700 	000212'		40$:	mov	#mon.y	,r0		; extract the ascii month here
     23	001456	004767 	000362 			call	mov2b			; copy two bytes
     24	001462	012700 	000204'			mov	#day.y	,r0		; extract the ascii day here
     25	001466	004767 	000352 			call	mov2b			; copy two bytes
     26
     27	001472					save	<r1>			; save pointer to time string
	001472	010146 				 mov	r1	,-(sp)
     28
     29	001474	012703 	000240'			mov	#yr.y	,r3		; recover ascii year
     30	001500	004767 	000350 			call	gnum			; make it an integer
     31	001504	010167 	000236'			mov	r1	,yr.x		; and save it here
     32	001510	012703 	000212'			mov	#mon.y	,r3		; recover ascii month
     33	001514	004767 	000334 			call	gnum			; make it an integer
     34	001520	010167 	000210'			mov	r1	,mon.x		; and save it here
     35	001524	012703 	000204'			mov	#day.y	,r3		; recover ascii day
     36	001530	004767 	000320 			call	gnum			; make it an integer
     37	001534	010167 	000202'			mov	r1	,day.x		; and save it here
     38
     39						;  2_bits<year_ext> ,4_bits<mon> ,5_bits<day> ,5_bits<year-1972>
     40	001540	016701 	000210'			mov	mon.x	,r1		; recover month
     41	001544	072127 	000005 			ash	#5	,r1		; partial shift towards final location
     42	001550	066701 	000202'			add	day.x	,r1		; recover days
     43	001554	072127 	000005 			ash	#5	,r1		; shift days/months to final positions
     44	001560	016746 	000236'			mov	yr.x	,-(sp)		; recover year
     45	001564	021627 	000144 			cmp	(sp)	,#100.		; is it two digits only?
     46	001570	002040 				bge	60$			; no
     47	001572	021627 	000107 			cmp	(sp)	,#71.		; ya but ambiguity impossible 'til '72
     48	001576	003433 				ble	50$			; it has to be 21st century
     49
     50						; if two-digit year extend to four-digits based on the current century
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 19-1
Put create date/time where close can get them later ; /BBS/

     51	001600					.gtim	#rtwork	,#xblock	; ensure clock rollover..
	001600	012700 	000000G			MOV	#rtwork,R0
	001604	012710 	010400 			MOV	#17.*^O400+0.,@R0
	001610	012760 	000232'	000002 		MOV	#xblock,2.(R0)
	001616	104375 				EMT	^O375
     52	001620					.date				; ya, which century is it now?
	001620	012700 	005000 			MOV	#^O5000,R0
	001624	104374 				EMT	^O374
     53	001626	010003 				mov	r0	,r3		; copy the date
     54	001630	042703 	177740 			bic	#^c<37>	,r3		; the year
     55	001634	062703 	003664 			add	#1972.	,r3		; plus the bias
     56	001640	042700 	037777 			bic	#^c<140000>,r0		; extend max year w/two hi bits
     57	001644	000300 				swab	r0			; two hi bits now are bits 7,6
     58	001646	006200 				asr	r0			; shift to bits 6,5 (true value)
     59	001650	060003 				add	r0	,r3		; now it's the total years
     60	001652	020327 	003717 			cmp	r3	,#1999.		; well?
     61	001656	003003 				bgt	50$			; it's 2000 A.D. or above
     62	001660	062716 	003554 			add	#1900.	,(sp)		; not 2000 A.D. yet ..
     63	001664	000402 				br	60$			; and continue
     64	001666	062716 	003720 		50$:	add	#2000.	,(sp)		; default to current century
     65
     66	001672	162716 	003664 		60$:	sub	#1972.	,(sp)		; RT-11 dates begin at 1972..
     67	001676	002002 				bge	70$			; an ok date for RT-11
     68	001700	005001 				clr	r1			; a bad date, so hose it
     69	001702	000411 				br	80$			; and continue..
     70
     71	001704	011600 			70$:	mov	(sp)	,r0		; copy to..
     72	001706	042700 	177637 			bic	#^c<100!40>,r0		; ..extract bits 6,5
     73	001712	006300 				asl	r0			; shift them to bits 7,6
     74	001714	000300 				swab	r0			; now they are the two hi bits
     75	001716	042716 	177740 			bic	#^c<37>	,(sp)		; hose possible hi bits in here
     76	001722	061601 				add	(sp)	,r1		; and add it into the date word
     77	001724	050001 				bis	r0	,r1		; then insert year extension bits
     78
     79	001726	005726 			80$:	tst	(sp)+			; pop buffer
     80	001730	012700 	000000G			mov	#lun.ou	,r0		; assume it's the output file
     81	001734	006300 				asl	r0			; word indexing
     82	001736	010160 	000000G			mov	r1	,date.a(r0)	; save date for use when closing file
     83
     84	001742					unsave	<r1>			; recover pointer to time string
	001742	012601 				 mov	(sp)+	,r1
     85	001744	105721 				tstb	(r1)+			; bump past space delimiter
     86	001746	001434 				beq	100$			; no time supplied
     87
     88	001750	010103 				mov	r1	,r3		; now do time..  copy pointer
     89	001752	004767 	000076 			call	gnum			; convert hours to integer
     90	001756	070127 	002260 			mul	#<60.*20.>,r1		; and to 3-sec intervals
     91	001762	010146 				mov	r1	,-(sp)		; save them
     92	001764	005203 				inc	r3			; bump past colon
     93	001766	004767 	000062 			call	gnum			; convert mins to integer
     94	001772	070127 	000024 			mul	#20.	,r1		; and to 3-sec intervals
     95	001776	010146 				mov	r1	,-(sp)		; save them
     96	002000	005001 				clr	r1			; preset in case no seconds supplied
     97	002002	122327 	000072 			cmpb	(r3)+	,#':		; if not a colon, there's no secs
     98	002006	001005 				bne	90$			; done
     99	002010	004767 	000040 			call	gnum			; convert secs to integer
    100	002014	005000 				clr	r0			; prep for divide
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 19-2
Put create date/time where close can get them later ; /BBS/

    101	002016	071027 	000003 			div	#3	,r0		; and to 3-sec intervals
    102	002022	062600 			90$:	add	(sp)+	,r0		; add in minutes data
    103	002024	062600 				add	(sp)+	,r0		; add in hours data
    104	002026	012701 	000000G			mov	#lun.ou	,r1		; assume it's the output file
    105	002032	006301 				asl	r1			; word indexing
    106	002034	010061 	000000G			mov	r0	,time.a(r1)	; save time for use when closing file
    107	002040	005000 			100$:	clr	r0			; success
    108	002042	000207 				return
    109
    110	002044	112120 			mov2b:	movb	(r1)+	,(r0)+		; move two bytes
    111	002046	112120 				movb	(r1)+	,(r0)+
    112	002050	105010 				clrb	(r0)			; null terminate
    113	002052	000207 				return
    114
    115	002054	005001 			gnum:	clr	r1			; the answer  ; return the next number
    116	002056	112300 			110$:	movb	(r3)+	,r0		; next char
    117	002060	162700 	000072 			sub	#'9+1	,r0		; convert ascii byte
    118	002064	062700 	000012 			add	#9.+1	,r0		; to an integer
    119	002070	103004 				bcc	120$			; not a number
    120	002072	070127 	000012 			mul	#10.	,r1		; bump accumulator by 10s
    121	002076	060001 				add	r0	,r1		; add in result from this pass
    122	002100	000766 				br	110$			; then try the next byte
    123	002102	105743 			120$:	tstb	-(r3)			; park on first non-numeric byte
    124	002104	000207 				return
    125
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 20
Put create date/time where close can get them later ; /BBS/

      1
      2						.sbttl	Put file protection code where close can get it later ; /BBS/
      3
      4	002106	012701 	000000G		rx.pro:	mov	#lun.ou	,r1		; assume output file
      5	002112	006301 				asl	r1			; word indexing
      6	002114	142767 	000345 	000002'		bicb	#<1!4!40!100!200>,curatr ; hose bits 0,2,5 and unused bits 6,7
      7	002122	001403 				beq	10$
      8	002124	005061 	000000G			clr	prot.a(r1)		; it's read-write
      9	002130	000402 				br	20$
     10	002132	010661 	000000G		10$:	mov	sp	,prot.a(r1)	; it's read-only
     11	002136	005000 			20$:	clr	r0			; success
     12	002140	000207 				return
     13
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 21
Put file protection code where close can get it later ; /BBS/

      1
      2						.sbttl	Received system type
      3
      4	002142	116767 	000002'	000000G	rx.sys:	movb	curatr	,at$sys		; save major vendor type
      5	002150	116767 	000003'	000001G		movb	curatr+1,at$sys+1	; save the operating system type
      6	002156	005000 				clr	r0			; success
      7	002160	000207 				return
      8
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 22
Received system type

      1
      2						.sbttl	Receive system specific info
      3
      4	002162	004767 	000156 		rx.inf:	call	ispdp			; are we
      5	002166	005700 				tst	r0			; compatible today?
      6	002170	001422 				beq	10$			; no, ignore the system dep attr's
      7	002172	012700 	000002'			mov	#curatr	,r0		; /BBS/ current attribute data
      8	002176	122027 	000042 			cmpb	(r0)+	,#42		; /53/ file type subfunction?
      9	002202	001015 				bne	10$			; /53/ no, ignore for now
     10	002204	005767 	000000G			tst	doauto			; /BBS/ auto file type enabled?
     11	002210	001412 				beq	10$			; /BBS/ no, ignore this stuff..
     12	002212					scan	(r0)	,#rx$in0	; /63/ get IFAB file attributes data
	002212	012746 	000072'			mov	#rx$in0	,-(sp)
	002216	005046 				clr	-(sp)
	002220	151016 				bisb	(r0)	,@sp
	002222	004767 	000000G			call	scanch
     13	002226	006300 				asl	r0			; /53/ word addressing
     14	002230	016067 	000100'	000000G		mov	rx$in1(r0),image	; /63/ set it
     15	002236	005000 			10$:	clr	r0
     16	002240	000207 				return
     17
     18						.save
     19	000072					.psect	$pdata
     20	000072	   101 	   102 	   111 	rx$in0:	.byte	'A&137	,'B&137	,'I&137	,'N&137	; /63/ add "B" type
     21	000076	   000 				.byte	0
     22						.even
     23	000100	000000 			rx$in1:	.word	TEXT			; if not in this list call it text
     24	000102	000000 	000001 	000001 		.word	TEXT	,BINARY	,BINARY	,DECNAT
     25	002242					.restore
     26
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 23
Receive system specific info

      1
      2						.sbttl	Exact file size in bytes (type "1")
      3
      4	002242	012705 	000002'		rx.xle:	mov	#curatr	,r5		; /49/ point to attribute save area
      5	002246	005003 				clr	r3			; /49/ init the accumulator (low word)
      6	002250	005002 				clr	r2			; /49/ double precision (high word)
      7	002252	105715 			10$:	tstb	@r5			; /49/ EOL?
      8	002254	001421 				beq	30$			; /49/ yep
      9	002256	121527 	000040 			cmpb	@r5	,#space		; /49/ ignore leading spaces please
     10	002262	001414 				beq	20$			; /49/ yes, a space
     11	002264	012700 	000012 			mov	#12	,r0		; /49/ setup for call to $dmul
     12	002270	004767 	000114 			call	$dmul			; /49/ do it please
     13	002274	010002 				mov	r0	,r2		; /49/ restore accumulator values now
     14	002276	010103 				mov	r1	,r3		; /49/ ditto...
     15	002300	005046 				clr	-(sp)			; /49/ get the next digit please
     16	002302	151516 				bisb	@r5	,@sp		; /BBS/ convert to decimal
     17	002304	162716 	000060 			sub	#'0	,@sp		; /49/ got it
     18	002310	062603 				add	(sp)+	,r3		; /49/ add in the current digit
     19	002312	005502 				adc	r2			; /49/ add carry bit in also please
     20	002314	005205 			20$:	inc	r5			; /49/ next ch please
     21	002316	000755 				br	10$			; /49/ next please
     22	002320	071227 	001000 		30$:	div	#1000	,r2		; /BBS/ convert to 512 byte blocks now
     23	002324	010267 	000000G			mov	r2	,at$len		; /49/ save it please
     24	002330	005703 				tst	r3			; /BBS/ was there a remainder?
     25	002332	001402 				beq	40$			; /49/ no, exit
     26	002334	005267 	000000G			inc	at$len			; /49/ yes, len++
     27	002340	005000 			40$:	clr	r0			; success
     28	002342	000207 				return
     29
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 24
Exact file size in bytes (type "1")

      1
      2						.sbttl	Determine if other system is a PDP-11
      3
      4					;	I S P D P
      5					;
      6					;	output:	r0 = 5	other system running POS
      7					;		     4	RT-11 or TSX+
      8					;		     3	RSTS
      9					;		     2	IAS
     10					;		     1	RSX
     11					;		     0	it's something else..
     12
     13		000070 				PD$RSX	= '8
     14		000071 				PD$IAS	= '9
     15		000101 				PD$RSTS	= 'A&137
     16		000102 				PD$RT	= 'B&137		; includes TSX
     17		000103 				PD$POS	= 'C&137
     18
     19	002344	005000 			ispdp:	clr	r0			; presume failure
     20	002346	126727 	000000G	000104 		cmpb	at$sys	,#'D&137	; a DEC system?
     21	002354	001007 				bne	10$			; no, exit
     22	002356					scan	<at$sys+1>,#pdplst	; ya, determine operating system type
	002356	012746 	000112'			mov	#pdplst	,-(sp)
	002362	005046 				clr	-(sp)
	002364	156716 	000001G			bisb	at$sys+1	,@sp
	002370	004767 	000000G			call	scanch
     23	002374	000207 			10$:	return
     24
     25						.save
     26	000112					.psect	$pdata
     27	000112	   070 	   071 	   101 	pdplst:	.byte	pd$rsx	,pd$ias	,pd$rsts,pd$rt	,pd$pos	,0
     28						.even
     29	002376					.restore
     30
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 25
Determine if other system is a PDP-11

      1
      2						.sbttl	Clear attributes
      3
      4	002376	005067 	000000G		clratr::clr	at$len			; clear the file length
      5	002402	005067 	000000G			clr	at$sys			; clear the system type
      6	002406	000207 				return
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 26
Clear attributes

      1
      2						.sbttl	32-bit multiply from RSX SYSLIB.OLB
      3
      4	002410	010046 			$DMUL:	MOV	R0	,-(SP)
      5	002412	005000 				CLR	R0
      6	002414	005001 				CLR	R1
      7	002416	005716 			10$:	TST	(SP)
      8	002420	001410 				BEQ	30$
      9	002422	006016 				ROR	(SP)
     10	002424	103003 				BCC	20$
     11	002426	060301 				ADD	R3	,R1
     12	002430	005500 				ADC	R0
     13	002432	060200 				ADD	R2	,R0
     14	002434	006303 			20$:	ASL	R3
     15	002436	006102 				ROL	R2
     16	002440	000766 				BR	10$
     17	002442	005726 			30$:	TST	(SP)+
     18	002444	000207 				RETURN
     19
     20		000001 				.end
KRTATR	Process attribute packe	MACRO V05.03b  00:00  Page 26-1
Symbol table

ALSIZE= 002000   	C.CRLF= 000004   	LOG$DE= 000020   	P.MXL2= 000014   	SN.LEN  000246R     002
ATRCTX  000000RG    004	C.LCUC= 000040   	LOG$IO= 000010   	P.NPAD= 000002   	SN.PRO  000200R     002
ATTRDS  000052R     003	C.LSPA= 000010   	LOG$ON= 040000   	P.PADC= 000003   	SN.SYS  000122R     002
ATTRTY  000042R     003	C.SSPA= 000020   	LOG$OP= 100000   	P.QBIN= 000006   	SN.TYP  000144R     002
AT$LEN= ****** GX	C.TSPA= 000200   	LOG$PA= 000001   	P.QCTL= 000005   	SN.XLE  000644R     002
AT$SYS= ****** GX	DATE.A= ****** GX	LOG$RP= 000004   	P.REPT= 000010   	SOH   = 000001
AT.ALL  000177   	DAY.X   000202R     004	LUN.OU= ****** GX	P.SPSI= 000000   	SPACE = 000040
AT.CDT  000001   	DAY.Y   000204R     004	L$CVTN= ****** GX	P.TIME= 000001   	SUCCS$= 000001
AT.INF  000002   	DECNAT  000002   	L$LEN = ****** GX	P.VEND= 000017   	TAB   = 000011
AT.LEN  000004   	DEL   = 000177   	MAXLNG= 003600   	P.WIND= 000012   	TERMIN  177777
AT.ON   100000   	DOATTR= ****** GX	MAXPAK  000136   	RTWORK= ****** GX	TEXT    000000
AT.PRO  000010   	DOAUTO= ****** GX	MON.X   000210R     004	RX$IN0  000072R     003	TILDE = 000176
AT.RX   000016R     003	DOT   = 000056   	MON.Y   000212R     004	RX$IN1  000100R     003	TIME.A= ****** GX
AT.SYS  000020   	ERBFSI= 000170   	MOV2B   002044R     002	RX.CDT  001352R     002	TSXSAV= ****** GX
AT.TX   000020R     003	ERRBYT= 000052   	NOSCOP= 000000   	RX.INF  002162R     002	TTY   = 000001
AT.TYP  000040   	ERROR$= 000004   	PAR$EV  000002   	RX.LEN  001220R     002	USERRB= 000053
AT.XLE  000100   	ESC   = 000033   	PAR$MA  000003   	RX.PRO  002106R     002	VT100 = 000002
BELL  = 000007   	FATAL$= 000020   	PAR$NO  000000   	RX.SYS  002142R     002	VT200 = 000003
BINARY  000001   	FF    = 000014   	PAR$OD  000001   	RX.TYP  001302R     002	WARN$ = 000002
BS    = 000010   	GNUM    002054R     002	PAR$SP  000004   	RX.XLE  002242R     002	WATT    000000R     003
CAPA.A= 000010   	IMAGE = ****** GX	PDPLST  000112R     003	RX.$$   001214R     002	W$ATTR  000000RG    002
CAPA.L= 000002   	ISPDP   002344R     002	PD$IAS= 000071   	R$ATTR  000766RG    002	XBLOCK  000232R     004
CAPA.S= 000004   	I2TOA = ****** GX	PD$POS= 000103   	SCANCH= ****** GX	XOFF  = 000023
CLRATR  002376RG    002	I4TOA = ****** GX	PD$RST= 000101   	SCOLON= 000073   	XON   = 000021
COMMA = 000054   	JSW   = 000044   	PD$RSX= 000070   	SEVER$= 000010   	YR.X    000236R     004
CONPAR= ****** GX	KRTINC= 000001   	PD$RT = 000102   	SIZBUF  000216R     004	YR.Y    000240R     004
CON$ES= 000034   	LF    = 000012   	PROT.A= ****** GX	SIZOF = ****** GX	$ALLSI= 003614
CR    = 000015   	LN$CNT= 000012   	P.CAPA= 000011   	SN$INF  000036R     003	$CDDMG= ****** GX
CTRL$N= 000016   	LN$MAX= 000204   	P.CHKT= 000007   	SN.CDT  000376R     002	$DMUL   002410R     002
CTRL$O= 000017   	LOG$AL= 000003   	P.EOL = 000004   	SN.END  000242R     002	$IMAGE= ****** GX
CURATR  000002R     004	LOG$CO= 000002   	P.MXL1= 000013   	SN.INF  000350R     002	...V1 = 000003


. ABS.	000000    000	(RW,I,GBL,ABS,OVR)
      	000000    001	(RW,I,LCL,REL,CON)
$CODE 	002446    002	(RO,I,LCL,REL,CON)
$PDATA	000120    003	(RO,D,LCL,REL,CON)
$RWDAT	000246    004	(RW,D,LCL,REL,CON)
Errors detected:  0

*** Assembler statistics


Work  file  reads: 0
Work  file writes: 0
Size of work file: 12073 Words  ( 48 Pages)
Size of core pool: 12800 Words  ( 50 Pages)
Operating  system: RT-11

Elapsed time: 00:00:00.09
KRTATR,KRTATR=KRTATR
