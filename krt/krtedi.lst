.MAIN.	MACRO V05.03b  00:01
Table of contents

    1-   1	KRTNHD	EIS macros for a non-EIS CPU
    4-   1	KRTMAC	Various handy constants and macros
    6-   2	Utility macros
    8-   2	Local data
    9-   3	SL editor main loop	; /BBS/ minor mods..
   10-   2	Process escape sequence	; /BBS/ minor mods..
   11-   2	Ring the bell		; /BBS/ replaces noop
   12-   2	PF2, Help		; /BBS/ added..
   13-   2	Post-PF1 processor	; /BBS/ all new
   14-   2	Two ways to undel a char  ; /BBS/ all new
   15-   2	Insert a char		; /BBS/ cleaned up
   16-   2	Move to start of line (Keypad 0)
   17-   2	Move to end of line (Keypad 2)
   18-   2	Move cursor one word	; /BBS/ all new
   19-   2	Move cursor one char	; /BBS/ added
   20-   2	Move right one char
   21-   2	Move left one char
   22-   2	Set advance mode	; /BBS/ added
   23-   2	Set backup mode		; /BBS/ added
   24-   2	Process ^C, ^Z		; /BBS/ fixed up..
   25-   2	Process CR, store command line	; /BBS/ fixed up..
   26-   2	Recall a command	; /BBS/ some changes..
   27-   2	Up-arrow key		; /BBS/ some changes..
   28-   2	Recover a command line	; /BBS/ made this a subroutine
   29-   2	Process ^U		; /BBS/ all new
   30-   2	Keypad minus		; /BBS/ all new..
   31-   2	Line feed		; /BBS/ all new
   32-   2	Write buffers		; /BBS/ for the above two routines
   33-   2	Un-do PF4, keypad comma	; /BBS/ all new
   34-   2	Un-do ^U, line feed	; /BBS/ all new
   35-   2	Process PF4		; /BBS/ all new
   36-   2	Erase char under cursor	; /BBS/ all new
   37-   2	Erase char to left of cursor  ; /BBS/ fixed up..
   38-   2	Process ^R		; /BBS/ minor clean up
   39-   2	Toggle insert/overstrike mode
   40-   1	Save cursor then clear to EOL	; /BBS/ added
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 1
KRTNHD	EIS macros for a non-EIS CPU

      1						.sbttl	KRTNHD	EIS macros for a non-EIS CPU
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					; /62/	27-Jul-93  Billy Youdelman  V03.62
      6					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
      7					;
      8					;	Assemble Kermit-11 modules with this for use on a
      9					;	non-EIS CPU.  This calls p$mul and p$div, assembly
     10					;	of which into KRTSUB depends on defining "NONEIS".
     11					;	KRTASM.NON assembles everything for non-EIS use.
     12
     13					;	10-Apr-84  09:37:15  Brian Nelson
     14
     15		000001 				NONEIS	=	1		; force p$mul,p$div into KRTSUB.MAC
     16
     17						.macro	mul	src,reg		; single precision
     18						.ntype	$$	,reg		; save number of input register
     19						mov	src	,-(sp)		; pass multiplier to p$mul
     20						mov	reg	,-(sp)		; pass multiplicand too
     21						call	p$mul			; multiply, returns a 16-bit product
     22						.iif eq <$$-1>	mov	(sp)+	,r1	; ..if input register was r1
     23						.iif eq <$$-3>	mov	(sp)+	,r3	; ditto if r3
     24						.iif eq <$$-5>	mov	(sp)+	,r5	; ditto if r5
     25						.iif ne <<$$+1>&1> .error      <; bad dst reg for MUL macro>
     26						.endm	mul
     27
     28						.macro	div	src,reg		; /BBS/ made this double precision
     29						.ntype	$$	,reg		; # of register with dividend hi word
     30						mov	src	,-(sp)		; divisor
     31						.if eq $$			; hi word is in r0
     32						mov	r1	,-(sp)		; dividend low word
     33						mov	r0	,-(sp)		; dividend high word
     34						.endc
     35						.if eq $$-2			; hi word is in r2
     36						mov	r3	,-(sp)
     37						mov	r2	,-(sp)
     38						.endc
     39						.if eq $$-4			; hi word is in r4
     40						mov	r5	,-(sp)
     41						mov	r4	,-(sp)
     42						.endc
     43						call	p$div			; divide
     44						.if eq $$			; using r0..
     45						mov	(sp)+	,r1		; remainder
     46						mov	(sp)+	,r0		; this only returns a 16-bit quotient
     47						.endc
     48						.if eq $$-2			; using r2..
     49						mov	(sp)+	,r3
     50						mov	(sp)+	,r2
     51						.endc
     52						.if eq $$-4			; using r4..
     53						mov	(sp)+	,r5
     54						mov	(sp)+	,r4
     55						.endc
     56						.endm	div
     57
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 1-1
KRTNHD	EIS macros for a non-EIS CPU

     58						.macro	sob	reg,dst		; subtract one and branch if not zero
     59						dec	reg
     60						bne	dst
     61						.endm	sob
     62
     63						.macro	ash	amount,reg	; arithmetic shift
     64						.ntype	$$$0	,amount
     65						.iif ne <27-$$$0> .error       <; must be auto pc for ASH macro>
     66						$$type	= 1			; assume left shift
     67						$$size	= 0			; how many ASLs or ASRs to generate
     68						  .irpc	$a ,<amount>		; parse the first argument
     69						  $c	= ''$a			; get the character as a literal
     70						  .iif eq <$c - '-> $$type = -1	; if a minus sign then assume right
     71						  .iif eq <$c - '.> .error     <; only use octal in ASH macro please>
     72						  .iif eq <$c - '^> .error     <; only use octal in ASH macro please>
     73						  $c	= $c - '0		; check for a digit now
     74						    .if ge $c			; perhaps a digit
     75						      .if le $c-7		; got a digit
     76						      $$size = <$$size*10>+$c	; add into accumulator
     77						      .endc
     78						    .endc
     79						  .endr
     80						.rept	$$size
     81						.iif gt <$$type>  asl	reg
     82						.iif lt <$$type>  asr	reg
     83						.endr
     84						.endm
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 2
KRTNHD	EIS macros for a non-EIS CPU

      1						.title	KRTEDI	SL editor
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	fixed all possible sign extension problems now the LN$MAX > 127.
      7					;	but keep it under 255. or you'll have to fix some other stuff!!
      8
      9					; /62/	27-Jul-93  Billy Youdelman  V03.62
     10					;
     11					;	add bells: up arrow when nothing saved yet, down arrow at end
     12
     13					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     14					;
     15					;	up/dn arrow command scrolling fixed
     16					;	command dispatch table patched for VT-100 keypad (KED equivs)
     17					;	dup cmds now not saved even when < max cmds are currently stored
     18					;	extended keypad for adv, bkup, word, char, line, delete, undelete
     19					;	added check for SS3 for VT-220 keypad
     20					;	cleaned up various odds and ends..
     21					;	WARNING:  If LN$MAX is made greater than 127., fix sxt stuff here
     22
     23					;	18-Jul-86  12:00:29  Brian Nelson
     24
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 3
KRTNHD	EIS macros for a non-EIS CPU

      1
      2						.include "IN:KRTMAC.MAC"
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 4
KRTMAC	Various handy constants and macros

      1						.sbttl	KRTMAC	Various handy constants and macros
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	add support for SET ATTRIBUTES
      7					;	add flag to suspend logging to a disk file
      8					;	make $LN$MAX 132. bytes for EIS assembly
      9					;	pulled message macro, no longer used..
     10
     11					; /62/	27-Jul-93  Billy Youdelman  V03.62
     12					;
     13					;	move dispatch macro to KRTSER
     14					;	move erbfsiz here from KRTPAK
     15					;	condense logging (debug) modes
     16					;	increase efficiency of incm64 macro
     17					;	increase MAXLNG (long-packet size) to 1920.
     18					;	reduce MAXLNG to 600. for NONEIS assembly, so pgm loads under FB..
     19					;	ditto for ALSIZE (phone # buffer) and LN$CNT (SL # of lines saved)
     20
     21					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     22					;
     23					;	modified message macro to call .newline instead of saving CR/LF
     24					;	and null for each new line, knocking 1042. bytes off the size
     25					;	of this version..  also changed ".print" emulation to wrtall,
     26					;	for a similar savings in compiled program size.
     27					;
     28					;	dump raw I/O logging from log$al (SET DEB ALL) - too confusing
     29					;	also pulled log$rp out and made it a completely separate item..
     30					;
     31					;	added a couple upper case macros
     32
     33					;	include file for Kermit-11
     34					;
     35					;	Brian Nelson  01-Dec-83  13:56:12
     36
     37						.NLIST	BEX
     38						.LIST	MEB			; /62/
     39
     40		000001 				KRTINC	=	1		; for .include error checking
     41
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 5
KRTMAC	Various handy constants and macros

      1
      2	000000					.psect	$code	,ro,i,lcl,rel,con ; psect ordering..
      3	000000					.psect	$pdata	,ro,d,lcl,rel,con
      4
      5					;	various ascii chars
      6		000001 				SOH	=   1		; default packet start of header
      7		000007 				BELL	=   7		; beep
      8		000010 				BS	=  10		; backspace
      9		000011 				TAB	=  11		; tab
     10		000012 				LF	=  12		; line feed
     11		000014 				FF	=  14		; form feed
     12		000015 				CR	=  15		; carriage return
     13		000016 				CTRL$N	=  16		; ^N VT-100 line drawing on
     14		000017 				CTRL$O	=  17		; ^O VT-100 line drawing off
     15		000021 				XON	=  'Q&37	; ^Q
     16		000023 				XOFF	=  'S&37	; ^S
     17		000033 				ESC	=  33		; escape
     18		000040 				SPACE	=  40
     19		000054 				COMMA	=  54
     20		000056 				DOT	=  56		; /63/
     21		000073 				SCOLON	=  73		; /63/
     22		000176 				TILDE	= 176		; /63/
     23		000177 				DEL	= 177		; delete
     24
     25					;	system data locations
     26		000044 				JSW	= 44		; job status word
     27		000052 				ERRBYT	= 52		; emt error byte
     28		000053 				USERRB	= 53		; /62/ user error byte
     29		000001 					SUCCS$	=  1	; no error
     30		000002 					WARN$	=  2	; warning
     31		000004 					ERROR$	=  4	; error
     32		000010 					SEVER$	= 10	; sever error
     33		000020 					FATAL$	= 20	; fatal error
     34
     35					;	byte offsets into SINIT parameter vector
     36		000000 				P.SPSIZ	= 0		; set packet length
     37		000001 				P.TIME	= 1		; time-out
     38		000002 				P.NPAD	= 2		; number of pad chars
     39		000003 				P.PADC	= 3		; the pad character
     40		000004 				P.EOL	= 4		; eol char
     41		000005 				P.QCTL	= 5		; control char quoting
     42		000006 				P.QBIN	= 6		; 8-bit quote
     43		000007 				P.CHKT	= 7		; checksum type
     44		000010 				P.REPT	= 10		; repeated character prefix
     45		000011 				P.CAPAS	= 11		; capability bitmask
     46		000010 					CAPA.A	= 10	; attribute handling
     47		000002 					CAPA.L	= 2	; /42/ long packets
     48		000004 					CAPA.S	= 4	; /42/ sliding windows
     49		000012 				P.WINDS	= 12		; /43/ window size, # of packets
     50		000013 				P.MXL1	= 13		; /43/ high order of long packet size
     51		000014 				P.MXL2	= 14		; /43/ low order of long packet size
     52		000017 				P.VEND	= 17		; end of parameter vector
     53
     54					; /62/	bits in doattr (file attribute processing)
     55		000001 				AT.CDT	=: 1		; create date
     56		000002 				AT.INF	=: 2		; /63/ system specific info
     57		000004 				AT.LEN	=: 4		; length
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 5-1
KRTMAC	Various handy constants and macros

     58		000010 				AT.PRO	=: 10		; file protection
     59		000020 				AT.SYS	=: 20		; system ID
     60		000040 				AT.TYP	=: 40		; file type
     61		000100 				AT.XLE	=: 100		; exact length in bytes
     62		100000 				AT.ON	=: 100000	; /63/ do attribute processing
     63		000177 				AT.ALL	=: AT.CDT!AT.INF!AT.LEN!AT.PRO!AT.SYS!AT.TYP!AT.XLE
     64
     65					;	bits in trace (debug status word)
     66		000001 				LOG$PA	= 1		; log all packets
     67		000002 				LOG$CO	= 2		; /62/ CONNECT logging to disk
     68		000004 				LOG$RP	= 4		; /62/ rpack chars to TT
     69		000010 				LOG$IO	= 10		; /62/ everything received or sent
     70		000020 				LOG$DE	= 20		; /62/ debugging to TT
     71		040000 				LOG$ON	= 40000		; /63/ set to write to disk, clear to suspend
     72		100000 				LOG$OP	= 100000	; logfile is open
     73		000003 				LOG$AL	= LOG$PA!LOG$CO	; /62/ ALL
     74
     75					;	parity options
     76		000000 				PAR$NO	=: 0		; none
     77		000001 				PAR$OD	=: 1		; odd
     78		000002 				PAR$EV	=: 2		; even
     79		000003 				PAR$MA	=: 3		; mark
     80		000004 				PAR$SP	=: 4		; space
     81
     82					;	file types
     83		177777 				TERMINAL=: -1		; file to term ala xreply, not to disk
     84		000000 				TEXT	=:  0		; normal ascii text files
     85		000001 				BINARY	=:  1		; image mode
     86		000002 				DECNAT	=:  2		; /52/ 8-bit text files
     87
     88					;	terminal types
     89		000000 				NOSCOPE	= 0		; /BBS/ hard copy terminal
     90		000001 				TTY	= 1		; a dumb tube terminal
     91		000002 				VT100	= 2		; itself
     92		000003 				VT200	= 3		; ditto..
     93
     94					;	supported CVT$$ cvt_bit_pattern bits
     95		000004 				C.CRLF	= 4		; discard CR LF FF ESC
     96		000010 				C.LSPA	= 10		; discard leading spaces and tabs
     97		000020 				C.SSPA	= 20		; reduce spaces and tabs to a single space
     98		000040 				C.LCUC	= 40		; lower case to upper case
     99		000200 				C.TSPA	= 200		; discard trailing spaces and tabs
    100
    101		000034 				CON$ESC	=  '\-100	; default CONNECT escape char
    102		000170 				ERBFSIZ	=  120.		; /62/ error msg text buff size
    103		000136 				MAXPAK	=:  94.		; /63/ max_packet_length - max_checksum_length
    104
    105						.if df	NONEIS		; /62/ using NONEIS for convenience..
    106		001000 				ALSIZE	=   1000	; /63/ bufsiz for SET DIAL/PHO NUM
    107		000003 				LN$CNT	=      3.	; /62/ save/recall 3. commands
    108		000120 				LN$MAX	=     80.	; /63/ max command line length
    109		001130 				MAXLNG	=    600.	; /63/ so image is small enuff to run
    110						.iff
    111						ALSIZE	=   2000	; /62/ bufsiz for SET DIAL/PHO NUM
    112						LN$CNT	=     10.	; /63/ save/recall 10. commands
    113						LN$MAX	=    132.	; /63/ max command line length
    114						MAXLNG	=   1920.	; /63/ use max long-packet buff size
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 5-2
KRTMAC	Various handy constants and macros

    115						.endc
    116		001144 				$ALLSIZ	= <MAXLNG+14>&177776 ; /62/ make it this for safety
    117
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 6
KRTMAC	Various handy constants and macros

      1
      2						.sbttl	Utility macros
      3
      4						.macro	.br to		; /63/ added
      5						.if df	to
      6						.if ne	to-.
      7						.error	<; not at location to;>
      8						.endc
      9						.endc
     10						.endm	.br
     11
     12						.macro	.chksp	arg
     13						.ntype	$$5	,arg
     14						.iif eq <<$$5&7>-6> .error arg <; Illegal use of SP (r6) in call>
     15						.endm	.chksp
     16
     17						.macro	calls	name	,arglst
     18					;	subroutine call with arguments passed in an area pointed to by r5
     19					;	(as with F4 and BP2).  all args are pushed onto the stack in the
     20					;	order specified.  r5 points to the sp before the call and is saved
     21					;	and restored.
     22						$$ = 0				; init # of args count
     23						  .irp x ,<arglst>		; count up # of args passed
     24						  $$ = $$+1			; one at a time
     25						  .endr				; got it
     26						.if eq $$			; no args present?
     27						jsr	pc	,name		; if so, substitute a simple call
     28						.iff				; at least one arg in <arglst>
     29						mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
     30						  .if eq $$-1			; is it one or more than one arg?
     31						  .chksp	arglst		; one arg, check for legal SP modes
     32						  mov	arglst	,-(sp)		; doing it thusly generates less code
     33						  mov	sp	,r5		; set pointer to argument list
     34						  jsr	pc	,name		; call the subroutine
     35						  tst	(sp)+			; pop parameter list from stack
     36						  mov	(sp)+	,r5		; /63/ restore r5
     37						  .iff				; arg_count > 1
     38						  $$2 = $$			; extract the args in
     39						    .rept	$$		; reverse order so that
     40						    $$1 = 0			; we might save a little
     41						      .irp x ,<arglst>		; core (four words)
     42						      $$1 = $$1+1		; scan the arg list until we come to
     43						        .if eq $$2-$$1		; the last one before one we just did
     44						        .chksp	x		; check for SP addressing mode
     45						        mov	x	,-(sp)	; push it
     46						        .mexit			; and exit the .irp
     47						        .endc
     48						      .endr
     49						    $$2 = $$2-1			; backwards to previous arg
     50						    .endr
     51						  mov	sp	,r5		; set up the argument list pointer
     52						  jsr	pc	,name		; and go to the routine
     53						  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
     54						  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
     55						  mov	(sp)+	,r5		; /63/ restore r5
     56						  .endc
     57						.endc
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 6-1
Utility macros

     58						.endm	calls
     59
     60						.macro	ctl	src ,dst
     61						clr	-(sp)
     62						bisb	src	,@sp
     63						call	l$xor
     64						movb	(sp)+	,dst
     65						.endm	ctl
     66
     67						.macro	copyz	from ,to ,maxlen
     68						.if  b	<maxlen>
     69						clr	-(sp)
     70						.iff
     71						mov	maxlen	,-(sp)
     72						.endc
     73						mov	from	,-(sp)
     74						mov	to	,-(sp)
     75						call	copyz$
     76						.endm	copyz
     77
     78						.macro	deccvt	val ,buf ,width
     79						mov	r5	,-(sp)
     80						.if  b	<width>
     81						clr	-(sp)
     82						.iff
     83						mov	width	,-(sp)
     84						.endc
     85						mov	val	,-(sp)
     86						mov	buf	,-(sp)
     87						mov	sp	,r5
     88						call	l$cvtnum
     89						add	#6	,sp
     90						mov	(sp)+	,r5
     91						.endm	deccvt
     92
     93						.macro	decout	val
     94						mov	r5	,-(sp)
     95						mov	val	,-(sp)		; /62/ l$wrdec pops this buffer
     96						mov	sp	,r5
     97						call	l$wrdec
     98						mov	(sp)+	,r5
     99						.endm	decout
    100
    101						.macro	direrr	val
    102						mov	val	,-(sp)
    103						call	direr$
    104						.endm	direrr
    105
    106						.macro	incm64	val
    107						inc	val
    108						bic	#^c<77>	,val		; /62/ faster
    109						.endm	incm64
    110
    111						.macro	indexm	reg		; check for auto increment/decrement
    112						.ntype	$$$0	,reg		; modes for macros that can't have..
    113						.if  ne	$$$0-27			; always allow pc autoincrement
    114						$$$0 =	<$$$0&177770>/10	; ..these modes in their arg list
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 6-2
Utility macros

    115						.ift				; get the mode into 0..7
    116						  .if  ge $$$0-2		; if mode >=2 and mode <=5 then error
    117						  .iif ge <5-$$$0> .error      <; Can't use auto inc/dec mode here>
    118						  .endc
    119						.endc
    120						.endm	indexm
    121
    122						.macro	ixor	reg ,dst
    123					;	get around the mode restrictions for the hardware XOR instruction
    124					;	and fix for RT-11 systems that don't have the EIS chip option
    125						.chksp	reg			; can't allow sp args
    126						.chksp	dst			; in either register
    127						indexm	reg			; check for allowed
    128						indexm	dst			; addressing mode
    129						mov	reg	,-(sp)		; it's much simpler to do this
    130						bic	dst	,@sp		; for all RT-11 systems rather
    131						bic	reg	,dst		; than to be selective
    132						bis	(sp)+	,dst		; done
    133						.endm	ixor
    134
    135						.macro	.newline		; print CR/LF on TT
    136						call	l$pcrlf
    137						.endm	.newline
    138
    139						.macro	octout	val
    140						calls	l$wroct	,<val>
    141						.endm	octout
    142
    143						.macro	prsbuf	dst
    144						mov	dst	,r0
    145						call	prsarg
    146						.endm	prsbuf
    147
    148						.macro	rpack	len.a ,pakn.a ,msg.a ,max.len	; /62/
    149						sub	#10	,sp
    150						mov	sp	,r1
    151						calls	rpack$	,<msg.a,r1,max.len>
    152						mov	(r1)+	,len.a
    153						mov	(r1)+	,pakn.a
    154						mov	@r1	,r1
    155						add	#10	,sp
    156						.endm	rpack
    157
    158						.macro	save	list
    159						.if  b	<list>
    160						 save	<r0,r1,r2,r3,r4,r5>
    161						.iff
    162						.irp	x ,<list>
    163						 mov	x	,-(sp)
    164						.endr
    165						.endc
    166						.endm	save
    167
    168						.macro	scan	ch ,str
    169						mov	str	,-(sp)
    170						clr	-(sp)
    171						bisb	ch	,@sp
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 6-3
Utility macros

    172						call	scanch
    173						.endm	scan
    174
    175						.macro	setpar	src ,dst
    176						movb	src	,-(sp)
    177						call	dopari
    178						movb	(sp)+	,dst
    179						.endm	setpar
    180
    181						.macro	spack	type ,pnum ,len ,msg
    182						.if  b	<len>
    183						.iif nb	<msg>	.error	<; bad call to SPACK macro>
    184						calls	spack$	,<type,pnum,#0,#null>
    185						.iff
    186						calls	spack$	,<type,pnum,len,msg>
    187						.endc
    188						.endm	spack
    189
    190						.macro	strcat	dst ,src
    191						mov	src	,-(sp)
    192						mov	dst	,-(sp)
    193						jsr	pc	,strcat
    194						.endm	strcat
    195
    196						.macro	strcpy	dst ,src
    197						mov	src	,-(sp)
    198						mov	dst	,-(sp)
    199						jsr	pc	,strcpy
    200						.endm	strcpy
    201
    202						.macro	strlen	string
    203						mov	string	,r0
    204						call	l$len
    205						.endm	strlen
    206
    207						.macro	textsrc	text
    208						.if  b	<text>
    209						clr	getcroutine		; /62/ reset to file I/O
    210						clr	tgetaddr
    211						.iff
    212						mov	#tgetcr0,getcroutine
    213						mov	text	,tgetaddr
    214						.endc
    215						.endm	textsrc
    216
    217						.macro	tochar	src ,dst
    218						clr	-(sp)
    219						bisb	src	,@sp
    220						add	#40	,@sp
    221						movb	(sp)+	,dst
    222						.endm	tochar
    223
    224						.macro	unchar	src ,dst
    225						clr	-(sp)
    226						bisb	src	,@sp
    227						sub	#40	,@sp
    228						movb	(sp)+	,dst
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 6-4
Utility macros

    229						.endm	unchar
    230
    231						.macro	unsave	list
    232						.if b <list>
    233						unsave	<r5,r4,r3,r2,r1,r0>
    234						.iff
    235						.irp	x ,<list>
    236						 mov	(sp)+	,x
    237						.endr
    238						.endc
    239						.endm	unsave
    240
    241						.macro	upcase	s		; /BBS/ added ..
    242						mov	s	,r0
    243						call	upcase			; /BBS/ upcase until null terminator
    244						.endm	upcase
    245
    246						.macro	upone	s		; /BBS/ added ..
    247						mov	s	,r0
    248						call	upone			; /BBS/ upcase only to next delimiter
    249						.endm	upone
    250
    251						.macro	wrtall	arg		; IO.WAL for an .asciz string
    252						mov	arg	,-(sp)		; pass the address
    253						call	wrtall			; do it
    254						.endm	wrtall
    255
    256						.macro	xor	reg ,dst
    257						ixor	reg	,dst
    258						.endm	xor
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 7
Utility macros

      1						.iif ndf  KRTINC  .error	<; .include for IN:KRTMAC.MAC failed>
      2
      3						; bits used in edists (the editor status word)
      4		000001 				IN$MODE	=	1	; if <> insert mode is on (default)
      5		000002 				UP$MODE	=	2	; down arrow wuz last, going up the list
      6		000004 				DN$MODE	=	4	; up arrow wuz last, going down the list
      7		000010 				UP$END	=	10	; up arrow has just dumped edicmd #0
      8		000020 				FW$MODE	=	20	; if <>, advance mode (default=backup=0)
      9
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 8
Utility macros

      1
      2						.sbttl	Local data
      3
      4	000000					.psect	$pdata
      5	000000	   033 	   133 	   113 	$ceol:	.asciz	<esc>"[K"	; clear from cursor to end of line
      6	000004	   136 	   132 	   015 	$cz:	.asciz	"^Z"<cr><lf>	; to echo ^Z
      7	000011	   033 	   133 	   104 	$left:	.asciz	<esc>"[D"	; move cursor left one column
      8	000015	   033 	   070 	   000 	$resto:	.asciz	<esc>"8"	; restore cursor to previously saved position
      9	000020	   033 	   133 	   103 	$right:	.asciz	<esc>"[C"	; move cursor right one column
     10	000024	   010 	   040 	   010 	$rubout:.byte	bs ,space ,bs ,0 ; echo this for a rubout
     11	000030	   033 	   067 	   000 	$save:	.asciz	<esc>"7"	; save current cursor position
     12	000033	   033 	   075 	   000 	$setvt:	.byte	esc ,'= ,0	; enable VT-100 keypad
     13	000036	   040 	   054 	   056 	delimit:.byte	40 ,54 ,56 ,57 ,72 ,75 ,133 ,0	; word delimiters (tab unused)
     14	000046	   077 	   113 	   122 	edi.01:	.asciz	"?KRTEDI-W-Can't overlay HELP from here"<cr><lf> ; /63/
     15	000117	   123 	   114 	   040 	edi.02:	.asciz	"SL F"		; /63/ display SL Function keys topic
     16	000124	   123 	   114 	   040 	edi.03:	.asciz	"SL K"		; /63/ or do KED version if KED mode is on
     17						.even
     18
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 9
Local data

      1
      2	000000					.psect	$code
      3						.sbttl	SL editor main loop	; /BBS/ minor mods..
      4
      5					;	 (r5)	= the prompt string
      6					;	2(r5)	= buffer in which to return input string
      7					;	  r1	= length of string returned in 2(r5)
      8					;	  r0	= if <>, the error code
      9
     10	000000				kbredi::save	<r2,r3,r4>
	000000	010246 				 mov	r2	,-(sp)
	000002	010346 				 mov	r3	,-(sp)
	000004	010446 				 mov	r4	,-(sp)
     11	000006	005767 	000000G			tst	sl.on			; is SL on?
     12	000012	001014 				bne	10$			; ya
     13	000014					wrtall	@r5			; no, prompt and
	000014	011546 				mov	@r5	,-(sp)		; pass the address
	000016	004767 	000000G			call	wrtall			; do it
     14	000022					calls	kbread	,<2(r5)>	; do hardcopy ttin
	000022	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000024	016546 	000002 			  mov	2(r5)	,-(sp)		; doing it thusly generates less code
	000030	010605 				  mov	sp	,r5		; set pointer to argument list
	000032	004767 	000000G			  jsr	pc	,kbread		; call the subroutine
	000036	005726 				  tst	(sp)+			; pop parameter list from stack
	000040	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     15	000042	000462 				br	70$			; done
     16
     17	000044	004767 	000000G		10$:	call	l$nolf			; just a return
     18	000050					wrtall	@r5			; print the prompt
	000050	011546 				mov	@r5	,-(sp)		; pass the address
	000052	004767 	000000G			call	wrtall			; do it
     19	000056	005767 	000000G			tst	sl.ked			; KED mode on?
     20	000062	001404 				beq	20$			; no
     21	000064					wrtall	#$setvt			; ya, force keypad to application mode
	000064	012746 	000033'			mov	#$setvt	,-(sp)		; pass the address
	000070	004767 	000000G			call	wrtall			; do it
     22	000074	005067 	000000G		20$:	clr	edipos			; cursor is at start of the line
     23	000100	005067 	000000G			clr	edilen			; length=0
     24	000104	016504 	000002 			mov	2(r5)	,r4		; buffer address
     25	000110	105014 				clrb	@r4			; ensure starting with .asciz
     26	000112	004767 	000000G		30$:	call	read1ch			; get one char from the keyboard
     27	000116	010003 				mov	r0	,r3		; save a copy
     28	000120	001430 				beq	60$			; nothing there, treat as a ^Z
     29
     30	000122	005767 	000000G			tst	sl.ked			; KED mode on?
     31	000126	001012 				bne	40$			; ya, dispatch accordingly
     32	000130					scan	r3	,#scanlst	; no, look for a match
	000130	012746 	000132'			mov	#scanlst	,-(sp)
	000134	005046 				clr	-(sp)
	000136	150316 				bisb	r3	,@sp
	000140	004767 	000000G			call	scanch
     33	000144	006300 				asl	r0			; word indexing
     34	000146	004770 	000154'			jsr	pc	,@scandsp(r0)	; dispatch
     35	000152	000411 				br	50$			; skip past KED code
     36	000154				40$:	scan	r3	,#kedlst	; look for a match
	000154	012746 	000220'			mov	#kedlst	,-(sp)
	000160	005046 				clr	-(sp)
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 9-1
SL editor main loop	; /BBS/ minor mods..

	000162	150316 				bisb	r3	,@sp
	000164	004767 	000000G			call	scanch
     37	000170	006300 				asl	r0			; word indexing
     38	000172	004770 	000236'			jsr	pc	,@keddsp(r0)	; dispatch
     39	000176	103745 			50$:	bcs	30$			; not done yet
     40	000200	000403 				br	70$			; done
     41
     42	000202	012700 	000000G		60$:	mov	#er$eof	,r0		; error, return end-of-file
     43	000206	005001 				clr	r1			; length=0
     44	000210				70$:	unsave	<r4,r3,r2>
	000210	012604 				 mov	(sp)+	,r4
	000212	012603 				 mov	(sp)+	,r3
	000214	012602 				 mov	(sp)+	,r2
     45	000216	000207 				return
     46
     47						.save
     48	000132					.psect	$pdata
     49	000132	   001 	   002 	   003 	scanlst:.byte	'A&37	,'B&37	,'C&37	,'D&37	,'E&37	,'F&37	,lf
     50	000141	   015 	   022 	   025 		.byte	cr	,'R&37	,'U&37	,'V&37	,'W&37	,'Z&37	,33
     51	000150	   177 	   217 	   233 		.byte	177	,217	,233
     52	000153	   000 				.byte	0
     53						.even
     54	000154	000662'			scandsp:.word	insch
     55	000156	003472'	002124'	001376'		.word	toggle	,prev	,ctrlc	,left	,prev	,right	,lfproc
     56	000174	001500'	003366'	002352'		.word	done	,retype	,ctrlu	,next	,retype	,eof	,doesc
     57	000212	003240'	000240'	000240'		.word	dorub	,do220	,do220
     58
     59	000220	   003 	   010 	   011 	kedlst:	.byte	'C&37	,'H&37	,'I&37	,lf	,cr	,'R&37
     60	000226	   025 	   032 	   033 		.byte	'U&37	,'Z&37	,33	,177	,217	,233
     61	000234	   000 				.byte	0
     62						.even
     63	000236	000662'			keddsp:	.word	insch
     64	000240	001376'	003240'	003472'		.word	ctrlc	,dorub	,toggle	,lfproc	,done	,retype
     65	000254	002352'	001446'	000220'		.word	ctrlu	,eof	,doesc	,dorub	,do220	,do220
     66	000220					.restore
     67
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 10
SL editor main loop	; /BBS/ minor mods..

      1
      2						.sbttl	Process escape sequence	; /BBS/ minor mods..
      3
      4	000220	004767 	000000G		doesc:	call	read1ch			; get next char in escape sequence
      5	000224	120027 	000133 			cmpb	r0	,#'[		; CSI?
      6	000230	001403 				beq	do220			; ya
      7	000232	120027 	000117 			cmpb	r0	,#'O&137	; from the keypad?
      8	000236	001027 				bne	beep			; struck out..
      9
     10	000240	004767 	000000G		do220:	call	read1ch			; get next char in escape sequence
     11	000244	005767 	000000G			tst	sl.ked			; is SL on?
     12	000250	001011 				bne	10$			; ya
     13	000252					scan	r0	,#esclst	; no, index to process
	000252	012746 	000270'			mov	#esclst	,-(sp)
	000256	005046 				clr	-(sp)
	000260	150016 				bisb	r0	,@sp
	000262	004767 	000000G			call	scanch
     14	000266	006300 				asl	r0			; word indexing
     15	000270	000170 	000300'			jmp	@escdsp(r0)		; /62/ do it
     16	000274				10$:	scan	r0	,#k.lst		; index to process
	000274	012746 	000320'			mov	#k.lst	,-(sp)
	000300	005046 				clr	-(sp)
	000302	150016 				bisb	r0	,@sp
	000304	004767 	000000G			call	scanch
     17	000310	006300 				asl	r0			; word indexing
     18	000312	000170 	000342'			jmp	@k.dsp(r0)		; /62/ do it
     19
     20						.save
     21	000270					.psect	$pdata
     22	000270	   101 	   102 	   103 	esclst:	.byte	'A&137	,'B&137	,'C&137	,'D&137	,'S&137	,'P&137	,'Q&137
     23	000277	   000 				.byte	0
     24						.even
     25	000300	000316'			escdsp:	.word	beep
     26	000302	002124'	001722'	001246'		.word	prev	,next	,right	,left	,pf$4	,pf$1	,pf$2
     27
     28	000320	   101 	   102 	   103 	k.lst:	.byte	'A&137	,'B&137	,'C&137	,'D&137	,'p!40	,'r!40	,'M&137
     29	000327	   161 	   163 	   164 		.byte	'q!40	,'s!40	,'t!40	,'u!40	,'S&137	,'m!40	,'l!40
     30	000336	   120 	   121 			.byte	'P&137	,'Q&137
     31	000340	   000 				.byte	0
     32						.even
     33	000342	000316'			k.dsp:	.word	beep
     34	000344	002124'	001722'	001246'		.word	prev	,next	,right	,left	,sol	,eol	,done
     35	000362	001124'	001236'	001352'		.word	kp$1	,kp$3	,kp$4	,kp$5	,pf$4	,kp$min	,kp$com
     36	000400	000446'	000332'			.word	pf$1	,pf$2
     37	000316					.restore
     38
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 11
Process escape sequence	; /BBS/ minor mods..

      1
      2						.sbttl	Ring the bell		; /BBS/ replaces noop
      3
      4	000316	012700 	000007 		beep:	mov	#bell	,r0		; load a bell
      5	000322	004767 	000000G			call	writ1char		; ship it to the terminal
      6	000326	000261 				sec				; not done yet
      7	000330	000207 				return
      8
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 12
Ring the bell		; /BBS/ replaces noop

      1
      2						.sbttl	PF2, Help		; /BBS/ added..
      3
      4	000332	005767 	000000G		pf$2:	tst	pf2$ok			; could doing this destroy an overlay?
      5	000336	001413 				beq	10$			; no
      6	000340	004767 	000000G			call	l$nolf			; possibly..  goto column 1
      7	000344					wrtall	#$ceol			; hose the line
	000344	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	000350	004767 	000000G			call	wrtall			; do it
      8	000354					wrtall	#edi.01			; /63/ "Can't overlay HELP from here"
	000354	012746 	000046'			mov	#edi.01	,-(sp)		; pass the address
	000360	004767 	000000G			call	wrtall			; do it
      9	000364	000424 				br	30$			; and retype the command line
     10
     11	000366	012700 	000117'		10$:	mov	#edi.02	,r0		; preset normal mode
     12	000372	005767 	000000G			tst	sl.ked			; KED mode on?
     13	000376	001402 				beq	20$			; no
     14	000400	012700 	000124'			mov	#edi.03	,r0		; ya, use this help text
     15	000404				20$:	strcpy	argbuf	,r0		; /62/ pass desired topic to HELP
	000404	010046 				mov	r0	,-(sp)
	000406	016746 	000000G			mov	argbuf	,-(sp)
	000412	004767 	000000G			jsr	pc	,strcpy
     16	000416					.newline			; format display
	000416	004767 	000000G			call	l$pcrlf
     17	000422					save	<r5,r4>			; preserve pointers
	000422	010546 				 mov	r5	,-(sp)
	000424	010446 				 mov	r4	,-(sp)
     18	000426	004767 	000000G			call	c$help			; dump the help text to the terminal
     19	000432					unsave	<r4,r5>			; recover pointers
	000432	012604 				 mov	(sp)+	,r4
	000434	012605 				 mov	(sp)+	,r5
     20	000436	004767 	002724 		30$:	call	retype			; then re-display the command line
     21	000442	000261 				sec				; not done yet
     22	000444	000207 				return
     23
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 13
PF2, Help		; /BBS/ added..

      1
      2						.sbttl	Post-PF1 processor	; /BBS/ all new
      3
      4	000446	004767 	000000G		pf$1:	call	read1ch			; get next char
      5	000452	005767 	000000G			tst	sl.ked			; KED mode on?
      6	000456	001011 				bne	10$			; ya
      7	000460					scan	r0	,#pf1lst	; look for a match
	000460	012746 	000404'			mov	#pf1lst	,-(sp)
	000464	005046 				clr	-(sp)
	000466	150016 				bisb	r0	,@sp
	000470	004767 	000000G			call	scanch
      8	000474	006300 				asl	r0			; word indexing
      9	000476	000170 	000416'			jmp	@pf1dsp(r0)		; /62/ dispatch
     10	000502				10$:	scan	r0	,#k1.lst	; look for a match
	000502	012746 	000440'			mov	#k1.lst	,-(sp)
	000506	005046 				clr	-(sp)
	000510	150016 				bisb	r0	,@sp
	000512	004767 	000000G			call	scanch
     11	000516	006300 				asl	r0			; word indexing
     12	000520	000170 	000452'			jmp	@k1.dsp(r0)		; /62/ dispatch
     13
     14						.save
     15	000404					.psect	$pdata
     16	000404	   003 	   012 	   025 	pf1lst:	.byte	'C&37	,lf	,'U&37	,'Z&37
     17	000410	   033 	   177 	   217 		.byte	33	,177	,217	,233
     18	000414	   000 				.byte	0
     19						.even
     20	000416	000316'			pf1dsp:	.word	beep
     21	000420	001376'	002750'	002750'		.word	ctrlc	,.lfproc,.ctrlu	,eof
     22	000430	000524'	000646'	000550'		.word	.doesc	,.dorub	,.do220	,.do220
     23
     24	000440	   003 	   010 	   012 	k1.lst:	.byte	'C&37	,'H&37	,lf	,'U&37	,'Z&37
     25	000445	   033 	   177 	   217 		.byte	33	,177	,217	,233
     26	000451	   000 				.byte	0
     27						.even
     28	000452	000316'			k1.dsp:	.word	beep
     29	000454	001376'	000646'	002750'		.word	ctrlc	,.dorub	,.lfproc,.ctrlu	,eof
     30	000466	000524'	000646'	000550'		.word	.doesc	,.dorub	,.do220	,.do220
     31	000524					.restore
     32
     33	000524	004767 	000000G		.doesc:	call	read1ch			; get next in esc seq
     34	000530	120027 	000133 			cmpb	r0	,#'[		; CSI?
     35	000534	001405 				beq	.do220			; ya
     36	000536	120027 	000117 			cmpb	r0	,#'O&137	; from the keypad?
     37	000542	001402 				beq	.do220			; ya
     38	000544	000167 	177546 			jmp	beep			; struck out..
     39
     40	000550	004767 	000000G		.do220:	call	read1ch			; get next in esc seq
     41	000554	005767 	000000G			tst	sl.ked			; SL on?
     42	000560	001011 				bne	20$			; ya
     43	000562					scan	r0	,#pfxlst	; index to its process
	000562	012746 	000476'			mov	#pfxlst	,-(sp)
	000566	005046 				clr	-(sp)
	000570	150016 				bisb	r0	,@sp
	000572	004767 	000000G			call	scanch
     44	000576	006300 				asl	r0			; word offset
     45	000600	000170 	000502'			jmp	@pfxdsp(r0)		; /62/ dispatch
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 13-1
Post-PF1 processor	; /BBS/ all new

     46	000604				20$:	scan	r0	,#kx.lst	; index to its process
	000604	012746 	000510'			mov	#kx.lst	,-(sp)
	000610	005046 				clr	-(sp)
	000612	150016 				bisb	r0	,@sp
	000614	004767 	000000G			call	scanch
     47	000620	006300 				asl	r0			; word offset
     48	000622	000170 	000516'			jmp	@kx.dsp(r0)		; /62/ dispatch
     49
     50						.save
     51	000476					.psect	$pdata
     52	000476	   123 	   120 		pfxlst:	.byte	'S&137	,'P&137
     53	000500	   000 				.byte	0
     54						.even
     55	000502	000316'			pfxdsp:	.word	beep
     56	000504	002720'	000446'			.word	.pf$4	,pf$1
     57
     58	000510	   123 	   155 	   154 	kx.lst:	.byte	'S&137	,'m!40	,'l!40	,'P&137
     59	000514	   000 				.byte	0
     60						.even
     61	000516	000316'			kx.dsp:	.word	beep
     62	000520	002720'	002720'	000626'		.word	.pf$4	,.kp$min,.kp$com,pf$1
     63	000626					.restore
     64
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 14
Post-PF1 processor	; /BBS/ all new

      1
      2						.sbttl	Two ways to undel a char  ; /BBS/ all new
      3
      4	000626	004767 	000014 		.kp$com:call	.dorub			; undelete the char
      5	000632	005700 				tst	r0			; did it work?  beep loads r0 if not..
      6	000634	001002 				bne	10$			; no, leave cursor alone
      7	000636	004767 	000452 			call	left			; ya, fix the cursor position
      8	000642	000261 			10$:	sec				; not done yet
      9	000644	000207 				return
     10
     11	000646	005003 			.dorub:	clr	r3			; /63/ avoid possible sign extension
     12	000650	156703 	000000G			bisb	undchr	,r3		; /63/ recover char to undelete
     13	000654	001002 				bne	insch			; /63/ there is a char
     14	000656	000167 	177434 			jmp	beep			; nothing has been saved
     15
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 15
Two ways to undel a char  ; /BBS/ all new

      1
      2						.sbttl	Insert a char		; /BBS/ cleaned up
      3
      4	000662	120327 	000040 		insch:	cmpb	r3	,#space		; control characters that get
      5	000666	103404 				blo	10$			; /63/ this far should be ignored..
      6	000670	026727 	000000G	000120 		cmp	edilen	,#ln$max	; too many chars?
      7	000676	103402 				blo	20$			; no
      8	000700	000167 	177412 		10$:	jmp	beep			; ring bell if line is full
      9
     10	000704	016701 	000000G		20$:	mov	edipos	,r1		; get the offset into line
     11	000710	060401 				add	r4	,r1		; where to stuff the data
     12	000712	105711 				tstb	(r1)			; already at end of line?
     13	000714	001013 				bne	30$			; no
     14	000716	110321 				movb	r3	,(r1)+		; ya, add current char to it
     15	000720	105011 				clrb	(r1)			; reterminate
     16	000722	005301 				dec	r1			; back up
     17	000724					wrtall	r1			; echo
	000724	010146 				mov	r1	,-(sp)		; pass the address
	000726	004767 	000000G			call	wrtall			; do it
     18	000732	005267 	000000G			inc	edilen			; line is now one char longer
     19	000736	005267 	000000G			inc	edipos			; cursor is now here
     20	000742	000444 				br	60$			; that's it..
     21
     22	000744	032767 	000001 	000000G	30$:	bit	#in$mode,edists		; insert or overstrike?
     23	000752	001002 				bne	40$			; insert
     24	000754	110321 				movb	r3	,(r1)+		; overstrike
     25	000756	000420 				br	50$			; finish up
     26
     27	000760	162706 	000122 		40$:	sub	#ln$max+2,sp		; a temp buffer
     28	000764	010602 				mov	sp	,r2		; pointer to it
     29	000766					strcpy	r2	,r1		; save from cursor to EOL
	000766	010146 				mov	r1	,-(sp)
	000770	010246 				mov	r2	,-(sp)
	000772	004767 	000000G			jsr	pc	,strcpy
     30	000776	110321 				movb	r3	,(r1)+		; insert the new character
     31	001000					strcpy	r1	,r2		; put the trailing data back in
	001000	010246 				mov	r2	,-(sp)
	001002	010146 				mov	r1	,-(sp)
	001004	004767 	000000G			jsr	pc	,strcpy
     32	001010	062706 	000122 			add	#ln$max+2,sp		; pop buffer
     33	001014	005267 	000000G			inc	edilen			; line is now one char longer
     34	001020				50$:	wrtall	#$save			; save cursor position
	001020	012746 	000030'			mov	#$save	,-(sp)		; pass the address
	001024	004767 	000000G			call	wrtall			; do it
     35	001030	005301 				dec	r1			; back to to the new character
     36	001032					wrtall	r1			; dump the data
	001032	010146 				mov	r1	,-(sp)		; pass the address
	001034	004767 	000000G			call	wrtall			; do it
     37	001040					wrtall	#$restore		; put the cursor back now
	001040	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	001044	004767 	000000G			call	wrtall			; do it
     38	001050	004767 	000172 			call	right			; move over on the display
     39	001054	005000 			60$:	clr	r0			; no error
     40	001056	000261 				sec				; not done yet
     41	001060	000207 				return
     42
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 16
Insert a char		; /BBS/ cleaned up

      1
      2						.sbttl	Move to start of line (Keypad 0)
      3
      4	001062	005767 	000000G		sol:	tst	edipos			; stop at position 0
      5	001066	003403 				ble	10$			; /BBS/ done
      6	001070	004767 	000220 			call	left			; /BBS/ move one column
      7	001074	000772 				br	sol			; and check position
      8	001076	000261 			10$:	sec				; not done yet
      9	001100	000207 				return
     10
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 17
Move to start of line (Keypad 0)

      1
      2						.sbttl	Move to end of line (Keypad 2)
      3
      4	001102	026767 	000000G	000000G	eol:	cmp	edipos	,edilen		; /BBS/ end yet?
      5	001110	103003 				bhis	10$			; yes
      6	001112	004767 	000130 			call	right			; /BBS/ no, move one column
      7	001116	000771 				br	eol			; and check position
      8	001120	000261 			10$:	sec				; not done yet
      9	001122	000207 				return
     10
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 18
Move to end of line (Keypad 2)

      1
      2						.sbttl	Move cursor one word	; /BBS/ all new
      3
      4	001124	016702 	000000G		kp$1:	mov	edists	,r2		; so kp$3 can flip direction at ends
      5	001130	016701 	000000G		loop:	mov	edipos	,r1		; copy of current cursor position
      6	001134	032702 	000020 			bit	#fw$mode,r2		; check direction
      7	001140	001003 				bne	10$			; it's advance
      8	001142	005701 				tst	r1			; backup, any room left?
      9	001144	003432 				ble	30$			; nope
     10	001146	000403 				br	20$			; ya
     11	001150	020167 	000000G		10$:	cmp	r1	,edilen		; advance, any room left?
     12	001154	103026 				bhis	30$			; no
     13	001156	004767 	000054 		20$:	call	kp$3			; ya, move one char
     14	001162	016701 	000000G			mov	edipos	,r1		; refresh pointer
     15	001166	060401 				add	r4	,r1		; point to byte at hand
     16	001170					scan	(r1)	,#delimit	; check for a word delimiter
	001170	012746 	000036'			mov	#delimit	,-(sp)
	001174	005046 				clr	-(sp)
	001176	151116 				bisb	(r1)	,@sp
	001200	004767 	000000G			call	scanch
     17	001204	005700 				tst	r0			; well?
     18	001206	001350 				bne	loop			; found one, keep looking
     19	001210					scan	-1(r1)	,#delimit	; a char, does a delimiter precede it?
	001210	012746 	000036'			mov	#delimit	,-(sp)
	001214	005046 				clr	-(sp)
	001216	156116 	177777 			bisb	-1(r1)	,@sp
	001222	004767 	000000G			call	scanch
     20	001226	005700 				tst	r0			; well?
     21	001230	001737 				beq	loop			; no
     22	001232	000261 			30$:	sec				; ya, but not done yet
     23	001234	000207 				return
     24
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 19
Move cursor one word	; /BBS/ all new

      1
      2						.sbttl	Move cursor one char	; /BBS/ added
      3
      4	001236	032767 	000020 	000000G	kp$3:	bit	#fw$mode,edists		; check current direction
      5	001244	001423 				beq	left			; it's to the left
      6	001246					.br	right			; /63/ or to the right..
      7
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 20
Move cursor one char	; /BBS/ added

      1
      2						.sbttl	Move right one char
      3
      4	001246	026767 	000000G	000000G	right:	cmp	edipos	,edilen		; EOL?
      5	001254	103015 				bhis	10$			; /63/ yes
      6	001256					wrtall	#$right			; no, move cursor
	001256	012746 	000020'			mov	#$right	,-(sp)		; pass the address
	001262	004767 	000000G			call	wrtall			; do it
      7	001266	005267 	000000G			inc	edipos			; cursor is now here
      8	001272	026767 	000000G	000000G		cmp	edipos	,edilen		; /BBS/ EOL now?
      9	001300	103403 				blo	10$			; /63/ no
     10	001302	042767 	000020 	000000G		bic	#fw$mode,edists		; /BBS/ ya, flip direction
     11	001310	000261 			10$:	sec				; not done yet
     12	001312	000207 				return
     13
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 21
Move right one char

      1
      2						.sbttl	Move left one char
      3
      4	001314	005767 	000000G		left:	tst	edipos			; SOL?
      5	001320	003412 				ble	10$			; no
      6	001322					wrtall	#$left			; ya, backup a bit
	001322	012746 	000011'			mov	#$left	,-(sp)		; pass the address
	001326	004767 	000000G			call	wrtall			; do it
      7	001332	005367 	000000G			dec	edipos			; cursor is now here
      8	001336	001003 				bne	10$			; /BBS/ when hitting SOL..
      9	001340	052767 	000020 	000000G		bis	#fw$mode,edists		; /BBS/ ..flip direction
     10	001346	000261 			10$:	sec				; not done yet
     11	001350	000207 				return
     12
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 22
Move left one char

      1
      2						.sbttl	Set advance mode	; /BBS/ added
      3
      4	001352	052767 	000020 	000000G	kp$4:	bis	#fw$mode,edists		; go forward
      5	001360	000261 				sec				; not done yet
      6	001362	000207 				return
      7
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 23
Set advance mode	; /BBS/ added

      1
      2						.sbttl	Set backup mode		; /BBS/ added
      3
      4	001364	042767 	000020 	000000G	kp$5:	bic	#fw$mode,edists		; go backward
      5	001372	000261 				sec				; not done yet
      6	001374	000207 				return
      7
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 24
Set backup mode		; /BBS/ added

      1
      2						.sbttl	Process ^C, ^Z		; /BBS/ fixed up..
      3
      4	001376	004767 	177460 		ctrlc:	call	sol			; move to start of line, clear edipos
      5	001402					wrtall	#$ceol			; erase to EOL
	001402	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	001406	004767 	000000G			call	wrtall			; do it
      6	001412	005067 	000000G			clr	edilen			; init length
      7	001416	105014 				clrb	@r4			; no data left over
      8	001420	005767 	000000G			tst	edicmd			; anything saved yet?
      9	001424	002405 				blt	10$			; nope..
     10	001426	012767 	000003 	000000G		mov	#ln$cnt	,edicmd		; reset cmd recall ptr
     11	001434	005367 	000000G			dec	edicmd			; offset so prev/next work ok
     12	001440	012700 	000000G		10$:	mov	#cmd$ab	,r0		; it's a ^C abort (NOT ^Z)
     13	001444	000410 				br	cz.fin			; /63/ common exit code
     14
     15	001446	004767 	177430 		eof:	call	eol			; do this first
     16	001452					wrtall	#$cz			; echo ^Z
	001452	012746 	000004'			mov	#$cz	,-(sp)		; pass the address
	001456	004767 	000000G			call	wrtall			; do it
     17	001462	012700 	000000G			mov	#cmd$ex	,r0		; flag ^Z exit
     18	001466	042767 	000036 	000000G	cz.fin:	bic	#<up$mode!dn$mode!up$end!fw$mode>,edists  ; clear flags
     19	001474	005001 				clr	r1			; byte_count=0, also clears carry
     20	001476	000207 				return
     21
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 25
Process ^C, ^Z		; /BBS/ fixed up..

      1
      2						.sbttl	Process CR, store command line	; /BBS/ fixed up..
      3
      4	001500	104340 			done:	emt	340			; eat possible LF after CR
      5	001502					.newline			; kickoff the command..
	001502	004767 	000000G			call	l$pcrlf
      6	001506	005767 	000000G			tst	edilen			; anything to do?
      7	001512	001474 				beq	110$			; no
      8
      9	001514	005002 				clr	r2			; ya, init index
     10	001516	012703 	000003 			mov	#ln$cnt	,r3		; number of lines to do
     11	001522	016200 	000000G		10$:	mov	lastli(r2),r0		; look for a free spot
     12	001526	105710 				tstb	@r0			; empty?
     13	001530	001005 				bne	20$			; nope..
     14	001532	005702 				tst	r2			; iz it the very first one?
     15	001534	001452 				beq	90$			; ya, thus nothing to scroll
     16	001536	010203 				mov	r2	,r3		; no, put pointer in right spot
     17	001540	006203 				asr	r3			; only scroll this many lines
     18	001542	000407 				br	30$			; instead of them all
     19	001544	062702 	000002 		20$:	add	#2	,r2		; bump to next line and..
     20	001550					sob	r3	,10$		; ..keep looking, until..
	001550	005303 				dec	r3
	001552	001363 				bne	10$
     21	001554	005002 				clr	r2			; ..all lines are in use
     22	001556	012703 	000003 			mov	#ln$cnt	,r3		; so do them all..
     23
     24	001562	010446 			30$:	mov	r4	,-(sp)		; save pointer to top of buffer
     25	001564	005303 				dec	r3			; bump to line to test
     26	001566	006303 				asl	r3			; word indexing
     27	001570	016301 	000000G			mov	lastli(r3),r1		; this is its current address
     28	001574	016700 	000000G			mov	edilen	,r0		; length of string just typed in
     29	001600	122100 				cmpb	(r1)+	,r0		; is it same as stored string?
     30	001602	001004 				bne	50$			; no
     31	001604	122421 			40$:	cmpb	(r4)+	,(r1)+		; ya, check for string equality
     32	001606	001002 				bne	50$			; not the same
     33	001610					sob	r0	,40$		; same, check next byte
	001610	005300 				dec	r0
	001612	001374 				bne	40$
     34	001614	012604 			50$:	mov	(sp)+	,r4		; restore pointer to top of buffer
     35	001616	006203 				asr	r3			; restore index
     36	001620	005700 				tst	r0			; did strings match?
     37	001622	001003 				bne	60$			; no
     38	001624	010367 	000000G			mov	r3	,edicmd		; yes, save index
     39	001630	000425 				br	110$			; that's it
     40
     41	001632	005702 			60$:	tst	r2			; are all buffers in use?
     42	001634	001012 				bne	90$			; nope..
     43										; ya, scroll back previous lines
     44	001636	016200 	000000G		70$:	mov	lastli(r2),r0		; address where string will be written
     45	001642	016201 	000002G			mov	lastli+2(r2),r1		; address of string to be moved
     46	001646	112120 			80$:	movb	(r1)+	,(r0)+		; copy the string now
     47	001650	001376 				bne	80$			; until hitting the null terminator
     48	001652	062702 	000002 			add	#2	,r2		; bump pointer to next line
     49	001656					sob	r3	,70$		; next please
	001656	005303 				dec	r3
	001660	001366 				bne	70$
     50
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 25-1
Process CR, store command line	; /BBS/ fixed up..

     51	001662	016201 	000000G		90$:	mov	lastli(r2),r1		; at last, copy the new line
     52	001666	116721 	000000G			movb	edilen	,(r1)+		; save the line length
     53	001672	112421 			100$:	movb	(r4)+	,(r1)+		; copy the data now
     54	001674	001376 				bne	100$			; including null terminator
     55	001676	006202 				asr	r2			; recover index to current command
     56	001700	010267 	000000G			mov	r2	,edicmd		; save it
     57
     58	001704	016701 	000000G		110$:	mov	edilen	,r1		; return line length
     59	001710	042767 	000036 	000000G		bic	#<up$mode!dn$mode!up$end!fw$mode>,edists  ; clear flags
     60	001716	005000 				clr	r0			; no error, also clears carry
     61	001720	000207 				return
     62
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 26
Process CR, store command line	; /BBS/ fixed up..

      1
      2						.sbttl	Recall a command	; /BBS/ some changes..
      3
      4	001722	012702 	000000G		next:	mov	#edicmd	,r2		; point to command number buffer
      5	001726	005712 				tst	@r2			; anything been saved?
      6	001730	002003 				bge	10$			; /62/ ya
      7	001732	004767 	176360 			call	beep			; /62/ not yet, so there's
      8	001736	000465 				br	60$			; /62/ nothing to recall
      9
     10	001740	021227 	000002 		10$:	cmp	@r2	,#ln$cnt-1	; /62/ can we move up?
     11	001744	103403 				blo	30$			; /63/ ya
     12	001746	004767 	176344 		20$:	call	beep			; /62/ no, beep
     13	001752	000436 				br	50$			; /62/ and cleanup anyway
     14
     15	001754	005212 			30$:	inc	@r2			; yes, move up
     16
     17	001756	032767 	000004 	000000G		bit	#dn$mode,edists		; if down arrow was used last time
     18	001764	001404 				beq	40$			; loop in one more bump up to fix pos
     19	001766	042767 	000004 	000000G		bic	#dn$mode,edists		; when going back up, but only do this
     20	001774	000761 				br	10$			; once when coming back here
     21
     22	001776	011202 			40$:	mov	@r2	,r2		; recover command number
     23	002000	006302 				asl	r2			; word addressing
     24	002002	016202 	000000G			mov	lastli(r2),r2		; at last
     25	002006	105712 				tstb	@r2			; anything to copy?
     26	002010	001756 				beq	20$			; /62/ no, ring bell and cleanup
     27
     28	002012	004767 	000246 			call	recover			; ya, get the line
     29	002016	052767 	000002 	000000G		bis	#up$mode,edists		; set mode flag
     30	002024	026727 	000000G	000003 		cmp	edicmd	,#ln$cnt	; poised at the last command?
     31	002032	103427 				blo	60$			; /63/ no
     32	002034	005367 	000000G			dec	edicmd			; ya, fix so prev works correctly
     33	002040	042767 	000002 	000000G		bic	#up$mode,edists		; ditto
     34	002046	000421 				br	60$
     35
     36	002050	042767 	000002 	000000G	50$:	bic	#up$mode,edists		; at the end, no extra bump please
     37	002056	004767 	000000G			call	l$nolf			; /62/ goto start of line
     38	002062					wrtall	#$ceol			; /62/ clear line on screen
	002062	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	002066	004767 	000000G			call	wrtall			; do it
     39	002072					wrtall	@r5			; /62/ print prompt
	002072	011546 				mov	@r5	,-(sp)		; pass the address
	002074	004767 	000000G			call	wrtall			; do it
     40	002100	105014 				clrb	@r4			; no data left over
     41	002102	005067 	000000G			clr	edilen			; length=0
     42	002106	005067 	000000G			clr	edipos			; /62/ cursor is at beginning of line
     43
     44	002112	042767 	000010 	000000G	60$:	bic	#up$end,edists		; no longer at the end of list
     45	002120	000261 				sec				; not done yet
     46	002122	000207 				return
     47
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 27
Recall a command	; /BBS/ some changes..

      1
      2						.sbttl	Up-arrow key		; /BBS/ some changes..
      3
      4	002124	032767 	000010 	000000G	prev:	bit	#up$end,edists		; already at the firewall?
      5	002132	001402 				beq	10$			; no
      6	002134	004767 	176156 			call	beep			; ya, ring the bell
      7
      8	002140	016702 	000000G		10$:	mov	edicmd	,r2		; current command number
      9	002144	002003 				bge	20$			; /62/ something has been saved
     10	002146	004767 	176144 			call	beep			; /62/ never been here
     11	002152	000442 				br	60$			; /62/ so nothing to recall yet
     12
     13	002154	032767 	000002 	000000G	20$:	bit	#up$mode,edists		; down arrow been used?
     14	002162	001005 				bne	30$			; ya, so bump edicmd to correct
     15
     16	002164	006302 				asl	r2			; word indexing
     17	002166	016202 	000000G			mov	lastli(r2),r2		; address of buffer
     18	002172	105712 				tstb	@r2			; anything to copy?
     19	002174	001006 				bne	40$			; yes
     20
     21	002176	042767 	000002 	000000G	30$:	bic	#up$mode,edists		; only do this first time thru here
     22	002204	005367 	000000G			dec	edicmd			; no, back up
     23	002210	000753 				br	10$			; and try again..
     24
     25	002212	004767 	000046 		40$:	call	recover			; ya, get the line
     26
     27	002216	005767 	000000G			tst	edicmd			; check for underflow
     28	002222	003011 				bgt	50$			; nope
     29	002224	005067 	000000G			clr	edicmd			; just in case..
     30	002230	042767 	000004 	000000G		bic	#dn$mode,edists		; no help needed coming off end
     31	002236	052767 	000010 	000000G		bis	#up$end,edists		; no more stuff, edicmd=0
     32	002244	000405 				br	60$
     33
     34	002246	005367 	000000G		50$:	dec	edicmd			; backup now and
     35	002252	052767 	000004 	000000G		bis	#dn$mode,edists		; apply appropriate compensation
     36
     37	002260	000261 			60$:	sec				; not done yet
     38	002262	000207 				return
     39
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 28
Up-arrow key		; /BBS/ some changes..

      1
      2						.sbttl	Recover a command line	; /BBS/ made this a subroutine
      3
      4	002264	004767 	000000G		recover:call	l$nolf			; goto start of line
      5	002270					wrtall	#$ceol			; clear line on screen
	002270	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	002274	004767 	000000G			call	wrtall			; do it
      6	002300					wrtall	@r5			; print prompt
	002300	011546 				mov	@r5	,-(sp)		; pass the address
	002302	004767 	000000G			call	wrtall			; do it
      7	002306	105014 				clrb	(r4)			; init buffer
      8	002310	005003 				clr	r3			; /63/ avoid possible sign extension
      9	002312	152203 				bisb	(r2)+	,r3		; /63/ get length
     10	002314	001406 				beq	20$			; nothing there
     11	002316	010401 				mov	r4	,r1		; copy of the destination address
     12	002320	112221 			10$:	movb	(r2)+	,(r1)+		; copy string
     13	002322	001376 				bne	10$			; including null terminator
     14	002324					wrtall	r4			; echo the string just copied
	002324	010446 				mov	r4	,-(sp)		; pass the address
	002326	004767 	000000G			call	wrtall			; do it
     15	002332	010367 	000000G		20$:	mov	r3	,edilen		; save length
     16	002336	010367 	000000G			mov	r3	,edipos		; cursor is now at EOL
     17	002342	042767 	000020 	000000G		bic	#fw$mode,edists		; can only backup from here
     18	002350	000207 				return
     19
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 29
Recover a command line	; /BBS/ made this a subroutine

      1
      2						.sbttl	Process ^U		; /BBS/ all new
      3
      4	002352	016701 	000000G		ctrlu:	mov	edipos	,r1		; get the offset into line
      5	002356	003430 				ble	30$			; nothing to do
      6	002360	004767 	176476 			call	SOL			; move to start of line, clear edipos
      7	002364					wrtall	#$ceol			; erase to EOL
	002364	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	002370	004767 	000000G			call	wrtall			; do it
      8	002374	005067 	000000G			clr	edilen			; init length
      9	002400	005000 				clr	r0			; start at the top
     10	002402	004767 	000236 			call	undwrt			; write deleted data into a buffer
     11	002406	010402 				mov	r4	,r2		; work copy of output pointer
     12	002410	112022 			10$:	movb	(r0)+	,(r2)+		; copy rest of line back into buffer
     13	002412	001405 				beq	20$			; until null
     14	002414	005267 	000000G			inc	edilen			; string is now one char longer
     15	002420	005267 	000000G			inc	edipos			; cursor will be here
     16	002424	000771 				br	10$			; next char
     17	002426				20$:	wrtall	r4			; dump result to term
	002426	010446 				mov	r4	,-(sp)		; pass the address
	002430	004767 	000000G			call	wrtall			; do it
     18	002434	004767 	176422 			call	sol			; go back to start of the line
     19	002440	000261 			30$:	sec				; not done yet
     20	002442	000207 				return
     21
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 30
Process ^U		; /BBS/ all new

      1
      2						.sbttl	Keypad minus		; /BBS/ all new..
      3
      4	002444	026767 	000000G	000000G	kp$min:	cmp	edipos	,edilen		; at end of the line?
      5	002452	103035 				bhis	10$			; /63/ ya, can't do this
      6	002454	016703 	000000G			mov	edipos	,r3		; save current cursor position
      7	002460	004767 	001034 			call	savclr			; save cursor position, erase to EOL
      8	002464	016746 	000000G			mov	edists	,-(sp)		; save current mode
      9	002470	052767 	000020 	000000G		bis	#fw$mode,edists		; set advance mode
     10	002476	004767 	176422 			call	kp$1			; bump to next word
     11	002502	012667 	000000G			mov	(sp)+	,edists		; restore old mode
     12	002506	016701 	000000G			mov	edipos	,r1		; end of the deleted data
     13	002512	160301 				sub	r3	,r1		; length of same
     14	002514	160167 	000000G			sub	r1	,edilen		; length of what remains in line
     15	002520	010300 				mov	r3	,r0		; begin copy from here
     16	002522	004767 	000116 			call	undwrt			; copy deleted stuff into buffer
     17	002526					wrtall	#$restore		; put cursor back
	002526	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	002532	004767 	000000G			call	wrtall			; do it
     18	002536	010367 	000000G			mov	r3	,edipos		; cursor is now here
     19	002542	004767 	000120 			call	outwrt			; pull up trailing part of line
     20	002546	000261 			10$:	sec				; not done yet
     21	002550	000207 				return
     22
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 31
Keypad minus		; /BBS/ all new..

      1
      2						.sbttl	Line feed		; /BBS/ all new
      3
      4	002552	005767 	000000G		lfproc:	tst	edipos			; at top of the line?
      5	002556	003430 				ble	10$			; ya, can't do this
      6	002560	016703 	000000G			mov	edipos	,r3		; save current cursor position
      7	002564	016746 	000000G			mov	edists	,-(sp)		; save current mode
      8	002570	042767 	000020 	000000G		bic	#fw$mode,edists		; set backup mode
      9	002576	004767 	176322 			call	kp$1			; bump to next word
     10	002602	012667 	000000G			mov	(sp)+	,edists		; restore old mode
     11	002606	010301 				mov	r3	,r1		; end of deleted data
     12	002610	166701 	000000G			sub	edipos	,r1		; length of deleted part of line
     13	002614	160167 	000000G			sub	r1	,edilen		; new length of what's left in line
     14	002620	016700 	000000G			mov	edipos	,r0		; start from here
     15	002624	004767 	000014 			call	undwrt			; write the undelete buffer
     16	002630	004767 	000664 			call	savclr			; save cursor position, erase to EOL
     17	002634	004767 	000026 			call	outwrt			; pull up trailing part of line
     18	002640	000261 			10$:	sec				; not done yet
     19	002642	000207 				return
     20
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 32
Line feed		; /BBS/ all new

      1
      2						.sbttl	Write buffers		; /BBS/ for the above two routines
      3
      4	002644	012702 	000000G		undwrt:	mov	#undlin	,r2		; pointer to undelete line buffer
      5	002650	110122 				movb	r1	,(r2)+		; stash copy of the length
      6	002652	060400 				add	r4	,r0		; start from here
      7	002654	112022 			10$:	movb	(r0)+	,(r2)+		; stash the deleted
      8	002656					sob	r1	,10$		; part of the line
	002656	005301 				dec	r1
	002660	001375 				bne	10$
      9	002662	105012 				clrb	(r2)			; null terminate it
     10	002664	000207 				return
     11
     12	002666				outwrt:	wrtall	r0			; restore undeleted part of line
	002666	010046 				mov	r0	,-(sp)		; pass the address
	002670	004767 	000000G			call	wrtall			; do it
     13	002674					wrtall	#$restore		; put cursor back
	002674	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	002700	004767 	000000G			call	wrtall			; do it
     14	002704	010402 				mov	r4	,r2		; work copy of input pointer
     15	002706	066702 	000000G			add	edipos	,r2		; where old line left off
     16	002712	112022 			20$:	movb	(r0)+	,(r2)+		; pull up the rest of it
     17	002714	001376 				bne	20$			; until hitting the null terminator
     18	002716	000207 				return
     19
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 33
Write buffers		; /BBS/ for the above two routines

      1
      2						.sbttl	Un-do PF4, keypad comma	; /BBS/ all new
      3
      4	002720				.kp$min:				; UNDEL WORD and LINE are same funct
      5	002720	004767 	000024 		.pf$4:	call	.ctrlu			; use this, then fix cursor
      6	002724	005700 				tst	r0			; did it work?   beep sets r0 if not..
      7	002726	001006 				bne	20$			; no   /63/ or r0 clear for bisb below
      8	002730	156700 	000000G			bisb	undlin	,r0		; /63/ recover length of insert
      9	002734	004767 	176354 		10$:	call	left			; back cursor up to
     10	002740					sob	r0	,10$		; where it was
	002740	005300 				dec	r0
	002742	001374 				bne	10$
     11	002744	000261 			20$:	sec				; not done yet
     12	002746	000207 				return
     13
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 34
Un-do PF4, keypad comma	; /BBS/ all new

      1
      2						.sbttl	Un-do ^U, line feed	; /BBS/ all new
      3
      4	002750				.lfproc:				; UNDO LF and UNDO ^U are same funct
      5	002750	105767 	000000G		.ctrlu:	tstb	undlin			; anything to undelete?
      6	002754	001410 				beq	10$			; no
      7	002756	012700 	000120 			mov	#ln$max	,r0		; max possible line length
      8	002762	166700 	000000G			sub	edilen	,r0		; minus what is already in use
      9	002766	003403 				ble	10$			; no room left
     10	002770	126700 	000000G			cmpb	undlin	,r0		; will new stuff fit?
     11	002774	101402 				blos	20$			; /63/ ya
     12	002776	000167 	175314 		10$:	jmp	beep			; it can't happen
     13
     14	003002	162706 	000122 		20$:	sub	#ln$max+2,sp		; it can happen, get a temp buffer
     15	003006	010602 				mov	sp	,r2		; and a pointer to it
     16
     17	003010	016701 	000000G			mov	edipos	,r1		; get the offset into line
     18	003014	060401 				add	r4	,r1		; where to stuff the data
     19
     20	003016	012703 	000000G			mov	#undlin	,r3		; pointer to string to insert
     21	003022	005000 				clr	r0			; /63/ avoid possible sign extension
     22	003024	152300 				bisb	(r3)+	,r0		; /63/ recover length
     23	003026	060067 	000000G			add	r0	,edilen		; add length of insert to total
     24	003032	060067 	000000G			add	r0	,edipos		; cursor will be here when done
     25
     26	003036					strcpy	r2	,r1		; save from cursor to EOL
	003036	010146 				mov	r1	,-(sp)
	003040	010246 				mov	r2	,-(sp)
	003042	004767 	000000G			jsr	pc	,strcpy
     27	003046	112321 			30$:	movb	(r3)+	,(r1)+		; recover the insert data
     28	003050	001376 				bne	30$			; copy up to null terminator
     29	003052	005301 				dec	r1			; bump pointer back onto it
     30	003054					strcpy	r1	,r2		; put the trailing data back in
	003054	010246 				mov	r2	,-(sp)
	003056	010146 				mov	r1	,-(sp)
	003060	004767 	000000G			jsr	pc	,strcpy
     31	003064					wrtall	#undlin+1		; echo insert moving cursor to its end
	003064	012746 	000001G			mov	#undlin+1	,-(sp)		; pass the address
	003070	004767 	000000G			call	wrtall			; do it
     32	003074					wrtall	#$save			; save cursor pos
	003074	012746 	000030'			mov	#$save	,-(sp)		; pass the address
	003100	004767 	000000G			call	wrtall			; do it
     33	003104					wrtall	r2			; restore trailing part of old line
	003104	010246 				mov	r2	,-(sp)		; pass the address
	003106	004767 	000000G			call	wrtall			; do it
     34	003112					wrtall	#$restore		; put the cursor back now
	003112	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	003116	004767 	000000G			call	wrtall			; do it
     35	003122	062706 	000122 			add	#ln$max+2,sp		; pop buffer
     36	003126	005000 				clr	r0			; flag no error
     37	003130	000261 				sec				; but not done yet
     38	003132	000207 				return
     39
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 35
Un-do ^U, line feed	; /BBS/ all new

      1
      2						.sbttl	Process PF4		; /BBS/ all new
      3
      4	003134	016701 	000000G		pf$4:	mov	edilen	,r1		; length of the whole banana
      5	003140	166701 	000000G			sub	edipos	,r1		; length of deleted part of line
      6	003144	003421 				ble	20$			; nothing to do
      7	003146	012702 	000000G			mov	#undlin	,r2		; pointer to undelete line buffer
      8	003152	110122 				movb	r1	,(r2)+		; stash copy of the length
      9	003154	010400 				mov	r4	,r0		; work copy of input pointer
     10	003156	066700 	000000G			add	edipos	,r0		; start from here
     11	003162	010001 				mov	r0	,r1		; save to terminate after copying..
     12	003164	112022 			10$:	movb	(r0)+	,(r2)+		; ..the deleted part of line..
     13	003166	001376 				bne	10$			; ..and its null term
     14	003170	105011 				clrb	(r1)			; now terminate the new string
     15	003172					wrtall	#$ceol			; erase to the end of the line
	003172	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	003176	004767 	000000G			call	wrtall			; do it
     16	003202	016767 	000000G	000000G		mov	edipos	,edilen		; this is new length
     17	003210	000261 			20$:	sec				; not done yet
     18	003212	000207 				return
     19
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 36
Process PF4		; /BBS/ all new

      1
      2						.sbttl	Erase char under cursor	; /BBS/ all new
      3
      4	003214	026767 	000000G	000000G	kp$com:	cmp	edipos	,edilen		; at end of the line?
      5	003222	103057 				bhis	do.end			; /63/ ya, nothing to do
      6	003224	010402 				mov	r4	,r2		; copy pointer to top of buffer
      7	003226	066702 	000000G			add	edipos	,r2		; now it's pointing to cursor position
      8	003232	105712 				tstb	(r2)			; don't load a null into undchr!
      9	003234	001452 				beq	do.end			; it's at EOL, nothing to do
     10	003236	000427 				br	do.com			; fall thru to common code..
     11
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 37
Erase char under cursor	; /BBS/ all new

      1
      2						.sbttl	Erase char to left of cursor  ; /BBS/ fixed up..
      3
      4	003240	005767 	000000G		dorub:	tst	edipos			; at SOL?
      5	003244	003446 				ble	do.end			; ya
      6	003246	010402 				mov	r4	,r2		; copy pointer to top of buffer
      7	003250	066702 	000000G			add	edipos	,r2		; now it's pointing to cursor position
      8	003254	105712 				tstb	(r2)			; at EOL?
      9	003256	001014 				bne	10$			; no
     10	003260	114267 	000000G			movb	-(r2)	,undchr		; ya, copy for undel_char
     11	003264	105012 				clrb	(r2)			; then zap char
     12	003266	005367 	000000G			dec	edilen			; new length
     13	003272					wrtall	#$rubout		; fix display
	003272	012746 	000024'			mov	#$rubout	,-(sp)		; pass the address
	003276	004767 	000000G			call	wrtall			; do it
     14	003302	005367 	000000G			dec	edipos			; cursor is now here
     15	003306	000425 				br	do.end
     16
     17	003310	004767 	176000 		10$:	call	left			; move back one char for a rubout
     18	003314	005302 				dec	r2			; fix pointer
     19
     20	003316	111267 	000000G		do.com:	movb	(r2)	,undchr		; /63/ stash copy for possible undel
     21	003322	010201 				mov	r2	,r1		; copy pointer for input
     22	003324	010203 				mov	r2	,r3		; copy pointer for output
     23	003326	005201 				inc	r1			; bump past char that is hosed
     24	003330	112123 			20$:	movb	(r1)+	,(r3)+		; slide everything left down a byte
     25	003332	001376 				bne	20$			; until null terminated
     26	003334	005367 	000000G			dec	edilen			; line is now one less char long
     27	003340	004767 	000154 			call	savclr			; save cursor position, erase to EOL
     28	003344					wrtall	r2			; dump buffer
	003344	010246 				mov	r2	,-(sp)		; pass the address
	003346	004767 	000000G			call	wrtall			; do it
     29	003352					wrtall	#$restore		; restore cursor position
	003352	012746 	000015'			mov	#$restore	,-(sp)		; pass the address
	003356	004767 	000000G			call	wrtall			; do it
     30	003362	000261 			do.end:	sec				; /63/ not done yet
     31	003364	000207 				return
     32
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 38
Erase char to left of cursor  ; /BBS/ fixed up..

      1
      2						.sbttl	Process ^R		; /BBS/ minor clean up
      3
      4	003366	004767 	000000G		retype:	call	l$nolf			; start of line
      5	003372					wrtall	#$ceol			; clear to end of line
	003372	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	003376	004767 	000000G			call	wrtall			; do it
      6	003402					wrtall	@r5			; print the prompt
	003402	011546 				mov	@r5	,-(sp)		; pass the address
	003404	004767 	000000G			call	wrtall			; do it
      7	003410	005767 	000000G			tst	sl.ked			; KED mode on?
      8	003414	001404 				beq	10$			; no
      9	003416					wrtall	#$setvt			; ya, force keypad to application mode
	003416	012746 	000033'			mov	#$setvt	,-(sp)		; pass the address
	003422	004767 	000000G			call	wrtall			; do it
     10	003426				10$:	wrtall	r4			; dump the buffer
	003426	010446 				mov	r4	,-(sp)		; pass the address
	003430	004767 	000000G			call	wrtall			; do it
     11	003434	004767 	000000G			call	l$nolf			; back to column 1
     12	003440					strlen	@r5			; prompt is this long
	003440	011500 				mov	@r5	,r0
	003442	004767 	000000G			call	l$len
     13	003446	066700 	000000G			add	edipos	,r0		; add expected cursor position
     14	003452				20$:	wrtall	#$right			; go to it
	003452	012746 	000020'			mov	#$right	,-(sp)		; pass the address
	003456	004767 	000000G			call	wrtall			; do it
     15	003462					sob	r0	,20$		; one column at a time until there
	003462	005300 				dec	r0
	003464	001372 				bne	20$
     16	003466	000261 				sec				; not done yet
     17	003470	000207 				return
     18
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 39
Process ^R		; /BBS/ minor clean up

      1
      2						.sbttl	Toggle insert/overstrike mode
      3
      4	003472	012700 	000001 		toggle:	mov	#in$mode,r0		; copy of insert mode bit
      5	003476					xor	r0	,edists		; toggle it
	003476	010046 				mov	r0	,-(sp)		; it's much simpler to do this
	003500	046716 	000000G			bic	edists	,@sp		; for all RT-11 systems rather
	003504	040067 	000000G			bic	r0	,edists		; than to be selective
	003510	052667 	000000G			bis	(sp)+	,edists		; done
      6	003514	000261 				sec				; not done yet
      7	003516	000207 				return
      8
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 40
Save cursor then clear to EOL	; /BBS/ added

      1						.sbttl	Save cursor then clear to EOL	; /BBS/ added
      2
      3	003520				savclr:	wrtall	#$save			; save cursor position
	003520	012746 	000030'			mov	#$save	,-(sp)		; pass the address
	003524	004767 	000000G			call	wrtall			; do it
      4	003530					wrtall	#$ceol			; erase to EOL
	003530	012746 	000000'			mov	#$ceol	,-(sp)		; pass the address
	003534	004767 	000000G			call	wrtall			; do it
      5	003540	000207 				return
      6
      7		000001 				.end
KRTEDI	SL editor	MACRO V05.03b  00:01  Page 40-1
Symbol table

ALSIZE= 001000   	DONE    001500R     002	KX.DSP  000516R     003	PF$2    000332R     002	TERMIN  177777
ARGBUF= ****** GX	DORUB   003240R     002	KX.LST  000510R     003	PF$4    003134R     002	TEXT    000000
AT.ALL  000177   	DOT   = 000056   	K.DSP   000342R     003	PF1DSP  000416R     003	TILDE = 000176
AT.CDT  000001   	DO.COM  003316R     002	K.LST   000320R     003	PF1LST  000404R     003	TOGGLE  003472R     002
AT.INF  000002   	DO.END  003362R     002	K1.DSP  000452R     003	PF2$OK= ****** GX	TTY   = 000001
AT.LEN  000004   	DO220   000240R     002	K1.LST  000440R     003	PREV    002124R     002	UNDCHR= ****** GX
AT.ON   100000   	EDICMD= ****** GX	LASTLI= ****** GX	P.CAPA= 000011   	UNDLIN= ****** GX
AT.PRO  000010   	EDILEN= ****** GX	LEFT    001314R     002	P.CHKT= 000007   	UNDWRT  002644R     002
AT.SYS  000020   	EDIPOS= ****** GX	LF    = 000012   	P.EOL = 000004   	UP$END= 000010
AT.TYP  000040   	EDISTS= ****** GX	LFPROC  002552R     002	P.MXL1= 000013   	UP$MOD= 000002
AT.XLE  000100   	EDI.01  000046R     003	LN$CNT= 000003   	P.MXL2= 000014   	USERRB= 000053
BEEP    000316R     002	EDI.02  000117R     003	LN$MAX= 000120   	P.NPAD= 000002   	VT100 = 000002
BELL  = 000007   	EDI.03  000124R     003	LOG$AL= 000003   	P.PADC= 000003   	VT200 = 000003
BINARY  000001   	EOF     001446R     002	LOG$CO= 000002   	P.QBIN= 000006   	WARN$ = 000002
BS    = 000010   	EOL     001102R     002	LOG$DE= 000020   	P.QCTL= 000005   	WRIT1C= ****** GX
CAPA.A= 000010   	ERBFSI= 000170   	LOG$IO= 000010   	P.REPT= 000010   	WRTALL= ****** GX
CAPA.L= 000002   	ERRBYT= 000052   	LOG$ON= 040000   	P.SPSI= 000000   	XOFF  = 000023
CAPA.S= 000004   	ERROR$= 000004   	LOG$OP= 100000   	P.TIME= 000001   	XON   = 000021
CMD$AB= ****** GX	ER$EOF= ****** GX	LOG$PA= 000001   	P.VEND= 000017   	$ALLSI= 001144
CMD$EX= ****** GX	ESC   = 000033   	LOG$RP= 000004   	P.WIND= 000012   	$CEOL   000000R     003
COMMA = 000054   	ESCDSP  000300R     003	LOOP    001130R     002	READ1C= ****** GX	$CZ     000004R     003
CON$ES= 000034   	ESCLST  000270R     003	L$LEN = ****** GX	RECOVE  002264R     002	$LEFT   000011R     003
CR    = 000015   	FATAL$= 000020   	L$NOLF= ****** GX	RETYPE  003366R     002	$RESTO  000015R     003
CTRLC   001376R     002	FF    = 000014   	L$PCRL= ****** GX	RIGHT   001246R     002	$RIGHT  000020R     003
CTRLU   002352R     002	FW$MOD= 000020   	MAXLNG= 001130   	SAVCLR  003520R     002	$RUBOU  000024R     003
CTRL$N= 000016   	INSCH   000662R     002	MAXPAK  000136   	SCANCH= ****** GX	$SAVE   000030R     003
CTRL$O= 000017   	IN$MOD= 000001   	NEXT    001722R     002	SCANDS  000154R     003	$SETVT  000033R     003
CZ.FIN  001466R     002	JSW   = 000044   	NONEIS= 000001   	SCANLS  000132R     003	$$    = 000001
C$HELP= ****** GX	KBREAD= ****** GX	NOSCOP= 000000   	SCOLON= 000073   	$$$0  = 000006
C.CRLF= 000004   	KBREDI  000000RG    002	OUTWRT  002666R     002	SEVER$= 000010   	$$5   = 000067
C.LCUC= 000040   	KEDDSP  000236R     003	PAR$EV  000002   	SL.KED= ****** GX	.CTRLU  002750R     002
C.LSPA= 000010   	KEDLST  000220R     003	PAR$MA  000003   	SL.ON = ****** GX	.DOESC  000524R     002
C.SSPA= 000020   	KP$COM  003214R     002	PAR$NO  000000   	SOH   = 000001   	.DORUB  000646R     002
C.TSPA= 000200   	KP$MIN  002444R     002	PAR$OD  000001   	SOL     001062R     002	.DO220  000550R     002
DECNAT  000002   	KP$1    001124R     002	PAR$SP  000004   	SPACE = 000040   	.KP$CO  000626R     002
DEL   = 000177   	KP$3    001236R     002	PFXDSP  000502R     003	STRCPY= ****** GX	.KP$MI  002720R     002
DELIMI  000036R     003	KP$4    001352R     002	PFXLST  000476R     003	SUCCS$= 000001   	.LFPRO  002750R     002
DN$MOD= 000004   	KP$5    001364R     002	PF$1    000446R     002	TAB   = 000011   	.PF$4   002720R     002
DOESC   000220R     002	KRTINC= 000001

. ABS.	000000    000	(RW,I,GBL,ABS,OVR)
      	000000    001	(RW,I,LCL,REL,CON)
$CODE 	003542    002	(RO,I,LCL,REL,CON)
$PDATA	000530    003	(RO,D,LCL,REL,CON)
Errors detected:  0

*** Assembler statistics


Work  file  reads: 0
Work  file writes: 0
Size of work file: 12020 Words  ( 47 Pages)
Size of core pool: 12544 Words  ( 49 Pages)
Operating  system: RT-11

Elapsed time: 00:00:00.22
KRTEDI,KRTEDI=KRTNHD,KRTEDI
