.MAIN.	MACRO V05.03b  00:01
Table of contents

    1-   1	KRTNHD	EIS macros for a non-EIS CPU
    4-   1	KRTMAC	Various handy constants and macros
    6-   2	Utility macros
    7-   3	Macro references, various handy constants defined
    8-   2	APR7 buffer allocation	; /BBS/ moved here..
    9-   2	Local data
   10-   3	Init for RT-11/TSX-Plus
   11-   2	Allocate and init buffers
   12-   2	Set/get terminal config..   ; /BBS/ moved here
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 1
KRTNHD	EIS macros for a non-EIS CPU

      1						.sbttl	KRTNHD	EIS macros for a non-EIS CPU
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					; /62/	27-Jul-93  Billy Youdelman  V03.62
      6					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
      7					;
      8					;	Assemble Kermit-11 modules with this for use on a
      9					;	non-EIS CPU.  This calls p$mul and p$div, assembly
     10					;	of which into KRTSUB depends on defining "NONEIS".
     11					;	KRTASM.NON assembles everything for non-EIS use.
     12
     13					;	10-Apr-84  09:37:15  Brian Nelson
     14
     15		000001 				NONEIS	=	1		; force p$mul,p$div into KRTSUB.MAC
     16
     17						.macro	mul	src,reg		; single precision
     18						.ntype	$$	,reg		; save number of input register
     19						mov	src	,-(sp)		; pass multiplier to p$mul
     20						mov	reg	,-(sp)		; pass multiplicand too
     21						call	p$mul			; multiply, returns a 16-bit product
     22						.iif eq <$$-1>	mov	(sp)+	,r1	; ..if input register was r1
     23						.iif eq <$$-3>	mov	(sp)+	,r3	; ditto if r3
     24						.iif eq <$$-5>	mov	(sp)+	,r5	; ditto if r5
     25						.iif ne <<$$+1>&1> .error      <; bad dst reg for MUL macro>
     26						.endm	mul
     27
     28						.macro	div	src,reg		; /BBS/ made this double precision
     29						.ntype	$$	,reg		; # of register with dividend hi word
     30						mov	src	,-(sp)		; divisor
     31						.if eq $$			; hi word is in r0
     32						mov	r1	,-(sp)		; dividend low word
     33						mov	r0	,-(sp)		; dividend high word
     34						.endc
     35						.if eq $$-2			; hi word is in r2
     36						mov	r3	,-(sp)
     37						mov	r2	,-(sp)
     38						.endc
     39						.if eq $$-4			; hi word is in r4
     40						mov	r5	,-(sp)
     41						mov	r4	,-(sp)
     42						.endc
     43						call	p$div			; divide
     44						.if eq $$			; using r0..
     45						mov	(sp)+	,r1		; remainder
     46						mov	(sp)+	,r0		; this only returns a 16-bit quotient
     47						.endc
     48						.if eq $$-2			; using r2..
     49						mov	(sp)+	,r3
     50						mov	(sp)+	,r2
     51						.endc
     52						.if eq $$-4			; using r4..
     53						mov	(sp)+	,r5
     54						mov	(sp)+	,r4
     55						.endc
     56						.endm	div
     57
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 1-1
KRTNHD	EIS macros for a non-EIS CPU

     58						.macro	sob	reg,dst		; subtract one and branch if not zero
     59						dec	reg
     60						bne	dst
     61						.endm	sob
     62
     63						.macro	ash	amount,reg	; arithmetic shift
     64						.ntype	$$$0	,amount
     65						.iif ne <27-$$$0> .error       <; must be auto pc for ASH macro>
     66						$$type	= 1			; assume left shift
     67						$$size	= 0			; how many ASLs or ASRs to generate
     68						  .irpc	$a ,<amount>		; parse the first argument
     69						  $c	= ''$a			; get the character as a literal
     70						  .iif eq <$c - '-> $$type = -1	; if a minus sign then assume right
     71						  .iif eq <$c - '.> .error     <; only use octal in ASH macro please>
     72						  .iif eq <$c - '^> .error     <; only use octal in ASH macro please>
     73						  $c	= $c - '0		; check for a digit now
     74						    .if ge $c			; perhaps a digit
     75						      .if le $c-7		; got a digit
     76						      $$size = <$$size*10>+$c	; add into accumulator
     77						      .endc
     78						    .endc
     79						  .endr
     80						.rept	$$size
     81						.iif gt <$$type>  asl	reg
     82						.iif lt <$$type>  asr	reg
     83						.endr
     84						.endm
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 2
KRTNHD	EIS macros for a non-EIS CPU

      1						.title	KRTOSI	One shot init
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	fix test for running LTC to accomodate QED's fast PDP-11s
      7
      8					; /62/	27-Jul-93  Billy Youdelman  V03.62
      9					;
     10					;	check for indirect command file running program, for error handling
     11					;	dump unused BUFDEF stuff
     12					;	add Jim Whitlock's VBGEXE fetch pointer fixes
     13
     14					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     15					;
     16					;	"pic" code dumped
     17					;	if TSX, line number saved in tsxsav during init, for t.ttxon
     18					;	store clock rate (50/60 Hz) in clkflg, use elsewhere for timers
     19					;	add init for TSX activation char list
     20					;	call assdev when PRO-350 tries to automatically assign CL or XC
     21					;	.SERR is set here and then left on forever..
     22					;	VT200 now sets con8bit
     23					;	cleaned up init code
     24					;	increase ALSIZE to 1024. (user_defined modem and ph numb buffer)
     25					;	under RT-11 display memory free for handlers at sign-on
     26
     27					;	23-May-86  18:23:36 BDN	Creation.
     28					;	07-Jun-86  05:39:17 BDN XM edits.
     29					;
     30					; /BBS/	20-Oct-91  Updated  this  narrative  to  reflect  mods made.
     31					;	[Note in KRTTSX the mapped part of the root actually spans 3
     32					;	pages (APR1 thru APR3), and was padded with command dispatch
     33					;	tables and SL to the end of APR3 to allow the most efficient
     34					;	allocation of the remaining memory..]
     35					;
     36					;	 There are some significant assumptions made  here.  One for
     37					;	the  virtual  (RT-11XM)  Kermit  (KRTTSX.SAV)  is  that APR7
     38					;	(160000-177777) is available and does NOT contain  any  code
     39					;	overlays,  because  in  the  XM  image  we  create a dynamic
     40					;	region mapped from APR7 to allow placement  of  buffers  and
     41					;	the like  up there.   In the case of the disk overlaid image
     42					;	(KRT.SAV) we just  do  a  .SETTOP  to  177776  and  allocate
     43					;	buffers there,  allowing the USR to swap if need be over the
     44					;	buffers.  Additionally, the .FETCH buffer is, for  the  disk
     45					;	overlaid   (non-virtual)   KRT.SAV,   allocated   from  this
     46					;	.SETTOP area.  In  the  case  of  XM,  however,  we  have  a
     47					;	problem.  In  order  to reduce the size of the ROOT to allow
     48					;	Kermit to run as a foreground job we ended up  with  the top
     49					;	of the  root mapped by APR1 (20000-37777).  Now it is a well
     50					;	known fact that XM places many constraints on what  you  can
     51					;	put in the range,  QUE elements being the best known example
     52					;	of something you CAN NOT put there.  It also turns  out that
     53					;	you  must NEVER try to load a handler into that area either.
     54					;	If you do, depending on the address,  you  can  expect  very
     55					;	erratic  behavior  from the handler, if not outright failure
     56					;	and a system crash.  Such was the case on  the PRO/350.  The
     57					;	XC  driver  would  MOST  of the time work ok, but the system
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 2-1
KRTNHD	EIS macros for a non-EIS CPU

     58					;	would ALWAYS crash on a .HRESET directive.  Additionally the
     59					;	XC  OFFDRV  .SPFUN, while setting the "shutdown" flag in the
     60					;	driver,   would  be  ignored  at  program  exit.   Thus   an
     61					;	outstanding  XC  read  would attempt to enter a non-existent
     62					;	completion routine when the remote server timed out (sending
     63					;	a NAK packet that'd be read by XC), and hang the PRO.
     64					;
     65					;	 The correct method to control this buffer (XM version only)
     66					;	is to with the extend size for the psect HNBUFF at link time
     67					;	using the /e:0000 option in KRTLNK.COM.
     68					;
     69					;	 There are  a couple of things here for TSX+ also.  The TSX+
     70					;	directive for  altering  the physical address space limit is
     71					;	used,  which is simply an  EMT 375  with  R0  pointing to an
     72					;	argument block of the form
     73					;
     74					;	.byte	0,141
     75					;	.word	TOP_ADDRESS_DESIRED
     76					;
     77					;	 This is done because, as in the case of  the  RSTS/E  RT-11
     78					;	emulator,  the  .SETTOP  directive  only returns the current
     79					;	high limit, it has no effect on the memory allocation.  Both
     80					;	systems  thus  have special directives to actually alter the
     81					;	memory size.  KRTXM.MAC also patches  location 56  so KRTTSX
     82					;	will start on TSX+ systems with a default  memory allocation
     83					;	less  than  64Kb.  The  TSX+  "Line Number"  is  checked  to
     84					;	determine if the operating system is TSX+.  I have left that
     85					;	in the init code as it works even in older versions of TSX+.
     86
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 3
KRTNHD	EIS macros for a non-EIS CPU

      1
      2						.include "IN:KRTMAC.MAC"
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 4
KRTMAC	Various handy constants and macros

      1						.sbttl	KRTMAC	Various handy constants and macros
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	add support for SET ATTRIBUTES
      7					;	add flag to suspend logging to a disk file
      8					;	make $LN$MAX 132. bytes for EIS assembly
      9					;	pulled message macro, no longer used..
     10
     11					; /62/	27-Jul-93  Billy Youdelman  V03.62
     12					;
     13					;	move dispatch macro to KRTSER
     14					;	move erbfsiz here from KRTPAK
     15					;	condense logging (debug) modes
     16					;	increase efficiency of incm64 macro
     17					;	increase MAXLNG (long-packet size) to 1920.
     18					;	reduce MAXLNG to 600. for NONEIS assembly, so pgm loads under FB..
     19					;	ditto for ALSIZE (phone # buffer) and LN$CNT (SL # of lines saved)
     20
     21					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     22					;
     23					;	modified message macro to call .newline instead of saving CR/LF
     24					;	and null for each new line, knocking 1042. bytes off the size
     25					;	of this version..  also changed ".print" emulation to wrtall,
     26					;	for a similar savings in compiled program size.
     27					;
     28					;	dump raw I/O logging from log$al (SET DEB ALL) - too confusing
     29					;	also pulled log$rp out and made it a completely separate item..
     30					;
     31					;	added a couple upper case macros
     32
     33					;	include file for Kermit-11
     34					;
     35					;	Brian Nelson  01-Dec-83  13:56:12
     36
     37						.NLIST	BEX
     38						.LIST	MEB			; /62/
     39
     40		000001 				KRTINC	=	1		; for .include error checking
     41
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 5
KRTMAC	Various handy constants and macros

      1
      2	000000					.psect	$code	,ro,i,lcl,rel,con ; psect ordering..
      3	000000					.psect	$pdata	,ro,d,lcl,rel,con
      4
      5					;	various ascii chars
      6		000001 				SOH	=   1		; default packet start of header
      7		000007 				BELL	=   7		; beep
      8		000010 				BS	=  10		; backspace
      9		000011 				TAB	=  11		; tab
     10		000012 				LF	=  12		; line feed
     11		000014 				FF	=  14		; form feed
     12		000015 				CR	=  15		; carriage return
     13		000016 				CTRL$N	=  16		; ^N VT-100 line drawing on
     14		000017 				CTRL$O	=  17		; ^O VT-100 line drawing off
     15		000021 				XON	=  'Q&37	; ^Q
     16		000023 				XOFF	=  'S&37	; ^S
     17		000033 				ESC	=  33		; escape
     18		000040 				SPACE	=  40
     19		000054 				COMMA	=  54
     20		000056 				DOT	=  56		; /63/
     21		000073 				SCOLON	=  73		; /63/
     22		000176 				TILDE	= 176		; /63/
     23		000177 				DEL	= 177		; delete
     24
     25					;	system data locations
     26		000044 				JSW	= 44		; job status word
     27		000052 				ERRBYT	= 52		; emt error byte
     28		000053 				USERRB	= 53		; /62/ user error byte
     29		000001 					SUCCS$	=  1	; no error
     30		000002 					WARN$	=  2	; warning
     31		000004 					ERROR$	=  4	; error
     32		000010 					SEVER$	= 10	; sever error
     33		000020 					FATAL$	= 20	; fatal error
     34
     35					;	byte offsets into SINIT parameter vector
     36		000000 				P.SPSIZ	= 0		; set packet length
     37		000001 				P.TIME	= 1		; time-out
     38		000002 				P.NPAD	= 2		; number of pad chars
     39		000003 				P.PADC	= 3		; the pad character
     40		000004 				P.EOL	= 4		; eol char
     41		000005 				P.QCTL	= 5		; control char quoting
     42		000006 				P.QBIN	= 6		; 8-bit quote
     43		000007 				P.CHKT	= 7		; checksum type
     44		000010 				P.REPT	= 10		; repeated character prefix
     45		000011 				P.CAPAS	= 11		; capability bitmask
     46		000010 					CAPA.A	= 10	; attribute handling
     47		000002 					CAPA.L	= 2	; /42/ long packets
     48		000004 					CAPA.S	= 4	; /42/ sliding windows
     49		000012 				P.WINDS	= 12		; /43/ window size, # of packets
     50		000013 				P.MXL1	= 13		; /43/ high order of long packet size
     51		000014 				P.MXL2	= 14		; /43/ low order of long packet size
     52		000017 				P.VEND	= 17		; end of parameter vector
     53
     54					; /62/	bits in doattr (file attribute processing)
     55		000001 				AT.CDT	=: 1		; create date
     56		000002 				AT.INF	=: 2		; /63/ system specific info
     57		000004 				AT.LEN	=: 4		; length
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 5-1
KRTMAC	Various handy constants and macros

     58		000010 				AT.PRO	=: 10		; file protection
     59		000020 				AT.SYS	=: 20		; system ID
     60		000040 				AT.TYP	=: 40		; file type
     61		000100 				AT.XLE	=: 100		; exact length in bytes
     62		100000 				AT.ON	=: 100000	; /63/ do attribute processing
     63		000177 				AT.ALL	=: AT.CDT!AT.INF!AT.LEN!AT.PRO!AT.SYS!AT.TYP!AT.XLE
     64
     65					;	bits in trace (debug status word)
     66		000001 				LOG$PA	= 1		; log all packets
     67		000002 				LOG$CO	= 2		; /62/ CONNECT logging to disk
     68		000004 				LOG$RP	= 4		; /62/ rpack chars to TT
     69		000010 				LOG$IO	= 10		; /62/ everything received or sent
     70		000020 				LOG$DE	= 20		; /62/ debugging to TT
     71		040000 				LOG$ON	= 40000		; /63/ set to write to disk, clear to suspend
     72		100000 				LOG$OP	= 100000	; logfile is open
     73		000003 				LOG$AL	= LOG$PA!LOG$CO	; /62/ ALL
     74
     75					;	parity options
     76		000000 				PAR$NO	=: 0		; none
     77		000001 				PAR$OD	=: 1		; odd
     78		000002 				PAR$EV	=: 2		; even
     79		000003 				PAR$MA	=: 3		; mark
     80		000004 				PAR$SP	=: 4		; space
     81
     82					;	file types
     83		177777 				TERMINAL=: -1		; file to term ala xreply, not to disk
     84		000000 				TEXT	=:  0		; normal ascii text files
     85		000001 				BINARY	=:  1		; image mode
     86		000002 				DECNAT	=:  2		; /52/ 8-bit text files
     87
     88					;	terminal types
     89		000000 				NOSCOPE	= 0		; /BBS/ hard copy terminal
     90		000001 				TTY	= 1		; a dumb tube terminal
     91		000002 				VT100	= 2		; itself
     92		000003 				VT200	= 3		; ditto..
     93
     94					;	supported CVT$$ cvt_bit_pattern bits
     95		000004 				C.CRLF	= 4		; discard CR LF FF ESC
     96		000010 				C.LSPA	= 10		; discard leading spaces and tabs
     97		000020 				C.SSPA	= 20		; reduce spaces and tabs to a single space
     98		000040 				C.LCUC	= 40		; lower case to upper case
     99		000200 				C.TSPA	= 200		; discard trailing spaces and tabs
    100
    101		000034 				CON$ESC	=  '\-100	; default CONNECT escape char
    102		000170 				ERBFSIZ	=  120.		; /62/ error msg text buff size
    103		000136 				MAXPAK	=:  94.		; /63/ max_packet_length - max_checksum_length
    104
    105						.if df	NONEIS		; /62/ using NONEIS for convenience..
    106		001000 				ALSIZE	=   1000	; /63/ bufsiz for SET DIAL/PHO NUM
    107		000003 				LN$CNT	=      3.	; /62/ save/recall 3. commands
    108		000120 				LN$MAX	=     80.	; /63/ max command line length
    109		001130 				MAXLNG	=    600.	; /63/ so image is small enuff to run
    110						.iff
    111						ALSIZE	=   2000	; /62/ bufsiz for SET DIAL/PHO NUM
    112						LN$CNT	=     10.	; /63/ save/recall 10. commands
    113						LN$MAX	=    132.	; /63/ max command line length
    114						MAXLNG	=   1920.	; /63/ use max long-packet buff size
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 5-2
KRTMAC	Various handy constants and macros

    115						.endc
    116		001144 				$ALLSIZ	= <MAXLNG+14>&177776 ; /62/ make it this for safety
    117
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 6
KRTMAC	Various handy constants and macros

      1
      2						.sbttl	Utility macros
      3
      4						.macro	.br to		; /63/ added
      5						.if df	to
      6						.if ne	to-.
      7						.error	<; not at location to;>
      8						.endc
      9						.endc
     10						.endm	.br
     11
     12						.macro	.chksp	arg
     13						.ntype	$$5	,arg
     14						.iif eq <<$$5&7>-6> .error arg <; Illegal use of SP (r6) in call>
     15						.endm	.chksp
     16
     17						.macro	calls	name	,arglst
     18					;	subroutine call with arguments passed in an area pointed to by r5
     19					;	(as with F4 and BP2).  all args are pushed onto the stack in the
     20					;	order specified.  r5 points to the sp before the call and is saved
     21					;	and restored.
     22						$$ = 0				; init # of args count
     23						  .irp x ,<arglst>		; count up # of args passed
     24						  $$ = $$+1			; one at a time
     25						  .endr				; got it
     26						.if eq $$			; no args present?
     27						jsr	pc	,name		; if so, substitute a simple call
     28						.iff				; at least one arg in <arglst>
     29						mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
     30						  .if eq $$-1			; is it one or more than one arg?
     31						  .chksp	arglst		; one arg, check for legal SP modes
     32						  mov	arglst	,-(sp)		; doing it thusly generates less code
     33						  mov	sp	,r5		; set pointer to argument list
     34						  jsr	pc	,name		; call the subroutine
     35						  tst	(sp)+			; pop parameter list from stack
     36						  mov	(sp)+	,r5		; /63/ restore r5
     37						  .iff				; arg_count > 1
     38						  $$2 = $$			; extract the args in
     39						    .rept	$$		; reverse order so that
     40						    $$1 = 0			; we might save a little
     41						      .irp x ,<arglst>		; core (four words)
     42						      $$1 = $$1+1		; scan the arg list until we come to
     43						        .if eq $$2-$$1		; the last one before one we just did
     44						        .chksp	x		; check for SP addressing mode
     45						        mov	x	,-(sp)	; push it
     46						        .mexit			; and exit the .irp
     47						        .endc
     48						      .endr
     49						    $$2 = $$2-1			; backwards to previous arg
     50						    .endr
     51						  mov	sp	,r5		; set up the argument list pointer
     52						  jsr	pc	,name		; and go to the routine
     53						  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
     54						  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
     55						  mov	(sp)+	,r5		; /63/ restore r5
     56						  .endc
     57						.endc
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 6-1
Utility macros

     58						.endm	calls
     59
     60						.macro	ctl	src ,dst
     61						clr	-(sp)
     62						bisb	src	,@sp
     63						call	l$xor
     64						movb	(sp)+	,dst
     65						.endm	ctl
     66
     67						.macro	copyz	from ,to ,maxlen
     68						.if  b	<maxlen>
     69						clr	-(sp)
     70						.iff
     71						mov	maxlen	,-(sp)
     72						.endc
     73						mov	from	,-(sp)
     74						mov	to	,-(sp)
     75						call	copyz$
     76						.endm	copyz
     77
     78						.macro	deccvt	val ,buf ,width
     79						mov	r5	,-(sp)
     80						.if  b	<width>
     81						clr	-(sp)
     82						.iff
     83						mov	width	,-(sp)
     84						.endc
     85						mov	val	,-(sp)
     86						mov	buf	,-(sp)
     87						mov	sp	,r5
     88						call	l$cvtnum
     89						add	#6	,sp
     90						mov	(sp)+	,r5
     91						.endm	deccvt
     92
     93						.macro	decout	val
     94						mov	r5	,-(sp)
     95						mov	val	,-(sp)		; /62/ l$wrdec pops this buffer
     96						mov	sp	,r5
     97						call	l$wrdec
     98						mov	(sp)+	,r5
     99						.endm	decout
    100
    101						.macro	direrr	val
    102						mov	val	,-(sp)
    103						call	direr$
    104						.endm	direrr
    105
    106						.macro	incm64	val
    107						inc	val
    108						bic	#^c<77>	,val		; /62/ faster
    109						.endm	incm64
    110
    111						.macro	indexm	reg		; check for auto increment/decrement
    112						.ntype	$$$0	,reg		; modes for macros that can't have..
    113						.if  ne	$$$0-27			; always allow pc autoincrement
    114						$$$0 =	<$$$0&177770>/10	; ..these modes in their arg list
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 6-2
Utility macros

    115						.ift				; get the mode into 0..7
    116						  .if  ge $$$0-2		; if mode >=2 and mode <=5 then error
    117						  .iif ge <5-$$$0> .error      <; Can't use auto inc/dec mode here>
    118						  .endc
    119						.endc
    120						.endm	indexm
    121
    122						.macro	ixor	reg ,dst
    123					;	get around the mode restrictions for the hardware XOR instruction
    124					;	and fix for RT-11 systems that don't have the EIS chip option
    125						.chksp	reg			; can't allow sp args
    126						.chksp	dst			; in either register
    127						indexm	reg			; check for allowed
    128						indexm	dst			; addressing mode
    129						mov	reg	,-(sp)		; it's much simpler to do this
    130						bic	dst	,@sp		; for all RT-11 systems rather
    131						bic	reg	,dst		; than to be selective
    132						bis	(sp)+	,dst		; done
    133						.endm	ixor
    134
    135						.macro	.newline		; print CR/LF on TT
    136						call	l$pcrlf
    137						.endm	.newline
    138
    139						.macro	octout	val
    140						calls	l$wroct	,<val>
    141						.endm	octout
    142
    143						.macro	prsbuf	dst
    144						mov	dst	,r0
    145						call	prsarg
    146						.endm	prsbuf
    147
    148						.macro	rpack	len.a ,pakn.a ,msg.a ,max.len	; /62/
    149						sub	#10	,sp
    150						mov	sp	,r1
    151						calls	rpack$	,<msg.a,r1,max.len>
    152						mov	(r1)+	,len.a
    153						mov	(r1)+	,pakn.a
    154						mov	@r1	,r1
    155						add	#10	,sp
    156						.endm	rpack
    157
    158						.macro	save	list
    159						.if  b	<list>
    160						 save	<r0,r1,r2,r3,r4,r5>
    161						.iff
    162						.irp	x ,<list>
    163						 mov	x	,-(sp)
    164						.endr
    165						.endc
    166						.endm	save
    167
    168						.macro	scan	ch ,str
    169						mov	str	,-(sp)
    170						clr	-(sp)
    171						bisb	ch	,@sp
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 6-3
Utility macros

    172						call	scanch
    173						.endm	scan
    174
    175						.macro	setpar	src ,dst
    176						movb	src	,-(sp)
    177						call	dopari
    178						movb	(sp)+	,dst
    179						.endm	setpar
    180
    181						.macro	spack	type ,pnum ,len ,msg
    182						.if  b	<len>
    183						.iif nb	<msg>	.error	<; bad call to SPACK macro>
    184						calls	spack$	,<type,pnum,#0,#null>
    185						.iff
    186						calls	spack$	,<type,pnum,len,msg>
    187						.endc
    188						.endm	spack
    189
    190						.macro	strcat	dst ,src
    191						mov	src	,-(sp)
    192						mov	dst	,-(sp)
    193						jsr	pc	,strcat
    194						.endm	strcat
    195
    196						.macro	strcpy	dst ,src
    197						mov	src	,-(sp)
    198						mov	dst	,-(sp)
    199						jsr	pc	,strcpy
    200						.endm	strcpy
    201
    202						.macro	strlen	string
    203						mov	string	,r0
    204						call	l$len
    205						.endm	strlen
    206
    207						.macro	textsrc	text
    208						.if  b	<text>
    209						clr	getcroutine		; /62/ reset to file I/O
    210						clr	tgetaddr
    211						.iff
    212						mov	#tgetcr0,getcroutine
    213						mov	text	,tgetaddr
    214						.endc
    215						.endm	textsrc
    216
    217						.macro	tochar	src ,dst
    218						clr	-(sp)
    219						bisb	src	,@sp
    220						add	#40	,@sp
    221						movb	(sp)+	,dst
    222						.endm	tochar
    223
    224						.macro	unchar	src ,dst
    225						clr	-(sp)
    226						bisb	src	,@sp
    227						sub	#40	,@sp
    228						movb	(sp)+	,dst
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 6-4
Utility macros

    229						.endm	unchar
    230
    231						.macro	unsave	list
    232						.if b <list>
    233						unsave	<r5,r4,r3,r2,r1,r0>
    234						.iff
    235						.irp	x ,<list>
    236						 mov	(sp)+	,x
    237						.endr
    238						.endc
    239						.endm	unsave
    240
    241						.macro	upcase	s		; /BBS/ added ..
    242						mov	s	,r0
    243						call	upcase			; /BBS/ upcase until null terminator
    244						.endm	upcase
    245
    246						.macro	upone	s		; /BBS/ added ..
    247						mov	s	,r0
    248						call	upone			; /BBS/ upcase only to next delimiter
    249						.endm	upone
    250
    251						.macro	wrtall	arg		; IO.WAL for an .asciz string
    252						mov	arg	,-(sp)		; pass the address
    253						call	wrtall			; do it
    254						.endm	wrtall
    255
    256						.macro	xor	reg ,dst
    257						ixor	reg	,dst
    258						.endm	xor
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 7
Utility macros

      1						.iif ndf  KRTINC  .error	<; .include for IN:KRTMAC.MAC failed>
      2
      3						.sbttl	Macro references, various handy constants defined
      4
      5					; /62/	.PEEK bypassed for V4, also expanded to allow assembly under same
      6					; /62/	.CRAW,.CRRG,.RDBBK,.WDBBK expanded as well..
      7
      8						.MCALL	.CSTAT	,.DSTAT	,.EXIT	,.GTIM	,.GTJB	,.GVAL
      9						.MCALL	.LOOKUP	,.PURGE	.QSET	,.RCTRLO,.SERR	,.SETTOP
     10
     11
     12		000320 				CNTXT	= 320		; /62/ pointer to impure area of current job
     13		000300 				CONFIG	= 300		; RT-11 primary configuration word
     14		000001 					SJSYS	= 1	; clear if a SJ system
     15		000040 					HERTZ50	= 40	; /BBS/ 50Hz clock if set
     16		010000 					XMSYS	= 10000	; XM if set and SJSYS off
     17		000370 				CONFG2	= 370		; /62/ RT-11 configuration word 2
     18		000400 					EIS$	= 400	; /62/ extended instruction set is present
     19		177760 				CURPRI	= -16.		; /BBS/ offset to TSX current priority
     20		000366 				STATWD	= 366		; /62/ DCL indirect file status word
     21		000400 					IFACTV	= 400	; /62/ indirect file active bit
     22		000372 				SYSGEN	= 372		; /BBS/ sysgen features word
     23		002000 					MARKTIM	= 2000	; SJ timer support is present
     24		000276 				SYSVER	= 276		; the monitor version number
     25		000050 				TOPMEM	= 50		; location of address of top of memory
     26		177740 				TS.VER	= -32.		; /BBS/ offset to TSX version number
     27		020000 				VRUN$	= 20000		; /62/ VBGEXE bit in job state word
     28
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 8
Macro references, various handy constants defined

      1
      2						.sbttl	APR7 buffer allocation	; /BBS/ moved here..
      3
      4					;	ALSIZE is the SET DIAL,PHONE buffer length, and lives in KRTMAC.MAC
      5		000200 				BINLSIZ	= 40*4			; binary types list buffer size
      6					;	$ALLSIZ is the packet buffer length, and lives in KRTMAC.MAC
      7		001000 				MAXSIZ	==   1000		; individual file buffer size
      8		004010 				$$BUFP	= <<MAXSIZ+2>*4>	; 4 file buffers: in, out, log, take
      9		000402 				$.1	= 82.+200+60		; /62/ dirnam + dirbfr + phnum buffers
     10		000340 				$.2	= <34*2*2>*2		; totp.r and totp.s stats buffers
     11		000244 				$.3	= <LN$MAX+2>*2		; cmdbuf and argbuf allocations
     12		000366 				$.4	= <<LN$MAX+2>*LN$CNT>	; SL editor command line buffers
     13
     14		010150 				TOTALL	== <ALSIZE+BINLSIZE+$ALLSIZ+$$BUFP+$.1+$.2+$.3+$.4>
     15
     16						.if eq TOTALL-<<TOTALL/100>*100> ; 32-word boundary
     17						ALLOC	== TOTALL		; landed right on it
     18						.iff
     19		010200 				ALLOC	== <TOTALL&177700>+100	; force to next 32-word boundary
     20						.endc
     21
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 9
APR7 buffer allocation	; /BBS/ moved here..

      1
      2						.sbttl	Local data
      3
      4	000000					.psect	mapwin	,rw,d,gbl,rel,con  ; ensure window data in ROOT
      5	000000				apr7re:	; /62/	.rdbbk	alloc/100	; define symbols and reserve space
      6		000000 				R.GID=:0			; /62/ expanded to assemble under V4
      7		000002 				R.GSIZ=:2.			; /62/ even though it won't run there
      8		000004 				R.GSTS=:4.
      9		000006 				R.GNAM=:6.
     10		000012 				R.GBAS=:10.
     11		000014 				R.GLGH=:12.
     12		100000 				RS.CRR=:^o100000
     13		040000 				RS.UNM=:^o40000
     14		020000 				RS.NAL=:^o20000
     15		010000 				RS.NEW=:^o10000
     16		004000 				RS.GBL=:^o4000
     17		002000 				RS.CGR=:^o2000
     18		001000 				RS.AGE=:^o1000
     19		000400 				RS.EGR=:^o400
     20		000200 				RS.EXI=:^o200
     21		000100 				RS.CAC=:^o100
     22		000040 				RS.BAS=:^o40
     23		000020 				RS.NSM=:^o20
     24	000000	000000 	000102 	000000 		.WORD	0,alloc/100,0,0,0,0
     25	000014				apr7wi:	; /62/	.wdbbk	7,alloc/100,0,0,alloc/100,ws.map ; for memory region
     26		000000 				W.NID=:0			; /62/ expanded to assemble under V4
     27		000001 				W.NAPR=:1			; /62/ even though it won't run there
     28		000002 				W.NBAS=:2.
     29		000004 				W.NSIZ=:4.
     30		000006 				W.NRID=:6.
     31		000010 				W.NOFF=:^o10
     32		000012 				W.NLEN=:^o12
     33		000014 				W.NSTS=:^o14
     34		000016 				W.NLGH=:^o16
     35		100000 				WS.CRW=:^o100000
     36		040000 				WS.UNM=:^o40000
     37		020000 				WS.ELW=:^o20000
     38		000400 				WS.MAP=:^o400
     39	000014	   000 	   007 			.BYTE	0,7
     40	000016	000000 	000102 	000000 		.WORD	0,alloc/100,0,0,alloc/100,ws.map
     41	000032	000000 	000000 		mapwrk:	.word	0 ,0			; mapping work buffer
     42
     43	000000					.psect	$rwdata	,rw,d,lcl,rel,con
     44	000000	000000 	000000 		chkbuf:	.word	0 ,0			; /BBS/ check for running clock buff
     45	000004	000000 	000000 		timbuf:	.word	0 ,0			; roll the clock over buffer
     46	000010	   000 	   141 		tsxmem:	.byte	0 ,141			; TSX-Plus get more memory emt
     47	000012	000000 				.word	0			; /BBS/ xinit puts size in here
     48
     49	000000					.psect	$pdata
     50	000000	   000 	   155 		cl0asn:	.byte	0 ,155			; try to assign
     51	000002	000000 				.word	0			; CL0 to
     52	000004	000003 				.word	3			; line 3
     53	000006	   000 	   155 		cl1asn:	.byte	0 ,155			; try to assign
     54	000010	000001 				.word	1			; CL1 to
     55	000012	000003 				.word	3			; line 3
     56	000014	   000 	   144 		tsxjob:	.byte	0 ,144			; /62/ TSX job status info emt args
     57	000016	   000 	   000 		tsxj.l:	.byte	0 , 0			; /62/ line_# ,subfunct (line status)
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 9-1
Local data

     58	000020	000000'				.word	chkbuf			; /62/ borrow a buffer to return stats
     59	000022	   000 	   110 		tsxlin:	.byte	0 ,110			; TSX get line number emt
     60	000024	   000 	   152 		tsxon:	.byte	0 ,152			; /BBS/ TSX nowait TT input mode
     61	000026	000125 	000000 			.word	'U&137	,0
     62	000032	   000 	   152 		tsxsin:	.byte	0 ,152			; /BBS/ TSX single char activation
     63	000034	000123 	000000 			.word	'S&137	,0
     64	000040	   000 	   137 		tsxtrm:	.byte	0 ,137			; TSX get terminal type
     65	000042	043310 			km.r50:	.rad50	"KM "			; /62/ to test for KM
     66	000044	062550 			pi.r50:	.rad50	"PI "			; used to test for PRO hardware
     67	000046	113170 			xc.r50:	.rad50	"XC "			; device names for
     68	000050	113740 			xl.r50:	.rad50	"XL "			; testing for same
     69
     70	000052	   000 	   001 	   002 	trmlst:	.byte	0.	,1.	,2.	,3.	,4. ; terminal types
     71	000057	   005 	   006 	   007 		.byte	5.	,6.	,7.	,8.	,9. ; data table
     72	000064	   377 				.byte	-1
     73						.even
     74	000066	000000 	000001 	000002 	trmtyp:	.word	NOSCOPE	,TTY	,VT100	,TTY	,TTY
     75	000100	000000 	000000 	000001 		.word	NOSCOPE	,NOSCOPE,TTY	,TTY	,VT200
     76
     77	000112	   103 	   114 	   060 	cl0text:.asciz	"CL0:"			; asciz names
     78	000117	   103 	   114 	   061 	cl1text:.asciz	"CL1:"			; for TSX
     79	000124	   077 	   113 	   122 	fatal:	.asciz	"?KRTOSI-F-"
     80	000137	   124 	   150 	   151 	noxcmt:	.ascii	"This system lacks KM, XC and XL drivers.  "	; /62/
     81	000211	   124 	   124 	   040 		.ascii	"TT must be used for transfers."<cr><lf>
     82	000251	   120 	   141 	   143 		.ascii	"Packet length has been set to 60. bytes "
     83	000321	   164 	   157 	   040 		.asciz	"to avoid overflowing the console port."<cr><lf>
     84	000372	   120 	   141 	   143 	nolog:	.ascii	"Packet stats display disabled for FRUNed Kermit."<cr><lf>
     85	000454	   125 	   163 	   145 		.asciz	"Use SET UPDATE to enable stats during transfers."<cr><lf>
     86	000537	   122 	   124 	   055 	osi.01:	.asciz	"RT-11SJ must be SYSGENNED with timer support"<cr><lf>
     87	000616	   114 	   151 	   156 	osi.02:	.asciz	"Line Time Clock is not running"<cr><lf>
     88	000657	   103 	   120 	   125 	osi.03:	.asciz	"CPU has no EIS support, rebuild KRT with KRTASM.NON"<cr><lf>
     89	000745	   110 	   111 	   115 	osi.04:	.asciz	"HIMEM in TSGEN.MAC must be at least "
     90	001012	   056 	   040 	   142 	osi.05:	.asciz	". bytes"<cr><lf>
     91	001024	   103 	   122 	   122 	osi.06:	.asciz	"CRRG/CRAW error #"
     92	001046	   111 	   156 	   163 	osi.07:	.ascii	"Insufficient space available for buffer allocation"<cr><lf>
     93	001132	   124 	   117 	   124 		.asciz	"TOTALL = "
     94	001144	   054 	   040 	   040 	osi.08:	.asciz	",  MAXTOP-HILIMIT = "
     95	001171	   120 	   162 	   157 	osi.09:	.ascii	"Program high limit exceeds top of memory"<cr><lf>
     96	001243	   110 	   111 	   114 		.asciz	"HILIMIT = "
     97	001256	   054 	   040 	   040 	osi.10:	.asciz	",  MAXTOP = "
     98	001273	   015 	   012 	   131 	osi.11:	.asciz	<cr><lf>"You are "
     99	001306	   040 	   146 	   162 	osi.12:	.asciz	" from happiness.."<cr><lf>
    100	001332	   056 	   040 	   167 	osi.13:	.asciz	". word"
    101	001341	   163 	   000 		osi.14: .asciz	"s"			; /63/ not 1, so make it plural
    102	001343	   040 	   146 	   162 	osi.15:	.asciz	" free to load handlers"<cr><lf>
    103						.even
    104
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 10
Local data

      1
      2	000000					.psect	$code
      3						.sbttl	Init for RT-11/TSX-Plus
      4
      5	000000				xinit::	.gtim	#rtwork	,#timbuf	; ensure clock rollover
	000000	012700 	000000G			MOV	#rtwork,R0
	000004	012710 	010400 			MOV	#17.*^O400+0.,@R0
	000010	012760 	000004'	000002 		MOV	#timbuf,2.(R0)
	000016	104375 				EMT	^O375
      6	000020	012767 	000074 	000000G		mov	#60.	,clkflg		; /BBS/ preset clock rate at 60Hz
      7	000026	012767 	000021 	000002G		mov	#17.	,break+2	; /BBS/ assume 60Hz for break length
      8	000034					.gval	#rtwork	,#config	; get RMON configuration word into r0
	000034	012700 	000000G			MOV	#rtwork,R0
	000040	012710 	016000 			MOV	#28.*^O400+0.,@R0
	000044	012760 	000300 	000002 		MOV	#config,2.(R0)
	000052	104375 				EMT	^O375
      9	000054	032700 	000040 			bit	#hertz50,r0		; /BBS/ is clock 50Hz?
     10	000060	001406 				beq	10$			; /BBS/ nope..
     11	000062	012767 	000062 	000000G		mov	#50.	,clkflg		; /BBS/ ya, overwrite 60Hz default
     12	000070	012767 	000016 	000002G		mov	#14.	,break+2	; /BBS/ and fix break length for 50Hz
     13	000076	032700 	000001 		10$:	bit	#sjsys	,r0		; is this the SJ monitor?
     14	000102	001027 				bne	20$			; it's FB or XM
     15	000104	005367 	000000G			dec	montyp			; /BBS/ it's SJ, exec type saved
     16	000110					.gval	#rtwork	,#sysgen	; /BBS/ check for
	000110	012700 	000000G			MOV	#rtwork,R0
	000114	012710 	016000 			MOV	#28.*^O400+0.,@R0
	000120	012760 	000372 	000002 		MOV	#sysgen,2.(R0)
	000126	104375 				EMT	^O375
     17	000130	032700 	002000 			bit	#marktime,r0		; /BBS/ timer support
     18	000134	001022 				bne	30$			; /BBS/ found it
     19	000136					wrtall	#fatal			; /BBS/ fatal error message prefix
	000136	012746 	000124'			mov	#fatal	,-(sp)		; pass the address
	000142	004767 	000000G			call	wrtall			; do it
     20	000146					wrtall	#osi.01			; /63/ "must SYSGEN w/timer support"
	000146	012746 	000537'			mov	#osi.01	,-(sp)		; pass the address
	000152	004767 	000000G			call	wrtall			; do it
     21	000156	000167 	001074 			jmp	180$			; go die..
     22
     23	000162	032700 	010000 		20$:	bit	#xmsys	,r0		; XM system?  r0=config_word
     24	000166	001405 				beq	30$			; no, must be FB
     25	000170	005267 	000000G			inc	montyp			; it's XM, save flag
     26	000174	012767 	000002G	000000G		mov	#$limit+2,hilimit	; we really want VIRTUAL limit
     27
     28	000202	005002 			30$:	clr	r2			; /63/ init a 64k pass loop counter
     29	000204				40$:	.gtim	#rtwork	,#chkbuf	; /BBS/ check to see if clock is on
	000204	012700 	000000G			MOV	#rtwork,R0
	000210	012710 	010400 			MOV	#17.*^O400+0.,@R0
	000214	012760 	000000'	000002 		MOV	#chkbuf,2.(R0)
	000222	104375 				EMT	^O375
     30	000224	026767 	000002'	000006'		cmp	chkbuf+2,timbuf+2	; /63/ well?
     31	000232	001014 				bne	50$			; /62/ there is a clock..
     32	000234					sob	r2	,40$		; /63/ not yet, try it again
	000234	005302 				dec	r2
	000236	001362 				bne	40$
     33	000240					wrtall	#fatal			; /BBS/ no clock, Kermit must die
	000240	012746 	000124'			mov	#fatal	,-(sp)		; pass the address
	000244	004767 	000000G			call	wrtall			; do it
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 10-1
Init for RT-11/TSX-Plus

     34	000250					wrtall	#osi.02			; /63/ "LTC is not running"
	000250	012746 	000616'			mov	#osi.02	,-(sp)		; pass the address
	000254	004767 	000000G			call	wrtall			; do it
     35	000260	000167 	000772 			jmp	180$
     36
     37	000264	005402 			50$:	neg	r2			; /63/ convert to # clock test loops
     38	000266	010267 	000000G			mov	r2	,qedtst		; /63/ save so count can be EXAMINEd
     39						.if ndf	NONEIS			; /62/ if KRT was built for an EIS CPU
     40						.gval	#rtwork	,#confg2	; /62/ check to see
     41						bit	#eis$	,r0		; /62/ if an EIS CPU is running this..
     42						bne	60$			; /62/ it is
     43						wrtall	#fatal			; /62/ no EIS present
     44						wrtall	#osi.03			; /63/ "CPU has no EIS support ..."
     45						jmp	180$
     46						.endc	; ndf NONEIS
     47
     48	000272				60$:	.gtjb	#rtwork	,#jobsts	; so we know if BG or FG job
	000272	012700 	000000G			MOV	#rtwork,R0
	000276	012710 	010001 			MOV	#16.*^O400+1.,@R0
	000302	012760 	000000G	000002 		MOV	#jobsts,2.(R0)
	000310	012760 	177775 	000004 		MOV	#-3.,4.(R0)
	000316	104375 				EMT	^O375
     49	000320					.gval	#rtwork	,#statwd	; /62/ DCL indirect file status word
	000320	012700 	000000G			MOV	#rtwork,R0
	000324	012710 	016000 			MOV	#28.*^O400+0.,@R0
	000330	012760 	000366 	000002 		MOV	#statwd,2.(R0)
	000336	104375 				EMT	^O375
     50	000340	032700 	000400 			bit	#ifactv	,r0		; /62/ indirect file running this pgm?
     51	000344	001402 				beq	70$			; /62/ no
     52	000346	005267 	000000G			inc	jobtype			; /62/ ya, flag it for error handling
     53	000352				70$:	.qset	#rtque	,#nrtque	; allocate extra queue elements
	000352	012746 	000000G			MOV	#rtque,-(SP)
	000356	012700 	000000G			MOV	#nrtque,R0
	000362	104353 				EMT	^O<353>
     54
     55					; /62/	W A R N I N G:  the following 70. lines of code may seem somewhat
     56					;	kludgey, however to get this all to run across all the various OS
     57					;	versions and hardware and options and etc, this it it -
     58
     59	000364					.serr	;; /BBS/ NOTE: .serr is set here and remains enabled forever..
	000364	012700 	002000 			MOV	#^O2000,R0
	000370	104374 				EMT	^O374
     60	000372	012702 	010150 			mov	#totall	,r2		; /BBS/ need this much buffer space
     61	000376					.gval	#rtwork	,#sysver	; /62/ get monitor version number
	000376	012700 	000000G			MOV	#rtwork,R0
	000402	012710 	016000 			MOV	#28.*^O400+0.,@R0
	000406	012760 	000276 	000002 		MOV	#sysver,2.(R0)
	000414	104375 				EMT	^O375
     62	000416	110067 	000000G			movb	r0	,rt11ver	; /62/ save it here
     63	000422	000300 				swab	r0			; /62/ now get the
     64	000424	110067 	000000G			movb	r0	,rt11upd	; /62/ release level
     65	000430	026727 	000000G	000005 		cmp	rt11ver	,#5		; /62/ what version is this?
     66	000436	002426 				blt	80$			; /62/ VBGEXE doesn't exist before V5
     67	000440					.gval	#rtwork	,#cntxt		; /62/ get pointer to impure area
	000440	012700 	000000G			MOV	#rtwork,R0
	000444	012710 	016000 			MOV	#28.*^O400+0.,@R0
	000450	012760 	000320 	000002 		MOV	#cntxt,2.(R0)
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 10-2
Init for RT-11/TSX-Plus

	000456	104375 				EMT	^O375
     68	000460	010001 				mov	r0	,r1		; /62/ save a copy of it
     69	000462	001414 				beq	80$			; /62/ if cntxt=0, it's TSX
     70					; /62/	.peek	#rtwork	,r1		; /62/ get job state word
     71	000464	012700 	000000G			MOV	#rtwork	,R0		; /62/ expanded for assy under V4
     72	000470	012710 	016001 			MOV	#28.*^o400+1.,@R0	; /62/ even though V4 can't run it
     73	000474	010160 	000002 			MOV	r1	,2.(R0)		; /62/
     74	000500	104375 				EMT	^o375			; /62/
     75	000502	032700 	020000 			bit	#vrun$	,r0		; /62/ running under VBGEXE today?
     76	000506	001402 				beq	80$			; /62/ nope..
     77	000510	010667 	000000G			mov	sp	,vbgexe		; /62/ ya
     78	000514	005767 	000000G		80$:	tst	imgtyp			; /62/ is this virtual overlay image?
     79	000520	001403 				beq	90$			; no
     80	000522	062702 	160000 			add	#160000	,r2		; top limit minimum for virtual memory
     81	000526	000412 				br	110$			; skip low memory stuff
     82
     83	000530	005767 	000000G		90$:	tst	vbgexe			; /62/ is VBGEXE running this program?
     84	000534	001403 				beq	100$			; /62/ no
     85	000536	012767 	000050 	000000G		mov	#topmem	,hilimit	; /62/ ya use location 50 not $limit+2
     86	000544	063702 	000050 		100$:	add	@#topmem,r2		; /BBS/ disk overlaid, add high limit
     87	000550	062702 	000004 			add	#4	,r2		; /BBS/ fudge factor for TSX
     88
     89	000554	012700 	000010'		110$:	mov	#tsxmem	,r0		; /BBS/ grab some extra TSX memory
     90	000560	010260 	000002 			mov	r2	,2(r0)		; /BBS/ pass size to tsxmem emt..
     91	000564	104375 				emt	375			; call TSX now
     92	000566	103423 				bcs	120$			; must be RT-11 today
     93	000570	020002 				cmp	r0	,r2		; TSX+, did it give us enough?
     94	000572	103021 				bhis	120$			; yes, keep on going
     95	000574					wrtall	#fatal			; /BBS/ no
	000574	012746 	000124'			mov	#fatal	,-(sp)		; pass the address
	000600	004767 	000000G			call	wrtall			; do it
     96	000604					wrtall	#osi.04			; /63/ "HIMEM .. must be at least .."
	000604	012746 	000745'			mov	#osi.04	,-(sp)		; pass the address
	000610	004767 	000000G			call	wrtall			; do it
     97	000614	010200 				mov	r2	,r0		; copy needed value for L10266
     98	000616	004767 	000000G			call	L10266			; /BBS/ what it needs..
     99	000622					wrtall	#osi.05			; /63/	". bytes"<cr><lf>
	000622	012746 	001012'			mov	#osi.05	,-(sp)		; pass the address
	000626	004767 	000000G			call	wrtall			; do it
    100	000632	000167 	000420 			jmp	180$			; /BBS/ die
    101
    102	000636	012702 	000000G		120$:	mov	#freept	,r2		; setup pointer to start of free core
    103	000642	012712 	160000 			mov	#160000,@r2		; /62/ assume /v ovrlys and force APR7
    104	000646	005767 	000000G			tst	imgtyp			; /62/ is it really /v overlays today?
    105	000652	001002 				bne	130$			; /62/ yes
    106	000654	017712 	000000G			mov	@hilimit,@r2		; no, free core list for SJ/FB .fetch
    107	000660	062712 	000003 		130$:	add	#3	,@r2		; +2 to pointer above us please
    108	000664	042712 	000001 			bic	#1	,@r2		; whilst ensuring even address
    109	000670	005767 	000000G			tst	imgtyp			; /62/ running the XM image?
    110	000674	001451 				beq	150$			; /BBS/ no, use .settop for buffers
    111
    112										; it's KRTTSX.SAV on RT-11XM or TSX+
    113					; /62/	.crrg	#mapwrk	,#apr7re	; we will instead create a region
    114	000676	012700 	000032'			MOV	#mapwrk	,R0		; /62/ expanded to assemble under V4
    115	000702	012710 	017000 			MOV	#30.*^o400+0.,@R0	; /62/ even though it can't run there
    116	000706	012760 	000000'	000002 		MOV	#apr7re	,2.(R0)		; /62/
    117	000714	104375 				EMT	^o375			; /62/
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 10-3
Init for RT-11/TSX-Plus

    118	000716	103421 				bcs	140$			; didn't work..
    119	000720	016767 	000000'	000022'		mov	apr7re+r.gid,apr7wi+w.nrid  ; this will allow future expansion
    120					; /62/	.craw	#mapwrk	,#apr7wi	; create address window and map it
    121	000726	012700 	000032'			MOV	#mapwrk	,R0		; /62/ expanded to assemble under V4
    122	000732	012710 	017002 			MOV	#30.*^o400+2.,@R0	; /62/ even though it can't run there
    123	000736	012760 	000014'	000002 		MOV	#apr7wi	,2.(R0)		; /62/
    124	000744	104375 				EMT	^o375			; /62/
    125	000746	103405 				bcs	140$			; if failed..
    126	000750	012767 	170200 	000000G		mov	#alloc+160000,maxtop	; /BBS/ success, save copy of the top
    127	000756	000167 	000336 			jmp	A200$			; continue
    128
    129	000762	113700 	000052 		140$:	movb	@#errbyt,r0		; region failed, get the error code
    130	000766					wrtall	#fatal			; fatal error message prefix
	000766	012746 	000124'			mov	#fatal	,-(sp)		; pass the address
	000772	004767 	000000G			call	wrtall			; do it
    131	000776					wrtall	#osi.06			; /63/ "CRRG/CRAW error #"
	000776	012746 	001024'			mov	#osi.06	,-(sp)		; pass the address
	001002	004767 	000000G			call	wrtall			; do it
    132	001006	004767 	000000G			call	L10266			; /BBS/ dump error byte
    133	001012					.newline
	001012	004767 	000000G			call	l$pcrlf
    134	001016	000517 				br	180$			; /BBS/ die on mapping failure
    135
    136	001020				150$:	.settop	#-2			; SJ or FB, or TSX and disk overlays
	001020	012700 	177776 			MOV	#-2,R0
	001024	104354 				EMT	^O<354>
    137	001026	010067 	000000G			mov	r0	,maxtop		; save the current max address
    138	001032	021200 				cmp	@r2	,r0		; is there REALLY space available?
    139	001034	101042 				bhi	160$			; no, die
    140	001036	161200 				sub	@r2	,r0		; compute space available now
    141	001040	022700 	010150 			cmp	#totall	,r0		; space available for buffer pool?
    142	001044	101525 				blos	A200$			; yes, it's ok
    143
    144	001046					wrtall	#fatal			; /BBS/ added this..
	001046	012746 	000124'			mov	#fatal	,-(sp)		; pass the address
	001052	004767 	000000G			call	wrtall			; do it
    145	001056					wrtall	#osi.07			; /63/ "Insufficient space ..TOTALL ="
	001056	012746 	001046'			mov	#osi.07	,-(sp)		; pass the address
	001062	004767 	000000G			call	wrtall			; do it
    146	001066					octout	#totall			; dump octal value to TT
	001066	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001070	012746 	010150 			  mov	#totall	,-(sp)		; doing it thusly generates less code
	001074	010605 				  mov	sp	,r5		; set pointer to argument list
	001076	004767 	000000G			  jsr	pc	,l$wroct		; call the subroutine
	001102	005726 				  tst	(sp)+			; pop parameter list from stack
	001104	012605 				  mov	(sp)+	,r5		; /63/ restore r5
    147	001106					wrtall	#osi.08			; /63/ ",  MAXTOP-HILIMIT = "
	001106	012746 	001144'			mov	#osi.08	,-(sp)		; pass the address
	001112	004767 	000000G			call	wrtall			; do it
    148	001116					octout	r0			; dump octal value to TT
	001116	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001120	010046 				  mov	r0	,-(sp)		; doing it thusly generates less code
	001122	010605 				  mov	sp	,r5		; set pointer to argument list
	001124	004767 	000000G			  jsr	pc	,l$wroct		; call the subroutine
	001130	005726 				  tst	(sp)+			; pop parameter list from stack
	001132	012605 				  mov	(sp)+	,r5		; /63/ restore r5
    149	001134	162700 	010150 			sub	#totall	,r0		; get diff for reporting
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 10-4
Init for RT-11/TSX-Plus

    150	001140	000433 				br	170$			; and go display it
    151
    152	001142				160$:	wrtall	#fatal			; /BBS/ added this too..
	001142	012746 	000124'			mov	#fatal	,-(sp)		; pass the address
	001146	004767 	000000G			call	wrtall			; do it
    153	001152					wrtall	#osi.09			; /63/ "..high limit exceeds top.."
	001152	012746 	001171'			mov	#osi.09	,-(sp)		; pass the address
	001156	004767 	000000G			call	wrtall			; do it
    154	001162					octout	@r2			; dump octal value to TT
	001162	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001164	011246 				  mov	@r2	,-(sp)		; doing it thusly generates less code
	001166	010605 				  mov	sp	,r5		; set pointer to argument list
	001170	004767 	000000G			  jsr	pc	,l$wroct		; call the subroutine
	001174	005726 				  tst	(sp)+			; pop parameter list from stack
	001176	012605 				  mov	(sp)+	,r5		; /63/ restore r5
    155	001200					wrtall	#osi.10			; /63/ ",  MAXTOP = "
	001200	012746 	001256'			mov	#osi.10	,-(sp)		; pass the address
	001204	004767 	000000G			call	wrtall			; do it
    156	001210					octout	r0			; r0 still contains maxtop here
	001210	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001212	010046 				  mov	r0	,-(sp)		; doing it thusly generates less code
	001214	010605 				  mov	sp	,r5		; set pointer to argument list
	001216	004767 	000000G			  jsr	pc	,l$wroct		; call the subroutine
	001222	005726 				  tst	(sp)+			; pop parameter list from stack
	001224	012605 				  mov	(sp)+	,r5		; /63/ restore r5
    157	001226	161200 				sub	@r2	,r0		; get diff for reporting
    158
    159	001230				170$:	wrtall	#osi.11			; /63/ <cr><lf>"You are "
	001230	012746 	001273'			mov	#osi.11	,-(sp)		; pass the address
	001234	004767 	000000G			call	wrtall			; do it
    160	001240	005400 				neg	r0			; fix sign, args were flipped
    161	001242	004767 	000014 			call	plural			; display value and "word" or "words"
    162	001246					wrtall	#osi.12			; /63/ " from happiness.."<cr><lf>
	001246	012746 	001306'			mov	#osi.12	,-(sp)		; pass the address
	001252	004767 	000000G			call	wrtall			; do it
    163	001256	005000 			180$:	clr	r0			; do a hard exit (includes .hreset)
    164	001260					.exit
	001260	104350 				EMT	^O350
    165
    166	001262	006200 			plural:	asr	r0			; /BBS/ display size in words
    167	001264	010001 				mov	r0	,r1		; copy to test for singular/plural
    168	001266	004767 	000000G			call	L10266			; dump size to TT
    169	001272					wrtall	#osi.13			; /63/ ". word"
	001272	012746 	001332'			mov	#osi.13	,-(sp)		; pass the address
	001276	004767 	000000G			call	wrtall			; do it
    170	001302	005301 				dec	r1			; just one word?
    171	001304	001404 				beq	190$			; ya, don't make it plural
    172	001306					wrtall	#osi.14			; /63/ no, add an "s"
	001306	012746 	001341'			mov	#osi.14	,-(sp)		; pass the address
	001312	004767 	000000G			call	wrtall			; do it
    173	001316	000207 			190$:	return
    174
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 11
Init for RT-11/TSX-Plus

      1
      2						.sbttl	Allocate and init buffers
      3
      4					; /BBS/	 NOTE:	if you add or change any buffer here you must also
      5					;		conform the constants from which TOTALL is derived
      6					;		at the top of this file
      7
      8	001320	011200 			A200$:	mov	@r2	,r0		; /62/ save top to clear when done
      9	001322	012703 	000002 			mov	#2	,r3		; offset into buflst
     10	001326	012704 	000004 			mov	#4	,r4		; /62/ four buffers to set up
     11	001332	011263 	000000G		210$:	mov	@r2	,buflst(r3)	; setup our buffer addresses now
     12	001336	062712 	001000 			add	#maxsiz	,@r2		; fix freept up to point to next
     13	001342	062703 	000002 			add	#2	,r3		; point to next list entry
     14	001346					sob	r4	,210$		; /62/ simple
	001346	005304 				dec	r4
	001350	001370 				bne	210$
     15	001352	011267 	000000G			mov	@r2	,xklgbuf	; a special buffer for XC/XL/CL
     16	001356	062712 	001144 			add	#$allsiz,@r2		; add in the allocation now
     17	001362	011267 	000000G			mov	@r2	,albuff		; allocate this buffer
     18	001366	062712 	001000 			add	#alsize	,@r2		; and move the pointer up
     19	001372	011267 	000000G			mov	@r2	,dirnam		; allocate more static buffers
     20	001376	062712 	000122 			add	#82.	,@r2		; /62/ allow for max .csispc can do
     21	001402	011267 	000000G			mov	@r2	,dirbfr		; allocate more dir listing buffers
     22	001406	062712 	000200 			add	#200	,@r2		; /62/ and move on up
     23	001412	011267 	000000G			mov	@r2	,phnum		; save a phonenumber for REDIAL
     24	001416	062712 	000060 			add	#60	,@r2		; allocate it
     25	001422	011267 	000000G			mov	@r2	,bintyp		; more to go
     26	001426	062712 	000200 			add	#binlsiz,@r2		; binary file types list lives here
     27	001432	011267 	000000G			mov	@r2	,totp.s		; send packet stats
     28	001436	062712 	000160 			add	#34*2*2	,@r2		; 28. double precision numbers here
     29	001442	011267 	000000G			mov	@r2	,totp.r		; receive packet stats
     30	001446	062712 	000160 			add	#34*2*2	,@r2		; 28. double precision numbers here
     31	001452	012703 	000003 			mov	#ln$cnt	,r3		; recall buffer count
     32	001456	012704 	000000G			mov	#lastli	,r4		; where to stuff the addresses
     33	001462	011224 			220$:	mov	@r2	,(r4)+		; command line editing
     34	001464	062712 	000122 			add	#ln$max+2,@r2		; move up
     35	001470					sob	r3	,220$		; keep going
	001470	005303 				dec	r3
	001472	001373 				bne	220$
     36	001474	011267 	000000G			mov	@r2	,cmdbuf		; insert command line buffer
     37	001500	062712 	000122 			add	#ln$max+2,@r2		; /63/ next
     38	001504	011267 	000000G			mov	@r2	,argbuf		; argument buffer
     39	001510	062712 	000122 			add	#ln$max+2,@r2		; /63/ next
     40
     41	001514	005020 			230$:	clr	(r0)+			; /62/ clear out now
     42	001516	020012 				cmp	r0	,@r2		; done?
     43	001520	101775 				blos	230$			; no
     44
     45	001522	010267 	000000G			mov	r2	,fetpt		; yes, setup pointers for .fetch now
     46	001526	017767 	000000G	000000G		mov	@hilimit,fetptmax	; max address for .fetching
     47	001534	005767 	000000G			tst	vbgexe			; /62/ is VBGEXE running this program?
     48	001540	001022 				bne	240$			; /62/ ya
     49	001542	005767 	000000G			tst	montyp			; if this is XM, then we must
     50	001546	003417 				ble	240$			; force handlers into lowcore
     51	001550	012767 	000000G	000000G		mov	#xmflow	,xmfetpt	; ensure APR0 fetching
     52	001556	062767 	000003 	000000G		add	#3	,xmfetpt	; ensure
     53	001564	042767 	000001 	000000G		bic	#1	,xmfetpt	; .even
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 11-1
Allocate and init buffers

     54	001572	012767 	000000G	000000G		mov	#xmfetpt,fetpt		; now insert address of pointer
     55	001600	012767 	000000G	000000G		mov	#xmftop	,fetptmax	; this is the top of XM .fetch space
     56	001606					.br	240$			; /63/
     57
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 12
Allocate and init buffers

      1
      2						.sbttl	Set/get terminal config..   ; /BBS/ moved here
      3
      4		050120 				TTMODE	= 20 ! 100 ! 10000 ! 40000  ; nosl ,nowait ,spec ,lc
      5		000424 				$TCFIG	= 424			; offset to addr of term config word
      6		100000 				$SCOPE	= 100000		; and its SET TT SCOPE bit
      7
      8	001606	052737 	050120 	000044 	240$:	bis	#ttmode	,@#jsw		; this pgm runs in single char mode
      9	001614					.rctrlo				; force read of new jsw..
	001614	104355 				EMT	^O355
     10	001616	013767 	000044 	000000G		mov	@#jsw	,ttparm		; save jsw
     11	001624	010667 	000000G			mov	sp	,remote		; /62/ assume remote mode
     12
     13	001630					.lookup	#rtwork,#lun.sr,#dkblk	; get physical name of os's DK
	001630	012700 	000000G			MOV	#rtwork,R0
	001634	012710 	000400G			MOV	#lun.sr+<1.*^O400>,@R0
	001640	012760 	000000G	000002 		MOV	#dkblk,2.(R0)
	001646	104375 				EMT	^O375
     14	001650	103436 				bcs	250$			; failed..
     15	001652					.cstat	#rtwork,#lun.sr,#cstat	; get device data
	001652	012700 	000000G			MOV	#rtwork,R0
	001656	012710 	013400G			MOV	#lun.sr+<23.*^O400>,@R0
	001662	012760 	000000G	000002 		MOV	#cstat,2.(R0)
	001670	104375 				EMT	^O375
     16	001672	103425 				bcs	250$			; failed..
     17	001674					calls	rdtoa	,<#dkname,cstat+12> ; device name
	001674	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001676	016746 	000012G			        mov	cstat+12	,-(sp)	; push it
	001702	012746 	000000G			        mov	#dkname	,-(sp)	; push it
	001706	010605 				  mov	sp	,r5		; set up the argument list pointer
	001710	004767 	000000G			  jsr	pc	,rdtoa		; and go to the routine
	001714	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	001716	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     18	001720	116700 	000010G			movb	cstat+10,r0		; get unit number
     19	001724	062700 	000060 			add	#'0	,r0		; convert to ascii
     20	001730	110067 	000002G			movb	r0	,dkname+2	; stuff unit number into name
     21	001734	112767 	000072 	000003G		movb	#':	,dkname+3	; tag it with a colon
     22	001742	105067 	000004G			clrb	dkname+4		; null terminate the string
     23	001746				250$:	.purge	#lun.sr			; dump the channel to the device
	001746	012700 	001400G			MOV	#lun.sr+<3.*^O400>,R0
	001752	104374 				EMT	^O374
     24	001754					strcpy	#defdir	,#dkname	; /62/ set default device name
	001754	012746 	000000G			mov	#dkname	,-(sp)
	001760	012746 	000000G			mov	#defdir	,-(sp)
	001764	004767 	000000G			jsr	pc	,strcpy
     25	001770	010667 	000000G			mov	sp	,tt$io		; /62/ init with I/O through TT
     26					;
     27					; ---	use tried-and-true method to detect TSX+
     28					;
     29	001774	012700 	000022'			mov	#tsxlin	,r0		; load TSX get line number emt arg
     30	002000	104375 				emt	375			; try to get it
     31	002002	103002 				bcc	260$			; /62/ got it
     32	002004	000167 	000424 			jmp	350$			; /62/ if failed it's not TSX
     33	002010	010067 	000000G		260$:	mov	r0	,tsxsav		; /BBS/ stash TSX line number here
     34
     35	002014	110067 	000016'			movb	r0	,tsxj.l		; /62/ copy to check line status
     36	002020	012700 	000014'			mov	#tsxjob	,r0		; /62/ point to argument block
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 12-1
Set/get terminal config..   ; /BBS/ moved here

     37	002024	104375 				emt	375			; /62/ inquire
     38	002026	103407 				bcs	270$			; /62/ something failed..
     39	002030	032767 	000002 	000000'		bit	#2	,chkbuf		; /62/ is this a detached job?
     40	002036	001403 				beq	270$			; /62/ no
     41	002040	012767 	177777 	000000G		mov	#-1	,jobtyp		; /62/ ya, flag it
     42
     43	002046	012700 	000024'		270$:	mov	#tsxon	,r0		; /BBS/ TSX nowait TT input mode
     44	002052	104375 				emt	375			; /BBS/ enable it
     45	002054	012700 	000032'			mov	#tsxsin	,r0		; /BBS/ TSX single char activation
     46	002060	104375 				emt	375			; /BBS/ enable this too..
     47
     48	002062					.gval	#rtwork	,#-4		; /BBS/ moved here, get TSX lead-in
	002062	012700 	000000G			MOV	#rtwork,R0
	002066	012710 	016000 			MOV	#28.*^O400+0.,@R0
	002072	012760 	177774 	000002 		MOV	#-4,2.(R0)
	002100	104375 				EMT	^O375
     49	002102	122700 	000035 			cmpb	#35	,r0		; is it the default?
     50	002106	001415 				beq	290$			; ya..
     51	002110	110067 	000000G			movb	r0	,m.tsxr		; no, set in
     52	002114	110067 	000000G			movb	r0	,m.tsxs		; place
     53
     54	002120	005001 				clr	r1			; /BBS/ start at first one
     55	002122	012702 	000013 			mov	#11.	,r2		; /BBS/ 11. of 'em to do
     56	002126	110061 	000000G		280$:	movb	r0	,limits(r1)	; /BBS/ load lead-in char into init $
     57	002132	062701 	000003 			add	#3	,r1		; /BBS/ bump to next one
     58	002136					sob	r2	,280$		; /BBS/ and go do it
	002136	005302 				dec	r2
	002140	001372 				bne	280$
     59
     60	002142				290$:	wrtall	#m.tsxs			; /BBS/ kill LF after CR under TSX
	002142	012746 	000000G			mov	#m.tsxs	,-(sp)		; pass the address
	002146	004767 	000000G			call	wrtall			; do it
     61	002152					.gval	#rtwork	,#ts.ver	; /BBS/ get TSX version
	002152	012700 	000000G			MOV	#rtwork,R0
	002156	012710 	016000 			MOV	#28.*^O400+0.,@R0
	002162	012760 	177740 	000002 		MOV	#ts.ver,2.(R0)
	002170	104375 				EMT	^O375
     62	002172	103402 				bcs	300$			; /BBS/ this doesn't work before V6.0
     63	002174	010067 	000000G			mov	r0	,tsxver		; /BBS/ save it
     64
     65	002200				300$:	.gval	#rtwork	,#curpri	; /BBS/ get current priority
	002200	012700 	000000G			MOV	#rtwork,R0
	002204	012710 	016000 			MOV	#28.*^O400+0.,@R0
	002210	012760 	177760 	000002 		MOV	#curpri,2.(R0)
	002216	104375 				EMT	^O375
     66	002220	010067 	000000G			mov	r0	,defpri		; /BBS/ save it
     67	002224	010067 	000000G			mov	r0	,cl.pri		; /BBS/ and init this
     68
     69	002230	012700 	000040'			mov	#tsxtrm	,r0		; now get terminal type
     70	002234	104375 				emt	375			; do it
     71	002236	103422 				bcs	320$			; oops
     72	002240	005001 				clr	r1			; map terminal type now
     73	002242	005201 			310$:	inc	r1			; next please
     74	002244	105761 	000051'			tstb	trmlst-1(r1)		; end of the list yet?
     75	002250	100415 				bmi	320$			; yes
     76	002252	120061 	000051'			cmpb	r0	,trmlst-1(r1)	; no, a match?
     77	002256	001371 				bne	310$			; no, keep looking
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 12-2
Set/get terminal config..   ; /BBS/ moved here

     78	002260	006301 				asl	r1			; /BBS/ word index here
     79	002262	016167 	000064'	000000G		mov	trmtyp-2(r1),vttype	; save internal code for TT type
     80	002270	026727 	000000G	000003 		cmp	vttype	,#vt200		; /BBS/ is it an 8-bit terminal?
     81	002276	001002 				bne	320$			; /BBS/ nope ..
     82	002300	010667 	000000G			mov	sp	,con8bit	; /BBS/ ya, do this for CONNECT
     83	002304	016700 	000000G		320$:	mov	tsxsav	,r0		; /BBS/ recover line number
     84	002310	005300 				dec	r0			; which line (1=console) is this?
     85	002312	001047 				bne	340$			; not console
     86	002314					.dstat	#rtwork	,#pi.r50	; console, see if this is a PRO
	002314	012700 	000044'			MOV	#pi.r50,R0
	002320	012746 	000000G			MOV	#rtwork,-(SP)
	002324	104342 				EMT	^O<342>
     87	002326	103441 				bcs	340$			; can't be
     88	002330	012701 	000112'			mov	#cl0text,r1		; for the strcpy
     89	002334	012700 	000000'			mov	#cl0asn	,r0		; try to assign
     90	002340	104375 				emt	375			; line 3 to CL0
     91	002342	103006 				bcc	330$			; success
     92	002344	012701 	000117'			mov	#cl1text,r1		; for the strcpy
     93	002350	012700 	000006'			mov	#cl1asn	,r0		; CL0 is busy,
     94	002354	104375 				emt	375			; try CL1
     95	002356	103425 				bcs	340$			; CL0 and CL1 are busy (unlikely)
     96	002360				330$:	calls	assdev	,<r1>		; /BBS/ assign the device
	002360	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002362	010146 				  mov	r1	,-(sp)		; doing it thusly generates less code
	002364	010605 				  mov	sp	,r5		; set pointer to argument list
	002366	004767 	000000G			  jsr	pc	,assdev		; call the subroutine
	002372	005726 				  tst	(sp)+			; pop parameter list from stack
	002374	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     97	002376	005700 				tst	r0			; /BBS/ ok?
     98	002400	001014 				bne	340$			; /BBS/ no
     99	002402	005067 	000000G			clr	remote			; say we are a local Kermit
    100	002406					strcpy	#ttname	,r1		; copy the CL name
	002406	010146 				mov	r1	,-(sp)
	002410	012746 	000000G			mov	#ttname	,-(sp)
	002414	004767 	000000G			jsr	pc	,strcpy
    101	002420	012767 	000003 	000000G		mov	#3	,cl$line	; /BBS/ save line # for defterm
    102	002426	010667 	000000G			mov	sp	,z.atch		; /BBS/ flag assign done by Kermit
    103	002432	000207 			340$:	return				; /62/
    104
    105	002434				350$:	.gval	#rtwork	,#$tcfig	; get term config word address
	002434	012700 	000000G			MOV	#rtwork,R0
	002440	012710 	016000 			MOV	#28.*^O400+0.,@R0
	002444	012760 	000424 	000002 		MOV	#$tcfig,2.(R0)
	002452	104375 				EMT	^O375
    106	002454	026727 	000000G	000005 		cmp	rt11ver	,#5		; /62/ is this RT-11 V5 or above?
    107	002462	002005 				bge	360$			; /62/ ya, .peek will work
    108	002464	005767 	000000G			tst	montyp			; /62/ if XM and V4..
    109	002470	003022 				bgt	380$			; /62/ ..tough luck
    110	002472	011000 				mov	(r0)	,r0		; /62/ otherwise, this is it
    111	002474	000410 				br	370$
    112	002476	010001 			360$:	mov	r0	,r1		; save copy for peek
    113					; /62/	.peek	#rtwork	,r1		; got to do it this way for XM!
    114	002500	012700 	000000G			MOV	#rtwork	,R0		; /62/ expanded for assy under V4
    115	002504	012710 	016001 			MOV	#28.*^o400+1.,@R0	; /62/ even though V4 can't run it
    116	002510	010160 	000002 			MOV	r1	,2.(R0)		; /62/
    117	002514	104375 				EMT	^o375			; /62/
    118	002516	010067 	000000G		370$:	mov	r0	,ttpar2		; save it
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 12-3
Set/get terminal config..   ; /BBS/ moved here

    119	002522	032700 	100000 			bit	#$scope	,r0		; hard copy terminal?
    120	002526	001403 				beq	380$			; ya
    121	002530	012767 	000002 	000000G		mov	#vt100	,vttype		; no, make it a VT-100
    122	002536	012767 	000004 	000000G	380$:	mov	#par$space,parity	; /BBS/ force 8-bit quoting for RT-11
    123	002544					.dstat	#rtwork	,#xc.r50	; /39/ check for KM, XC or XL
	002544	012700 	000046'			MOV	#xc.r50,R0
	002550	012746 	000000G			MOV	#rtwork,-(SP)
	002554	104342 				EMT	^O<342>
    124	002556	103030 				bcc	390$			; /39/ found it
    125	002560					.dstat	#rtwork	,#xl.r50	; /39/ no XC, try XL
	002560	012700 	000050'			MOV	#xl.r50,R0
	002564	012746 	000000G			MOV	#rtwork,-(SP)
	002570	104342 				EMT	^O<342>
    126	002572	103022 				bcc	390$			; /39/ found it
    127	002574					.dstat	#rtwork	,#km.r50	; /62/ no XL, try KM
	002574	012700 	000042'			MOV	#km.r50,R0
	002600	012746 	000000G			MOV	#rtwork,-(SP)
	002604	104342 				EMT	^O<342>
    128	002606	103014 				bcc	390$			; /62/ found it
    129	002610					wrtall	#noxcmt			; /39/ No, warn user of such fact
	002610	012746 	000137'			mov	#noxcmt	,-(sp)		; pass the address
	002614	004767 	000000G			call	wrtall			; do it
    130	002620	012767 	000074 	000000G		mov	#60.	,senlen		; /62/ console port won't XOFF fast
    131	002626	112767 	000074 	000000G		movb	#60.	,senpar+p.spsiz	; /62/ enough, do receive size too
    132	002634	005067 	000000G			clr	dolong			; /BBS/ can't do long packets now..
    133
    134	002640	005767 	000000G		390$:	tst	jobsts			; /54/ FRUNed?
    135	002644	001407 				beq	400$			; /54/ no
    136	002646	005067 	000000G			clr	blip			; /54/ yes, no packet status display
    137	002652					wrtall	#nolog			; /54/ inform
	002652	012746 	000372'			mov	#nolog	,-(sp)		; pass the address
	002656	004767 	000000G			call	wrtall			; do it
    138	002662	000416 				br	410$			; /BBS/ can't fetch from foreground
    139
    140	002664	005767 	000000G		400$:	tst	vbgexe			; /62/ any hope getting a good number?
    141	002670	001013 				bne	410$			; /62/ not if VBGEXE runs the program
    142	002672	016746 	000000G			mov	fetptmax,-(sp)		; /BBS/ this is top of memory, which
    143	002676	167716 	000000G			sub	@fetpt	,@sp		; /BBS/ minus top of program + buffers
    144	002702	012600 				mov	(sp)+	,r0		; /BBS/ = what's left for handlers
    145	002704	004767 	176352 			call	plural			; /BBS/ display it
    146	002710					wrtall	#osi.15			; /63/ " free to load hand.."<cr><lf>
	002710	012746 	001343'			mov	#osi.15	,-(sp)		; pass the address
	002714	004767 	000000G			call	wrtall			; do it
    147	002720	000207 			410$:	return
    148
    149		000001 				.end
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 12-4
Symbol table

ALBUFF= ****** GX	DECNAT  000002   	MONTYP= ****** GX	RS.CRR  100000   	TTNAME= ****** GX
ALLOC = 010200 G 	DEFDIR= ****** GX	M.TSXR= ****** GX	RS.EGR  000400   	TTPARM= ****** GX
ALSIZE= 001000   	DEFPRI= ****** GX	M.TSXS= ****** GX	RS.EXI  000200   	TTPAR2= ****** GX
APR7RE  000000R     004	DEL   = 000177   	NOLOG   000372R     003	RS.GBL  004000   	TTY   = 000001
APR7WI  000014R     004	DIRBFR= ****** GX	NONEIS= 000001   	RS.NAL  020000   	TT$IO = ****** GX
ARGBUF= ****** GX	DIRNAM= ****** GX	NOSCOP= 000000   	RS.NEW  010000   	USERRB= 000053
ASSDEV= ****** GX	DKBLK = ****** GX	NOXCMT  000137R     003	RS.NSM  000020   	VBGEXE= ****** GX
AT.ALL  000177   	DKNAME= ****** GX	NRTQUE= ****** GX	RS.UNM  040000   	VRUN$ = 020000
AT.CDT  000001   	DOLONG= ****** GX	OSI.01  000537R     003	RTQUE = ****** GX	VTTYPE= ****** GX
AT.INF  000002   	DOT   = 000056   	OSI.02  000616R     003	RTWORK= ****** GX	VT100 = 000002
AT.LEN  000004   	EIS$  = 000400   	OSI.03  000657R     003	RT11UP= ****** GX	VT200 = 000003
AT.ON   100000   	ERBFSI= 000170   	OSI.04  000745R     003	RT11VE= ****** GX	WARN$ = 000002
AT.PRO  000010   	ERRBYT= 000052   	OSI.05  001012R     003	R.GBAS  000012   	WRTALL= ****** GX
AT.SYS  000020   	ERROR$= 000004   	OSI.06  001024R     003	R.GID   000000   	WS.CRW  100000
AT.TYP  000040   	ESC   = 000033   	OSI.07  001046R     003	R.GLGH  000014   	WS.ELW  020000
AT.XLE  000100   	FATAL   000124R     003	OSI.08  001144R     003	R.GNAM  000006   	WS.MAP  000400
A200$   001320R     002	FATAL$= 000020   	OSI.09  001171R     003	R.GSIZ  000002   	WS.UNM  040000
BELL  = 000007   	FETPT = ****** GX	OSI.10  001256R     003	R.GSTS  000004   	W.NAPR  000001
BINARY  000001   	FETPTM= ****** GX	OSI.11  001273R     003	SCOLON= 000073   	W.NBAS  000002
BINLSI= 000200   	FF    = 000014   	OSI.12  001306R     003	SENLEN= ****** GX	W.NID   000000
BINTYP= ****** GX	FREEPT= ****** GX	OSI.13  001332R     003	SENPAR= ****** GX	W.NLEN  000012
BLIP  = ****** GX	HERTZ5= 000040   	OSI.14  001341R     003	SEVER$= 000010   	W.NLGH  000016
BREAK = ****** GX	HILIMI= ****** GX	OSI.15  001343R     003	SJSYS = 000001   	W.NOFF  000010
BS    = 000010   	IFACTV= 000400   	PARITY= ****** GX	SOH   = 000001   	W.NRID  000006
BUFLST= ****** GX	IMGTYP= ****** GX	PAR$EV  000002   	SPACE = 000040   	W.NSIZ  000004
CAPA.A= 000010   	JOBSTS= ****** GX	PAR$MA  000003   	STATWD= 000366   	W.NSTS  000014
CAPA.L= 000002   	JOBTYP= ****** GX	PAR$NO  000000   	STRCPY= ****** GX	XC.R50  000046R     003
CAPA.S= 000004   	JSW   = 000044   	PAR$OD  000001   	SUCCS$= 000001   	XINIT   000000RG    002
CHKBUF  000000R     005	KM.R50  000042R     003	PAR$SP  000004   	SYSGEN= 000372   	XKLGBU= ****** GX
CLKFLG= ****** GX	KRTINC= 000001   	PHNUM = ****** GX	SYSVER= 000276   	XL.R50  000050R     003
CL$LIN= ****** GX	LASTLI= ****** GX	PI.R50  000044R     003	TAB   = 000011   	XMFETP= ****** GX
CL.PRI= ****** GX	LF    = 000012   	PLURAL  001262R     002	TERMIN  177777   	XMFLOW= ****** GX
CL0ASN  000000R     003	LIMITS= ****** GX	P.CAPA= 000011   	TEXT    000000   	XMFTOP= ****** GX
CL0TEX  000112R     003	LN$CNT= 000003   	P.CHKT= 000007   	TILDE = 000176   	XMSYS = 010000
CL1ASN  000006R     003	LN$MAX= 000120   	P.EOL = 000004   	TIMBUF  000004R     005	XOFF  = 000023
CL1TEX  000117R     003	LOG$AL= 000003   	P.MXL1= 000013   	TOPMEM= 000050   	XON   = 000021
CMDBUF= ****** GX	LOG$CO= 000002   	P.MXL2= 000014   	TOTALL= 010150 G 	Z.ATCH= ****** GX
CNTXT = 000320   	LOG$DE= 000020   	P.NPAD= 000002   	TOTP.R= ****** GX	$ALLSI= 001144
COMMA = 000054   	LOG$IO= 000010   	P.PADC= 000003   	TOTP.S= ****** GX	$LIMIT= ****** GX
CONFG2= 000370   	LOG$ON= 040000   	P.QBIN= 000006   	TRMLST  000052R     003	$SCOPE= 100000
CONFIG= 000300   	LOG$OP= 100000   	P.QCTL= 000005   	TRMTYP  000066R     003	$TCFIG= 000424
CON$ES= 000034   	LOG$PA= 000001   	P.REPT= 000010   	TSXJOB  000014R     003	$$    = 000001
CON8BI= ****** GX	LOG$RP= 000004   	P.SPSI= 000000   	TSXJ.L  000016R     003	$$BUFP= 004010
CR    = 000015   	LUN.SR= ****** GX	P.TIME= 000001   	TSXLIN  000022R     003	$$1   = 000001
CSTAT = ****** GX	L$PCRL= ****** GX	P.VEND= 000017   	TSXMEM  000010R     005	$$2   = 000000
CTRL$N= 000016   	L$WROC= ****** GX	P.WIND= 000012   	TSXON   000024R     003	$$5   = 000001
CTRL$O= 000017   	L10266= ****** GX	QEDTST= ****** GX	TSXSAV= ****** GX	$.1   = 000402
CURPRI= 177760   	MAPWRK  000032R     004	RDTOA = ****** GX	TSXSIN  000032R     003	$.2   = 000340
C.CRLF= 000004   	MARKTI= 002000   	REMOTE= ****** GX	TSXTRM  000040R     003	$.3   = 000244
C.LCUC= 000040   	MAXLNG= 001130   	RS.AGE  001000   	TSXVER= ****** GX	$.4   = 000366
C.LSPA= 000010   	MAXPAK  000136   	RS.BAS  000040   	TS.VER= 177740   	...V1 = 000003
C.SSPA= 000020   	MAXSIZ= 001000 G 	RS.CAC  000100   	TTMODE= 050120   	...V2 = 000027
C.TSPA= 000200   	MAXTOP= ****** GX	RS.CGR  002000

. ABS.	000000    000	(RW,I,GBL,ABS,OVR)
      	000000    001	(RW,I,LCL,REL,CON)
$CODE 	002722    002	(RO,I,LCL,REL,CON)
KRTOSI	One shot init	MACRO V05.03b  00:01  Page 12-5
Symbol table

$PDATA	001374    003	(RO,D,LCL,REL,CON)
MAPWIN	000036    004	(RW,D,GBL,REL,CON)
$RWDAT	000014    005	(RW,D,LCL,REL,CON)
Errors detected:  0

*** Assembler statistics


Work  file  reads: 49
Work  file writes: 53
Size of work file: 14528 Words  ( 57 Pages)
Size of core pool: 12544 Words  ( 49 Pages)
Operating  system: RT-11

Elapsed time: 00:00:00.24
KRTOSI,KRTOSI=KRTNHD,KRTOSI
