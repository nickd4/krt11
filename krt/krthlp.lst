.MAIN.	MACRO V05.03b  00:01
Table of contents

    1-   1	KRTNHD	EIS macros for a non-EIS CPU
    5-   1	KRTMAC	Various handy constants and macros
    7-   2	Utility macros
    9-   2	Local data
   10-   3	BUG, HPRINT
   11-   2	HELP main_loop
   12-   2	Parse command line
   13-   2	Find the topic in the help file
   14-   2	Print help text found by HFIND
   15-   2	Preset an I/O channel to an exact block and offset ; /BBS/
   16-   2	Print index
   17-   2	Open the help file
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 1
KRTNHD	EIS macros for a non-EIS CPU

      1						.sbttl	KRTNHD	EIS macros for a non-EIS CPU
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					; /62/	27-Jul-93  Billy Youdelman  V03.62
      6					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
      7					;
      8					;	Assemble Kermit-11 modules with this for use on a
      9					;	non-EIS CPU.  This calls p$mul and p$div, assembly
     10					;	of which into KRTSUB depends on defining "NONEIS".
     11					;	KRTASM.NON assembles everything for non-EIS use.
     12
     13					;	10-Apr-84  09:37:15  Brian Nelson
     14
     15		000001 				NONEIS	=	1		; force p$mul,p$div into KRTSUB.MAC
     16
     17						.macro	mul	src,reg		; single precision
     18						.ntype	$$	,reg		; save number of input register
     19						mov	src	,-(sp)		; pass multiplier to p$mul
     20						mov	reg	,-(sp)		; pass multiplicand too
     21						call	p$mul			; multiply, returns a 16-bit product
     22						.iif eq <$$-1>	mov	(sp)+	,r1	; ..if input register was r1
     23						.iif eq <$$-3>	mov	(sp)+	,r3	; ditto if r3
     24						.iif eq <$$-5>	mov	(sp)+	,r5	; ditto if r5
     25						.iif ne <<$$+1>&1> .error      <; bad dst reg for MUL macro>
     26						.endm	mul
     27
     28						.macro	div	src,reg		; /BBS/ made this double precision
     29						.ntype	$$	,reg		; # of register with dividend hi word
     30						mov	src	,-(sp)		; divisor
     31						.if eq $$			; hi word is in r0
     32						mov	r1	,-(sp)		; dividend low word
     33						mov	r0	,-(sp)		; dividend high word
     34						.endc
     35						.if eq $$-2			; hi word is in r2
     36						mov	r3	,-(sp)
     37						mov	r2	,-(sp)
     38						.endc
     39						.if eq $$-4			; hi word is in r4
     40						mov	r5	,-(sp)
     41						mov	r4	,-(sp)
     42						.endc
     43						call	p$div			; divide
     44						.if eq $$			; using r0..
     45						mov	(sp)+	,r1		; remainder
     46						mov	(sp)+	,r0		; this only returns a 16-bit quotient
     47						.endc
     48						.if eq $$-2			; using r2..
     49						mov	(sp)+	,r3
     50						mov	(sp)+	,r2
     51						.endc
     52						.if eq $$-4			; using r4..
     53						mov	(sp)+	,r5
     54						mov	(sp)+	,r4
     55						.endc
     56						.endm	div
     57
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 1-1
KRTNHD	EIS macros for a non-EIS CPU

     58						.macro	sob	reg,dst		; subtract one and branch if not zero
     59						dec	reg
     60						bne	dst
     61						.endm	sob
     62
     63						.macro	ash	amount,reg	; arithmetic shift
     64						.ntype	$$$0	,amount
     65						.iif ne <27-$$$0> .error       <; must be auto pc for ASH macro>
     66						$$type	= 1			; assume left shift
     67						$$size	= 0			; how many ASLs or ASRs to generate
     68						  .irpc	$a ,<amount>		; parse the first argument
     69						  $c	= ''$a			; get the character as a literal
     70						  .iif eq <$c - '-> $$type = -1	; if a minus sign then assume right
     71						  .iif eq <$c - '.> .error     <; only use octal in ASH macro please>
     72						  .iif eq <$c - '^> .error     <; only use octal in ASH macro please>
     73						  $c	= $c - '0		; check for a digit now
     74						    .if ge $c			; perhaps a digit
     75						      .if le $c-7		; got a digit
     76						      $$size = <$$size*10>+$c	; add into accumulator
     77						      .endc
     78						    .endc
     79						  .endr
     80						.rept	$$size
     81						.iif gt <$$type>  asl	reg
     82						.iif lt <$$type>  asr	reg
     83						.endr
     84						.endm
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 2
KRTNHD	EIS macros for a non-EIS CPU

      1						.title  KRTHLP	HELP for Kermit-11
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	translate "_" to "-" which searching for topics
      7					;	move index data to separate file KRTIDX.MAC solving a size problem
      8					;	increase text line and terminal input buffers to 132. bytes
      9
     10					; /62/	27-Jul-93  Billy Youdelman  V03.62
     11					;
     12					;	add dummy file name for HPRINT via RT-11 V5.2/TSX V6.0 LP/LS
     13					;	display all subtopic text when wildcarding through nested text
     14
     15					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     16					;
     17					;	kill extra LF after listing subtopics
     18					;	hfind - fixed wildcarding when no subtopics exist for a topic
     19					;	help text file updated to reflect mods/additions/omissions
     20					;	hindex - display sped up, prompting after it now uses full text,
     21					;	also handles topic names greater than 18 bytes ala VMS help
     22					;	added fake RMS stuff for RT-11/TSX, and did a general cleanup..
     23					;	path for KRTHLP.HLP is now HLP, KRT, SY and DK
     24					;	modified to check for correct copy of KRTHLP.HLP
     25					;	on topic error nest in as far as possible instead of from the top
     26					;	added HPRINT, dumps help text to LP
     27
     28					;	Copyright 1986 Brian Nelson
     29					;
     30					;	26-Mar-86  18:41:25
     31					;
     32					;	This is a complete rewrite of Kermit-11's help.  It is a bit more
     33					;	intelligent, in that it understands wildcarding (HELP SET *), and
     34					;	can build subtopic prompting strings and process accordingly.
     35
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 3
KRTNHD	EIS macros for a non-EIS CPU

      1
      2					;	   Directions for rebuilding the RMS Index for KRTHLP.HLP
      3					;
      4					;	If the help text file must be edited, added to or changed, one
      5					;	must then rebuild the index data table located in KRTIDX.MAC.
      6					;	Doing this is quite easy - simply run KRTIDX.BAS which will
      7					;	create a new KRTIDX.MAC for you.
      8					;
      9					;	KRTHLP.HLP help text file format info:
     10					;
     11					;	The very first line contains an ident string with which this program
     12					;	can verify it has the correct file, as otherwise with the internal
     13					;	indexing in use here it may seem to be broken for no apparent reason.
     14					;	This ident string contains the program version and last edit date:
     15					;
     16					;	V03.63 27-Sep-97		(or whatever it may later become..)
     17					;
     18					;	Topic/subtopic lines must begin with a single ascii digit (ie: "1")
     19					;	representing the nesting level in the first column, followed by a
     20					;	space (ascii 40), followed by the topic/subtopic name.  The text
     21					;	following is preceded by a blank (CR/LF only) line.  Each line of
     22					;	the text must include a space (or lower value char, such as a tab
     23					;	or return) in column one, which is used to distinguish text from
     24					;	topics.  The text is followed by another blank line, just prior to
     25					;	the next topic or subtopic line.  Wildcarded nesting is currently
     26					;	supported through 5 levels, topic text length is 63. bytes and
     27					;	aggregate (topic/subtopics) length must be 127. or less bytes.
     28					;	The maximun length of a line of help text is 132. bytes, although
     29					;	it's best to stay within 80 columns if at all possible.
     30
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 4
KRTNHD	EIS macros for a non-EIS CPU

      1
      2						.include "IN:KRTMAC.MAC"
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 5
KRTMAC	Various handy constants and macros

      1						.sbttl	KRTMAC	Various handy constants and macros
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	add support for SET ATTRIBUTES
      7					;	add flag to suspend logging to a disk file
      8					;	make $LN$MAX 132. bytes for EIS assembly
      9					;	pulled message macro, no longer used..
     10
     11					; /62/	27-Jul-93  Billy Youdelman  V03.62
     12					;
     13					;	move dispatch macro to KRTSER
     14					;	move erbfsiz here from KRTPAK
     15					;	condense logging (debug) modes
     16					;	increase efficiency of incm64 macro
     17					;	increase MAXLNG (long-packet size) to 1920.
     18					;	reduce MAXLNG to 600. for NONEIS assembly, so pgm loads under FB..
     19					;	ditto for ALSIZE (phone # buffer) and LN$CNT (SL # of lines saved)
     20
     21					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     22					;
     23					;	modified message macro to call .newline instead of saving CR/LF
     24					;	and null for each new line, knocking 1042. bytes off the size
     25					;	of this version..  also changed ".print" emulation to wrtall,
     26					;	for a similar savings in compiled program size.
     27					;
     28					;	dump raw I/O logging from log$al (SET DEB ALL) - too confusing
     29					;	also pulled log$rp out and made it a completely separate item..
     30					;
     31					;	added a couple upper case macros
     32
     33					;	include file for Kermit-11
     34					;
     35					;	Brian Nelson  01-Dec-83  13:56:12
     36
     37						.NLIST	BEX
     38						.LIST	MEB			; /62/
     39
     40		000001 				KRTINC	=	1		; for .include error checking
     41
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 6
KRTMAC	Various handy constants and macros

      1
      2	000000					.psect	$code	,ro,i,lcl,rel,con ; psect ordering..
      3	000000					.psect	$pdata	,ro,d,lcl,rel,con
      4
      5					;	various ascii chars
      6		000001 				SOH	=   1		; default packet start of header
      7		000007 				BELL	=   7		; beep
      8		000010 				BS	=  10		; backspace
      9		000011 				TAB	=  11		; tab
     10		000012 				LF	=  12		; line feed
     11		000014 				FF	=  14		; form feed
     12		000015 				CR	=  15		; carriage return
     13		000016 				CTRL$N	=  16		; ^N VT-100 line drawing on
     14		000017 				CTRL$O	=  17		; ^O VT-100 line drawing off
     15		000021 				XON	=  'Q&37	; ^Q
     16		000023 				XOFF	=  'S&37	; ^S
     17		000033 				ESC	=  33		; escape
     18		000040 				SPACE	=  40
     19		000054 				COMMA	=  54
     20		000056 				DOT	=  56		; /63/
     21		000073 				SCOLON	=  73		; /63/
     22		000176 				TILDE	= 176		; /63/
     23		000177 				DEL	= 177		; delete
     24
     25					;	system data locations
     26		000044 				JSW	= 44		; job status word
     27		000052 				ERRBYT	= 52		; emt error byte
     28		000053 				USERRB	= 53		; /62/ user error byte
     29		000001 					SUCCS$	=  1	; no error
     30		000002 					WARN$	=  2	; warning
     31		000004 					ERROR$	=  4	; error
     32		000010 					SEVER$	= 10	; sever error
     33		000020 					FATAL$	= 20	; fatal error
     34
     35					;	byte offsets into SINIT parameter vector
     36		000000 				P.SPSIZ	= 0		; set packet length
     37		000001 				P.TIME	= 1		; time-out
     38		000002 				P.NPAD	= 2		; number of pad chars
     39		000003 				P.PADC	= 3		; the pad character
     40		000004 				P.EOL	= 4		; eol char
     41		000005 				P.QCTL	= 5		; control char quoting
     42		000006 				P.QBIN	= 6		; 8-bit quote
     43		000007 				P.CHKT	= 7		; checksum type
     44		000010 				P.REPT	= 10		; repeated character prefix
     45		000011 				P.CAPAS	= 11		; capability bitmask
     46		000010 					CAPA.A	= 10	; attribute handling
     47		000002 					CAPA.L	= 2	; /42/ long packets
     48		000004 					CAPA.S	= 4	; /42/ sliding windows
     49		000012 				P.WINDS	= 12		; /43/ window size, # of packets
     50		000013 				P.MXL1	= 13		; /43/ high order of long packet size
     51		000014 				P.MXL2	= 14		; /43/ low order of long packet size
     52		000017 				P.VEND	= 17		; end of parameter vector
     53
     54					; /62/	bits in doattr (file attribute processing)
     55		000001 				AT.CDT	=: 1		; create date
     56		000002 				AT.INF	=: 2		; /63/ system specific info
     57		000004 				AT.LEN	=: 4		; length
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 6-1
KRTMAC	Various handy constants and macros

     58		000010 				AT.PRO	=: 10		; file protection
     59		000020 				AT.SYS	=: 20		; system ID
     60		000040 				AT.TYP	=: 40		; file type
     61		000100 				AT.XLE	=: 100		; exact length in bytes
     62		100000 				AT.ON	=: 100000	; /63/ do attribute processing
     63		000177 				AT.ALL	=: AT.CDT!AT.INF!AT.LEN!AT.PRO!AT.SYS!AT.TYP!AT.XLE
     64
     65					;	bits in trace (debug status word)
     66		000001 				LOG$PA	= 1		; log all packets
     67		000002 				LOG$CO	= 2		; /62/ CONNECT logging to disk
     68		000004 				LOG$RP	= 4		; /62/ rpack chars to TT
     69		000010 				LOG$IO	= 10		; /62/ everything received or sent
     70		000020 				LOG$DE	= 20		; /62/ debugging to TT
     71		040000 				LOG$ON	= 40000		; /63/ set to write to disk, clear to suspend
     72		100000 				LOG$OP	= 100000	; logfile is open
     73		000003 				LOG$AL	= LOG$PA!LOG$CO	; /62/ ALL
     74
     75					;	parity options
     76		000000 				PAR$NO	=: 0		; none
     77		000001 				PAR$OD	=: 1		; odd
     78		000002 				PAR$EV	=: 2		; even
     79		000003 				PAR$MA	=: 3		; mark
     80		000004 				PAR$SP	=: 4		; space
     81
     82					;	file types
     83		177777 				TERMINAL=: -1		; file to term ala xreply, not to disk
     84		000000 				TEXT	=:  0		; normal ascii text files
     85		000001 				BINARY	=:  1		; image mode
     86		000002 				DECNAT	=:  2		; /52/ 8-bit text files
     87
     88					;	terminal types
     89		000000 				NOSCOPE	= 0		; /BBS/ hard copy terminal
     90		000001 				TTY	= 1		; a dumb tube terminal
     91		000002 				VT100	= 2		; itself
     92		000003 				VT200	= 3		; ditto..
     93
     94					;	supported CVT$$ cvt_bit_pattern bits
     95		000004 				C.CRLF	= 4		; discard CR LF FF ESC
     96		000010 				C.LSPA	= 10		; discard leading spaces and tabs
     97		000020 				C.SSPA	= 20		; reduce spaces and tabs to a single space
     98		000040 				C.LCUC	= 40		; lower case to upper case
     99		000200 				C.TSPA	= 200		; discard trailing spaces and tabs
    100
    101		000034 				CON$ESC	=  '\-100	; default CONNECT escape char
    102		000170 				ERBFSIZ	=  120.		; /62/ error msg text buff size
    103		000136 				MAXPAK	=:  94.		; /63/ max_packet_length - max_checksum_length
    104
    105						.if df	NONEIS		; /62/ using NONEIS for convenience..
    106		001000 				ALSIZE	=   1000	; /63/ bufsiz for SET DIAL/PHO NUM
    107		000003 				LN$CNT	=      3.	; /62/ save/recall 3. commands
    108		000120 				LN$MAX	=     80.	; /63/ max command line length
    109		001130 				MAXLNG	=    600.	; /63/ so image is small enuff to run
    110						.iff
    111						ALSIZE	=   2000	; /62/ bufsiz for SET DIAL/PHO NUM
    112						LN$CNT	=     10.	; /63/ save/recall 10. commands
    113						LN$MAX	=    132.	; /63/ max command line length
    114						MAXLNG	=   1920.	; /63/ use max long-packet buff size
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 6-2
KRTMAC	Various handy constants and macros

    115						.endc
    116		001144 				$ALLSIZ	= <MAXLNG+14>&177776 ; /62/ make it this for safety
    117
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 7
KRTMAC	Various handy constants and macros

      1
      2						.sbttl	Utility macros
      3
      4						.macro	.br to		; /63/ added
      5						.if df	to
      6						.if ne	to-.
      7						.error	<; not at location to;>
      8						.endc
      9						.endc
     10						.endm	.br
     11
     12						.macro	.chksp	arg
     13						.ntype	$$5	,arg
     14						.iif eq <<$$5&7>-6> .error arg <; Illegal use of SP (r6) in call>
     15						.endm	.chksp
     16
     17						.macro	calls	name	,arglst
     18					;	subroutine call with arguments passed in an area pointed to by r5
     19					;	(as with F4 and BP2).  all args are pushed onto the stack in the
     20					;	order specified.  r5 points to the sp before the call and is saved
     21					;	and restored.
     22						$$ = 0				; init # of args count
     23						  .irp x ,<arglst>		; count up # of args passed
     24						  $$ = $$+1			; one at a time
     25						  .endr				; got it
     26						.if eq $$			; no args present?
     27						jsr	pc	,name		; if so, substitute a simple call
     28						.iff				; at least one arg in <arglst>
     29						mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
     30						  .if eq $$-1			; is it one or more than one arg?
     31						  .chksp	arglst		; one arg, check for legal SP modes
     32						  mov	arglst	,-(sp)		; doing it thusly generates less code
     33						  mov	sp	,r5		; set pointer to argument list
     34						  jsr	pc	,name		; call the subroutine
     35						  tst	(sp)+			; pop parameter list from stack
     36						  mov	(sp)+	,r5		; /63/ restore r5
     37						  .iff				; arg_count > 1
     38						  $$2 = $$			; extract the args in
     39						    .rept	$$		; reverse order so that
     40						    $$1 = 0			; we might save a little
     41						      .irp x ,<arglst>		; core (four words)
     42						      $$1 = $$1+1		; scan the arg list until we come to
     43						        .if eq $$2-$$1		; the last one before one we just did
     44						        .chksp	x		; check for SP addressing mode
     45						        mov	x	,-(sp)	; push it
     46						        .mexit			; and exit the .irp
     47						        .endc
     48						      .endr
     49						    $$2 = $$2-1			; backwards to previous arg
     50						    .endr
     51						  mov	sp	,r5		; set up the argument list pointer
     52						  jsr	pc	,name		; and go to the routine
     53						  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
     54						  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
     55						  mov	(sp)+	,r5		; /63/ restore r5
     56						  .endc
     57						.endc
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 7-1
Utility macros

     58						.endm	calls
     59
     60						.macro	ctl	src ,dst
     61						clr	-(sp)
     62						bisb	src	,@sp
     63						call	l$xor
     64						movb	(sp)+	,dst
     65						.endm	ctl
     66
     67						.macro	copyz	from ,to ,maxlen
     68						.if  b	<maxlen>
     69						clr	-(sp)
     70						.iff
     71						mov	maxlen	,-(sp)
     72						.endc
     73						mov	from	,-(sp)
     74						mov	to	,-(sp)
     75						call	copyz$
     76						.endm	copyz
     77
     78						.macro	deccvt	val ,buf ,width
     79						mov	r5	,-(sp)
     80						.if  b	<width>
     81						clr	-(sp)
     82						.iff
     83						mov	width	,-(sp)
     84						.endc
     85						mov	val	,-(sp)
     86						mov	buf	,-(sp)
     87						mov	sp	,r5
     88						call	l$cvtnum
     89						add	#6	,sp
     90						mov	(sp)+	,r5
     91						.endm	deccvt
     92
     93						.macro	decout	val
     94						mov	r5	,-(sp)
     95						mov	val	,-(sp)		; /62/ l$wrdec pops this buffer
     96						mov	sp	,r5
     97						call	l$wrdec
     98						mov	(sp)+	,r5
     99						.endm	decout
    100
    101						.macro	direrr	val
    102						mov	val	,-(sp)
    103						call	direr$
    104						.endm	direrr
    105
    106						.macro	incm64	val
    107						inc	val
    108						bic	#^c<77>	,val		; /62/ faster
    109						.endm	incm64
    110
    111						.macro	indexm	reg		; check for auto increment/decrement
    112						.ntype	$$$0	,reg		; modes for macros that can't have..
    113						.if  ne	$$$0-27			; always allow pc autoincrement
    114						$$$0 =	<$$$0&177770>/10	; ..these modes in their arg list
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 7-2
Utility macros

    115						.ift				; get the mode into 0..7
    116						  .if  ge $$$0-2		; if mode >=2 and mode <=5 then error
    117						  .iif ge <5-$$$0> .error      <; Can't use auto inc/dec mode here>
    118						  .endc
    119						.endc
    120						.endm	indexm
    121
    122						.macro	ixor	reg ,dst
    123					;	get around the mode restrictions for the hardware XOR instruction
    124					;	and fix for RT-11 systems that don't have the EIS chip option
    125						.chksp	reg			; can't allow sp args
    126						.chksp	dst			; in either register
    127						indexm	reg			; check for allowed
    128						indexm	dst			; addressing mode
    129						mov	reg	,-(sp)		; it's much simpler to do this
    130						bic	dst	,@sp		; for all RT-11 systems rather
    131						bic	reg	,dst		; than to be selective
    132						bis	(sp)+	,dst		; done
    133						.endm	ixor
    134
    135						.macro	.newline		; print CR/LF on TT
    136						call	l$pcrlf
    137						.endm	.newline
    138
    139						.macro	octout	val
    140						calls	l$wroct	,<val>
    141						.endm	octout
    142
    143						.macro	prsbuf	dst
    144						mov	dst	,r0
    145						call	prsarg
    146						.endm	prsbuf
    147
    148						.macro	rpack	len.a ,pakn.a ,msg.a ,max.len	; /62/
    149						sub	#10	,sp
    150						mov	sp	,r1
    151						calls	rpack$	,<msg.a,r1,max.len>
    152						mov	(r1)+	,len.a
    153						mov	(r1)+	,pakn.a
    154						mov	@r1	,r1
    155						add	#10	,sp
    156						.endm	rpack
    157
    158						.macro	save	list
    159						.if  b	<list>
    160						 save	<r0,r1,r2,r3,r4,r5>
    161						.iff
    162						.irp	x ,<list>
    163						 mov	x	,-(sp)
    164						.endr
    165						.endc
    166						.endm	save
    167
    168						.macro	scan	ch ,str
    169						mov	str	,-(sp)
    170						clr	-(sp)
    171						bisb	ch	,@sp
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 7-3
Utility macros

    172						call	scanch
    173						.endm	scan
    174
    175						.macro	setpar	src ,dst
    176						movb	src	,-(sp)
    177						call	dopari
    178						movb	(sp)+	,dst
    179						.endm	setpar
    180
    181						.macro	spack	type ,pnum ,len ,msg
    182						.if  b	<len>
    183						.iif nb	<msg>	.error	<; bad call to SPACK macro>
    184						calls	spack$	,<type,pnum,#0,#null>
    185						.iff
    186						calls	spack$	,<type,pnum,len,msg>
    187						.endc
    188						.endm	spack
    189
    190						.macro	strcat	dst ,src
    191						mov	src	,-(sp)
    192						mov	dst	,-(sp)
    193						jsr	pc	,strcat
    194						.endm	strcat
    195
    196						.macro	strcpy	dst ,src
    197						mov	src	,-(sp)
    198						mov	dst	,-(sp)
    199						jsr	pc	,strcpy
    200						.endm	strcpy
    201
    202						.macro	strlen	string
    203						mov	string	,r0
    204						call	l$len
    205						.endm	strlen
    206
    207						.macro	textsrc	text
    208						.if  b	<text>
    209						clr	getcroutine		; /62/ reset to file I/O
    210						clr	tgetaddr
    211						.iff
    212						mov	#tgetcr0,getcroutine
    213						mov	text	,tgetaddr
    214						.endc
    215						.endm	textsrc
    216
    217						.macro	tochar	src ,dst
    218						clr	-(sp)
    219						bisb	src	,@sp
    220						add	#40	,@sp
    221						movb	(sp)+	,dst
    222						.endm	tochar
    223
    224						.macro	unchar	src ,dst
    225						clr	-(sp)
    226						bisb	src	,@sp
    227						sub	#40	,@sp
    228						movb	(sp)+	,dst
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 7-4
Utility macros

    229						.endm	unchar
    230
    231						.macro	unsave	list
    232						.if b <list>
    233						unsave	<r5,r4,r3,r2,r1,r0>
    234						.iff
    235						.irp	x ,<list>
    236						 mov	(sp)+	,x
    237						.endr
    238						.endc
    239						.endm	unsave
    240
    241						.macro	upcase	s		; /BBS/ added ..
    242						mov	s	,r0
    243						call	upcase			; /BBS/ upcase until null terminator
    244						.endm	upcase
    245
    246						.macro	upone	s		; /BBS/ added ..
    247						mov	s	,r0
    248						call	upone			; /BBS/ upcase only to next delimiter
    249						.endm	upone
    250
    251						.macro	wrtall	arg		; IO.WAL for an .asciz string
    252						mov	arg	,-(sp)		; pass the address
    253						call	wrtall			; do it
    254						.endm	wrtall
    255
    256						.macro	xor	reg ,dst
    257						ixor	reg	,dst
    258						.endm	xor
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 8
Utility macros

      1						.iif ndf  KRTINC  .error	<; .include for IN:KRTMAC.MAC failed>
      2
      3						.mcall	.RCTRLO
      4
      5		000274 				CVTARG	= C.CRLF ! C.LSPA ! C.SSPA ! C.LCUC ! C.TSPA ; arg processing
      6
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 9
Utility macros

      1
      2						.sbttl	Local data
      3
      4	000000					.psect	$pdata
      5	000000	000620'	000720'	001020'	sub.0:	.word	sub.2 ,sub.3 ,sub.4	; /62/ for nested wildcarded headers
      6	000006	000020'	000037'	000056'	rtname:	.word	10$ ,20$ ,30$ ,40$ ,0	; /63/ this is the help file path
      7	000020	   110 	   114 	   120 	10$:	.asciz	"HLP:KRTHLP.HLP"	; /BBS/ try here first
      8	000037	   113 	   122 	   124 	20$:	.asciz	"KRT:KRTHLP.HLP"	; /BBS/ then here, etc..
      9	000056	   123 	   131 	   072 	30$:	.asciz	"SY:KRTHLP.HLP"
     10	000074	   104 	   113 	   072 	40$:	.asciz	"DK:KRTHLP.HLP"
     11	000112	   040 	   040 	   040 	addinf:	.ascii	"    Additional information is available on:"<cr><lf> ; /63/
     12	000167	   015 	   012 	   040 	 fill7:	.byte	cr ,lf ,40 ,40 ,40 ,40 ,40 ,40 ; /BBS/ a newline and 7 blanks
     13	000177	   040 	   000 		 fill:	.byte	40 ,0			; or just one blank, for formatting
     14	000201	   125 	   160 	   147 	bugtxt:	.asciz	"Upgrades"		; /62/ for the BUG command
     15	000212	   040 	   055 	   055 	dbldash:.asciz	" --"			; /BBS/ a space and a double dash..
     16	000216	   077 	   113 	   122 	errhdr:	.asciz	"?KRTHLP-W-"		; /63/
     17	000231	   103 	   141 	   156 	errmis:	.asciz	"Can't find KRTHLP.HLP on HLP, KRT, SY or DK"<cr><lf>
     18	000307	   040 	   151 	   163 	errver:	.asciz	" is an incorrect version"<cr><lf>
     19	000342	   114 	   120 	   072 	hlp2lp:	.asciz	"LP:KRTHLP.OUT"		; /62/ where HPRINT sends a file
     20	000360	   045 	   040 	   110 	nohelp:	.asciz	"% Help not found for the requested topic"<cr><lf> ; /63/
     21	000433	   040 	   123 	   145 	ptopic:	.asciz	" Select topic, please: " ; /BBS/ for prompting
     22						.even
     23
     24	000000					.psect	$rwdata	,rw,d,lcl,rel,con ; /BBS/
     25	000000	000000 			backlev:.word	0			; /BBS/ last good topic in case error
     26	000002	000000 			backup:	.word	0			; /BBS/ for nesting in on an error
     27	000004				hlpbuf:	.blkb	134.			; /63/ read/write buffer for the file
     28	000212				htopic:	.blkb	200			; the current topic
     29	000412	000000 			idxdmp:	.word	0			; index was dumped
     30	000414				prbuff:	.blkb	200			; prompting buffer
     31	000614	000000 			prmptd:	.word	0			; /62/ select subtopic prompt done
     32	000616	000000 			rmsidx:	.word	0			; /BBS/ current place in RMS index
     33	000620				sub.2:	.blkb	100			; /62/ fill in with sub topics
     34	000720				sub.3:	.blkb	100			; /62/ as required by how far in
     35	001020				sub.4:	.blkb	100			; /62/ nested wildcarding goes..
     36	001120	000000 			subwild:.word	0			; /62/ <> if 1st char of input is "*"
     37	001122	000000 	000000 	000000 	topics:	.word	0 ,0 ,0 ,0 ,0 ,0 ,0 ,0	; /BBS/ list of topic/subtopic addrs
     38	001142				topbuf:	.blkb	200			; (nested) topics buffer
     39	001342	000000 			toplev:	.word	0			; level of current topic
     40	001344				ttbuff:	.blkb	134.			; /63/ terminal read buffer
     41	001552	000000 			wild:	.word	0			; <> if topic wildcarded
     42
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 10
Local data

      1
      2	000000					.psect	$code
      3						.sbttl	BUG, HPRINT
      4
      5	000000	005767 	000000G		c$phlp::tst	outopn			; /63/ come here to print it too..
      6	000004	001403 				beq	10$			; output channel is available
      7	000006	012700 	000000G			mov	#er$lby	,r0		; chan is busy
      8	000012	000425 				br	20$			; handle error
      9	000014				10$:	calls	create	,<#hlp2lp,#lun.ou,#text> ; open chan to LP:
	000014	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000016	012746 	000000 			        mov	#text	,-(sp)	; push it
	000022	012746 	000000G			        mov	#lun.ou	,-(sp)	; push it
	000026	012746 	000342'			        mov	#hlp2lp	,-(sp)	; push it
	000032	010605 				  mov	sp	,r5		; set up the argument list pointer
	000034	004767 	000000G			  jsr	pc	,create		; and go to the routine
	000040	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	000044	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     10	000046	005700 				tst	r0			; did it work?
     11	000050	001006 				bne	20$			; /63/ no
     12	000052	010667 	000000G			mov	sp	,outopn		; flag output channel is open
     13	000056	012767 	000000G	000000G		mov	#lun.ou	,xprint		; enable print routine in ttyout stuff
     14	000064	000412 				br	c$help			; /63/
     15	000066				20$:	direrr	r0			; no, say why..
	000066	010046 				mov	r0	,-(sp)
	000070	004767 	000000G			call	direr$
     16	000074	000207 				return
     17
     18	000076				c$bug::	strcpy	argbuf	,#bugtxt	; /62/ do this for
	000076	012746 	000201'			mov	#bugtxt	,-(sp)
	000102	016746 	000000G			mov	argbuf	,-(sp)
	000106	004767 	000000G			jsr	pc	,strcpy
     19	000112					.br	c$help			; /63/ the "BUG" command
     20
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 11
BUG, HPRINT

      1
      2						.sbttl	HELP main_loop
      3
      4					;	(1)  Try to open help file, if it fails print an error message
      5					;	(2)  Parse the command line, filling in the topics pointer array
      6					;	(3)  Find and print (if found) the requested help topic+[subtopic(s)]
      7					;	(4)  If not found, build a new command line from the topics pointer
      8					;	     array, prompt and concatenate the requested topic
      9					;	(5)  Go back to (2)
     10					;	(6)  When done, close help file
     11
     12	000112	004767 	002362 		c$help::call	hlpopn			; come here for just plain help..
     13	000116	005700 				tst	r0			; locate and open the help file?
     14	000120	001402 				beq	30$			; /BBS/ ya..
     15	000122	000167 	000466 			jmp	140$			; /62/ no, error already displayed..
     16
     17	000126				30$:	upcase	argbuf			; /BBS/ keep this out of the loop!
	000126	016700 	000000G			mov	argbuf	,r0
	000132	004767 	000000G			call	upcase			; /BBS/ upcase until null terminator
     18	000136	005067 	000614'			clr	prmptd			; /62/ haven't asked for a subtopic
     19	000142	005067 	001120'			clr	subwild			; /62/ first char of input isn't a "*"
     20
     21	000146	005067 	000412'		40$:	clr	idxdmp			; index has not been dumped yet
     22	000152	005067 	001552'			clr	wild			; clear the wildcarding flag
     23	000156	005067 	001122'			clr	topics			; init [sub]topics pointers
     24	000162	105067 	000414'			clrb	prbuff			; /BBS/ clear sub-level prompt buffer
     25	000166	004767 	000000G			call	loahlp			; /63/ load HELP text index overlay
     26	000172	010067 	000616'			mov	r0	,rmsidx		; /63/ goto the top of the RMS list
     27	000176	016705 	000000G			mov	argbuf	,r5		; /BBS/ point to possible command args
     28	000202	105715 				tstb	@r5			; anything there?
     29	000204	001451 				beq	80$			; no, dump root index
     30	000206	004767 	000474 			call	parse			; ya, set up pointers
     31	000212	004767 	000564 			call	hfind			; now locate the desired text
     32	000216	005700 				tst	r0			; find anything?
     33	000220	001404 				beq	50$			; yes, let's go dump the text
     34	000222	005300 				dec	r0			; ok, was it a code of 1 or 2?
     35	000224	001405 				beq	60$			; 1, which means not found
     36	000226	010667 	001552'			mov	sp	,wild		; 2, found something wildcarded
     37	000232	004767 	001142 		50$:	call	hprint			; dump the help text out now
     38	000236	000442 				br	90$			; then continue
     39
     40	000240				60$:	wrtall	#nohelp			; /63/ "Help not found for .."
	000240	012746 	000360'			mov	#nohelp	,-(sp)		; pass the address
	000244	004767 	000000G			call	wrtall			; do it
     41	000250	016767 	000002'	000616'		mov	backup	,rmsidx		; /BBS/ here on a topic error?
     42	000256	001412 				beq	70$			; /BBS/ nope..
     43	000260	016767 	000000'	001342'		mov	backlev	,toplev		; /BBS/ ya, recover topic level
     44	000266	005067 	000002'			clr	backup			; /BBS/ don't come back here from here
     45	000272	005067 	000412'			clr	idxdmp			; /BBS/ haven't dumped an index yet
     46	000276	005067 	001552'			clr	wild			; /BBS/ in case nothing was there to *
     47	000302	000753 				br	50$			; /BBS/ print nested in as far as can
     48	000304	005067 	001122'		70$:	clr	topics			; re-init [sub]topics pointers
     49	000310	105067 	000414'			clrb	prbuff			; /BBS/ clear sub-level prompt buffer
     50	000314	105067 	000004'			clrb	hlpbuf			; /BBS/ init one more buffer
     51	000320	004767 	000000G			call	loahlp			; /63/ load HELP text index overlay
     52	000324	010067 	000616'			mov	r0	,rmsidx		; /63/ goto the top of the RMS list
     53	000330				80$:	.newline
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 11-1
HELP main_loop

	000330	004767 	000000G			call	l$pcrlf
     54	000334	012746 	000061 			mov	#'1	,-(sp)		; flag to..
     55	000340	004767 	001660 			call	hindex			; ..dump the top-level index out now
     56
     57	000344	005767 	000412'		90$:	tst	idxdmp			; did we ever print [sub]topic list?
     58	000350	001521 				beq	140$			; /62/ no, just exit
     59	000352	012703 	000414'			mov	#prbuff	,r3		; ya, build a prompt string
     60	000356	016704 	000000G			mov	argbuf	,r4		; in the argbuf
     61	000362	012705 	001122'			mov	#topics	,r5		; pointers to the parsed arguments
     62	000366	105014 				clrb	@r4			; /BBS/ init argbuf keep prbuff intact
     63	000370	012502 			100$:	mov	(r5)+	,r2		; get next parsed argument
     64	000372	001415 				beq	110$			; all done, exit
     65	000374	121227 	000052 			cmpb	(r2)	,#'*		; wildcard argument?
     66	000400	001506 				beq	150$			; /BBS/ ya, done
     67	000402					strcat	r4	,r2		; /BBS/ no, add in previous [sub]topic
	000402	010246 				mov	r2	,-(sp)
	000404	010446 				mov	r4	,-(sp)
	000406	004767 	000000G			jsr	pc	,strcat
     68	000412					strcat	r4	,#fill		; /BBS/ and a delimiter
	000412	012746 	000177'			mov	#fill	,-(sp)
	000416	010446 				mov	r4	,-(sp)
	000420	004767 	000000G			jsr	pc	,strcat
     69	000424	000761 				br	100$			; do next arg
     70	000426	105713 			110$:	tstb	@r3			; /BBS/ anything in prompt buffer?
     71	000430	001405 				beq	120$			; /BBS/ nope..
     72	000432					strcat	r3	,#dbldash	; /BBS/ ya, add " --" to prompt string
	000432	012746 	000212'			mov	#dbldash	,-(sp)
	000436	010346 				mov	r3	,-(sp)
	000440	004767 	000000G			jsr	pc	,strcat
     73	000444				120$:	strcat	r3	,#ptopic	; finish creating the prompt
	000444	012746 	000433'			mov	#ptopic	,-(sp)
	000450	010346 				mov	r3	,-(sp)
	000452	004767 	000000G			jsr	pc	,strcat
     74	000456	005067 	001120'			clr	subwild			; /62/ first char of input isn't a "*"
     75	000462					.rctrlo				; /BBS/ be sure output is on
	000462	104355 				EMT	^O355
     76	000464					.newline
	000464	004767 	000000G			call	l$pcrlf
     77	000470					calls	readcmd	,<#ttbuff,r3>	; /BBS/ use SL editor
	000470	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000472	010346 				        mov	r3	,-(sp)	; push it
	000474	012746 	001344'			        mov	#ttbuff	,-(sp)	; push it
	000500	010605 				  mov	sp	,r5		; set up the argument list pointer
	000502	004767 	000000G			  jsr	pc	,readcmd		; and go to the routine
	000506	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	000510	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     78	000512	005700 				tst	r0			; successful terminal read?
     79	000514	001040 				bne	150$			; /BBS/ no, got to exit
     80	000516					calls	cvt$$	,<#ttbuff,r1,#cvtarg> ; remove garbage, upper case
	000516	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000520	012746 	000274 			        mov	#cvtarg	,-(sp)	; push it
	000524	010146 				        mov	r1	,-(sp)	; push it
	000526	012746 	001344'			        mov	#ttbuff	,-(sp)	; push it
	000532	010605 				  mov	sp	,r5		; set up the argument list pointer
	000534	004767 	000000G			  jsr	pc	,cvt$$		; and go to the routine
	000540	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	000544	012605 				  mov	(sp)+	,r5		; /63/ restore r5
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 11-2
HELP main_loop

     81	000546	005700 				tst	r0			; anything left?
     82	000550	001421 				beq	140$			; /62/ no, exit please
     83	000552	105060 	001344'			clrb	ttbuff(r0)		; ya, ensure .asciz
     84	000556	126727 	001344'	000052 		cmpb	ttbuff	,#'*		; /62/ is first byte an asterisk?
     85	000564	001002 				bne	130$			; /62/ no
     86	000566	010667 	001120'			mov	sp	,subwild	; /62/ first char of input is a "*"
     87	000572				130$:	strcat	r4	,#ttbuff	; append the data just read please
	000572	012746 	001344'			mov	#ttbuff	,-(sp)
	000576	010446 				mov	r4	,-(sp)
	000600	004767 	000000G			jsr	pc	,strcat
     88	000604	010667 	000614'			mov	sp	,prmptd		; /62/ prompted for subtopic flag
     89	000610	000167 	177332 			jmp	40$			; and parse the command all over again
     90
     91	000614	005000 			140$:	clr	r0			; /62/ here if error already handled
     92	000616				150$:	save	<r0>			; /62/ moved hlpclo here..
	000616	010046 				 mov	r0	,-(sp)
     93	000620	005767 	000000G			tst	outopn			; is chan to LP open?
     94	000624	001412 				beq	160$			; no
     95	000626					calls	close	,<#lun.ou>	; ya, close it
	000626	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000630	012746 	000000G			  mov	#lun.ou	,-(sp)		; doing it thusly generates less code
	000634	010605 				  mov	sp	,r5		; set pointer to argument list
	000636	004767 	000000G			  jsr	pc	,close		; call the subroutine
	000642	005726 				  tst	(sp)+			; pop parameter list from stack
	000644	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     96	000646	005067 	000000G			clr	outopn			; say it's now closed
     97	000652	005067 	000000G		160$:	clr	xprint			; turn off hprint
     98	000656					calls	close	,<#lun.in>	; close the help text file
	000656	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000660	012746 	000000G			  mov	#lun.in	,-(sp)		; doing it thusly generates less code
	000664	010605 				  mov	sp	,r5		; set pointer to argument list
	000666	004767 	000000G			  jsr	pc	,close		; call the subroutine
	000672	005726 				  tst	(sp)+			; pop parameter list from stack
	000674	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     99	000676	005067 	000000G			clr	inopn			; flag channel is now free
    100	000702					unsave	<r0>			; /62/
	000702	012600 				 mov	(sp)+	,r0
    101	000704	000207 				return
    102
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 12
HELP main_loop

      1
      2						.sbttl	Parse command line
      3
      4					;	P A R S E
      5					;
      6					;	passed:	  r5	= address of command args (minus "HELP"), .asciz
      7					;	return:	topics	= addresses to each topic/subtopic
      8					;			  extra embedded spaces are removed
      9
     10	000706				parse:	save	<r3,r4,r5>
	000706	010346 				 mov	r3	,-(sp)
	000710	010446 				 mov	r4	,-(sp)
	000712	010546 				 mov	r5	,-(sp)
     11	000714	012704 	001142'			mov	#topbuf	,r4		; where to copy the text
     12	000720	012703 	001122'			mov	#topics	,r3		; where to place the pointers to it
     13	000724	005013 				clr	@r3			; assume nothing was passed
     14	000726	105715 			10$:	tstb	@r5			; all done?
     15	000730	001420 				beq	50$			; yes, exit this routine
     16	000732	121527 	000040 			cmpb	@r5	,#space		; while (*ch && *ch == space) ch++
     17	000736	001002 				bne	20$			; not a space, go copy the data
     18	000740	005205 				inc	r5			; a space found, check next one
     19	000742	000771 				br	10$			; next
     20	000744	010423 			20$:	mov	r4	,(r3)+		; insert current address
     21	000746	005013 				clr	@r3			; ensure next one is cleared out
     22	000750	105715 			30$:	tstb	@r5			; all done with this line?
     23	000752	001405 				beq	40$			; yes, exit
     24	000754	121527 	000040 			cmpb	@r5	,#space		; space delimiter found?
     25	000760	001402 				beq	40$			; yes, setup for next one
     26	000762	112524 				movb	(r5)+	,(r4)+		; no, copy some data over
     27	000764	000771 				br	30$			; next please
     28	000766	105024 			40$:	clrb	(r4)+			; ensure .asciz please
     29	000770	000756 				br	10$			; next subtopic
     30	000772				50$:	unsave	<r5,r4,r3>
	000772	012605 				 mov	(sp)+	,r5
	000774	012604 				 mov	(sp)+	,r4
	000776	012603 				 mov	(sp)+	,r3
     31	001000	000207 				return
     32
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 13
Parse command line

      1
      2						.sbttl	Find the topic in the help file
      3
      4					;	input:	topics	= list of addresses of text to match
      5					;	return:	 r0	= 0 if success
      6					;			= 1 if not found
      7					;			= 2 if match and wildcarded topic/subtopic
      8
      9					; /BBS/	modified to scan an internal index and return pointer in rmsidx
     10					;	to block and offset of beginning of desired text in KRTHLP.HLP
     11
     12	001002				hfind:	save	<r2,r3,r4,r5>
	001002	010246 				 mov	r2	,-(sp)
	001004	010346 				 mov	r3	,-(sp)
	001006	010446 				 mov	r4	,-(sp)
	001010	010546 				 mov	r5	,-(sp)
     13	001012	012705 	001122'			mov	#topics	,r5		; point to the help topic list
     14	001016	012702 	000061 			mov	#'1	,r2		; current topic level
     15	001022	105067 	000212'			clrb	htopic			; clear out header
     16	001026	004767 	000000G			call	loahlp			; /63/ load HELP text index overlay
     17	001032	010004 				mov	r0	,r4		; /63/ pointer to fake RMS list
     18
     19	001034	005715 			10$:	tst	@r5			; anything to look for?
     20	001036	001540 				beq	110$			; no, just leave pointing at beginning
     21	001040	011401 				mov	@r4	,r1		; /BBS/ get address of ascii topic
     22	001042	001526 				beq	100$			; /BBS/ end of list, return(1)
     23	001044	121102 				cmpb	@r1	,r2		; topic levels match up?
     24	001046	103524 				blo	100$			; /BBS/ if gt then quit looking..
     25	001050	001054 				bne	70$			; no, read another record then
     26	001052	005201 				inc	r1			; /BBS/ skip over the level flag now
     27	001054	005201 				inc	r1			; /BBS/ skip over space
     28	001056	011503 				mov	(r5)	,r3		; get pointer to text to match up
     29	001060	121327 	000052 			cmpb	(r3)	,#'*		; wildcarding?
     30	001064	001451 				beq	80$			; yes, return(2)
     31
     32	001066	105713 			20$:	tstb	(r3)			; found end of the desired topic?
     33	001070	001425 				beq	60$			; ya, check next level topic needed
     34	001072	105711 				tstb	(r1)			; /BBS/ end of the line yet?
     35	001074	001442 				beq	70$			; yes
     36	001076	112100 				movb	(r1)+	,r0		; /BBS/ no, get next byte
     37	001100	120027 	000141 			cmpb	r0	,#'a!40		; is this a lower case letter?
     38	001104	103405 				blo	30$			; nope
     39	001106	120027 	000172 			cmpb	r0	,#'z!40		; maybe, if a "z" or below
     40	001112	101002 				bhi	30$			; no
     41	001114	142700 	000040 			bicb	#40	,r0		; ya, convert to upper case
     42	001120	121327 	000137 		30$:	cmpb	(r3)	,#'_		; /63/ did user type an underscore?
     43	001124	001003 				bne	40$			; /63/ no
     44	001126	120027 	000055 			cmpb	r0	,#'-		; /63/ ya, looking for a dash?
     45	001132	001402 				beq	50$			; /63/ ya, call it a match
     46	001134	121300 			40$:	cmpb	(r3)	,r0		; /63/ do the characters match up?
     47	001136	001021 				bne	70$			; /63/ no, read another record
     48	001140	005203 			50$:	inc	r3			; /63/ yes, keep checking them
     49	001142	000751 				br	20$			; /63/
     50
     51	001144	010267 	000000'		60$:	mov	r2	,backlev	; /BBS/ save this before the bump
     52	001150	010467 	000002'			mov	r4	,backup		; /BBS/ save copy of RMS index
     53	001154	005202 				inc	r2			; increment level # and read
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 13-1
Find the topic in the help file

     54	001156	005725 				tst	(r5)+			; another record from the help file
     55	001160	011401 				mov	@r4	,r1		; /BBS/ recover pointer
     56	001162	005201 				inc	r1			; /BBS/ bump past topic level number
     57	001164					strcat	#htopic	,r1		; /BBS/ build up a header record
	001164	010146 				mov	r1	,-(sp)
	001166	012746 	000212'			mov	#htopic	,-(sp)
	001172	004767 	000000G			jsr	pc	,strcat
     58	001176	005067 	000614'			clr	prmptd			; /62/ do main topic when wildcarding
     59	001202	062704 	000006 		70$:	add	#6	,r4		; /BBS/ bump index to next entry
     60	001206	000712 				br	10$			; then back for more
     61
     62	001210	105767 	000212'		80$:	tstb	htopic			; /62/ if eq it's H * or HPRINT * so
     63	001214	001426 				beq	90$			; /62/ there's no first topic to see
     64	001216	005767 	000614'			tst	prmptd			; /62/ already displayed main topic?
     65	001222	001023 				bne	90$			; /62/ ya
     66	001224	005767 	001120'			tst	subwild			; /62/ don't dump the index if first
     67	001230	001020 				bne	90$			; /62/ char of inout is a "*"
     68	001232					save	<r1>			; /62/ no, stash this address..
	001232	010146 				 mov	r1	,-(sp)
     69	001234	016767 	000002'	000616'		mov	backup	,rmsidx		; /62/ prep to dump the main text
     70	001242	016767 	000000'	001342'		mov	backlev	,toplev		; /62/ for a wildcarded [sub]topic
     71	001250	005067 	001552'			clr	wild			; /62/ but only that for the moment
     72	001254	004767 	000120 			call	hprint			; /62/ display main topic text & index
     73	001260					.newline			; /62/ format the display
	001260	004767 	000000G			call	l$pcrlf
     74	001264	010667 	001552'			mov	sp	,wild		; /62/ restore wildcarded status
     75	001270					unsave	<r1>			; /62/ pop address of topic name
	001270	012601 				 mov	(sp)+	,r1
     76	001272	005301 			90$:	dec	r1			; /BBS/ back up to include a blank
     77	001274					strcpy	#hlpbuf	,r1		; /62/ used to build first header
	001274	010146 				mov	r1	,-(sp)
	001276	012746 	000004'			mov	#hlpbuf	,-(sp)
	001302	004767 	000000G			jsr	pc	,strcpy
     78	001306	010267 	001342'			mov	r2	,toplev		; save the topic level
     79	001312	012700 	000002 			mov	#2	,r0		; /62/ match with wildcarding
     80	001316	000417 				br	120$			; /62/ done
     81
     82	001320	004767 	000000G		100$:	call	loahlp			; /63/ load HELP text index overlay
     83	001324	010067 	000616'			mov	r0	,rmsidx		; /63/ reset to top of file
     84	001330	012700 	000001 			mov	#1	,r0		; /63/ nothing found (reached EOF)
     85	001334	005015 				clr	@r5			; /BBS/ zap pointer to ng [sub]topic
     86	001336	000413 				br	130$			; bail out
     87	001340	010267 	001342'		110$:	mov	r2	,toplev		; save topic level
     88	001344	005367 	001342'			dec	toplev			; it will be off by one
     89	001350	005000 				clr	r0			; found the topic
     90	001352	162704 	000006 			sub	#6	,r4		; /BBS/ back up to last good one
     91	001356	010467 	000616'		120$:	mov	r4	,rmsidx		; /BBS/ save a copy of where it is now
     92	001362	005067 	000002'			clr	backup			; /BBS/ clear nested error rmsidx buff
     93	001366				130$:	unsave	<r5,r4,r3,r2>
	001366	012605 				 mov	(sp)+	,r5
	001370	012604 				 mov	(sp)+	,r4
	001372	012603 				 mov	(sp)+	,r3
	001374	012602 				 mov	(sp)+	,r2
     94	001376	000207 				return
     95
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 14
Find the topic in the help file

      1
      2						.sbttl	Print help text found by HFIND
      3
      4					;	assumes:	both PARSE and HFIND have been called already
      5					;	return:   r0	= if < failure, the RMS error code
      6					;			  if 0 success
      7					;			  if 1 found subtopics to print out
      8
      9					; /BBS/	patched to support indexing for help text in KRTHLP.HLP
     10
     11	001400				hprint:	save	<r2,r3,r4>
	001400	010246 				 mov	r2	,-(sp)
	001402	010346 				 mov	r3	,-(sp)
	001404	010446 				 mov	r4	,-(sp)
     12	001406	105067 	000620'			clrb	sub.2			; /62/ init wildcarded
     13	001412	105067 	000720'			clrb	sub.3			; /62/ sub topics
     14	001416	105067 	001020'			clrb	sub.4			; /62/ nested names buffers
     15	001422	005002 				clr	r2			; /62/ init index display control flag
     16	001424					strcpy	#ttbuff	,#htopic	; get the default header string made
	001424	012746 	000212'			mov	#htopic	,-(sp)
	001430	012746 	001344'			mov	#ttbuff	,-(sp)
	001434	004767 	000000G			jsr	pc	,strcpy
     17	001440					strcpy	#prbuff	,r0		; /62/ copy for select topic prompt
	001440	010046 				mov	r0	,-(sp)
	001442	012746 	000414'			mov	#prbuff	,-(sp)
	001446	004767 	000000G			jsr	pc	,strcpy
     18	001452	012704 	000004'			mov	#hlpbuf	,r4		; /BBS/ point to the buffer now
     19	001456	005767 	001552'			tst	wild			; /BBS/ coming in wild?
     20	001462	001415 				beq	10$			; /BBS/ nope..
     21	001464					.newline			; /BBS/ format display..
	001464	004767 	000000G			call	l$pcrlf
     22	001470					strcat	#ttbuff	,r4		; /62/ build up a header record for
	001470	010446 				mov	r4	,-(sp)
	001472	012746 	001344'			mov	#ttbuff	,-(sp)
	001476	004767 	000000G			jsr	pc	,strcat
     23	001502					wrtall	r0			; /62/ the first topic and print it
	001502	010046 				mov	r0	,-(sp)		; pass the address
	001504	004767 	000000G			call	wrtall			; do it
     24	001510					.newline			; /BBS/ and tag it with a newline
	001510	004767 	000000G			call	l$pcrlf
     25	001514	105010 				clrb	(r0)			; /BBS/ clear ttbuff name out now
     26
     27	001516	004767 	000442 		10$:	call	preset			; /BBS/ goto needed record in krthlp
     28	001522	103002 				bcc	30$			; /62/ it worked
     29	001524	000167 	000424 		20$:	jmp	170$			; /62/ it didn't work
     30
     31	001530				30$:	calls	getrec	,<r4,#lun.in,#132.> ; /62/ read the next record
	001530	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001532	012746 	000204 			        mov	#132.	,-(sp)	; push it
	001536	012746 	000000G			        mov	#lun.in	,-(sp)	; push it
	001542	010446 				        mov	r4	,-(sp)	; push it
	001544	010605 				  mov	sp	,r5		; set up the argument list pointer
	001546	004767 	000000G			  jsr	pc	,getrec		; and go to the routine
	001552	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	001556	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     32	001560	005700 				tst	r0			; error?
     33	001562	001360 				bne	20$			; /62/ yes, exit
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 14-1
Print help text found by HFIND

     34	001564	105061 	000004'			clrb	hlpbuf(r1)		; ensure it's .asciz please
     35	001570	121427 	000040 			cmpb	(r4)	,#space		; leading space or control char?
     36	001574	101532 				blos	110$			; yes, a normal line to print
     37	001576	062767 	000006 	000616'		add	#6	,rmsidx		; /BBS/ keep RMS index pointer current
     38	001604	121467 	001342'			cmpb	(r4)	,toplev		; is this a lower, higher or same?
     39	001610	103560 				blo	160$			; lower level, exit
     40	001612	001435 				beq	60$			; same level
     41	001614	016703 	000616'			mov	rmsidx	,r3		; /62/ save to dump text after index
     42	001620	121402 				cmpb	(r4)	,r2		; /62/ done this particular index yet?
     43	001622	003424 				ble	50$			; /62/ ya, once is enough
     44	001624	111400 				movb	(r4)	,r0		; /62/ copy of current nesting level
     45	001626	162700 	000062 			sub	#'0+2	,r0		; /62/ convert, "2"=0 "3"=1 "4"=2
     46	001632	002407 				blt	40$			; /62/ this should never happen
     47	001634	006300 				asl	r0			; /62/ word indexing
     48	001636					strcpy	sub.0(r0),#errtxt	; /62/ stash a copy for making headers
	001636	012746 	000000G			mov	#errtxt	,-(sp)
	001642	016046 	000000'			mov	sub.0(r0)	,-(sp)
	001646	004767 	000000G			jsr	pc	,strcpy
     49
     50	001652	111400 			40$:	movb	(r4)	,r0		; /BBS/ keep the high byte clear while
     51	001654	010046 				mov	r0	,-(sp)		; /BBS/ passing the level number
     52	001656	004767 	000342 			call	hindex			; and print out whats leftover
     53	001662	005767 	001552'			tst	wild			; if not wildcarded
     54	001666	001526 				beq	150$			; then exit
     55	001670					.newline			; /BBS/ format wildcarded display
	001670	004767 	000000G			call	l$pcrlf
     56
     57	001674	010367 	000616'		50$:	mov	r3	,rmsidx		; /62/ now back up and do topics text
     58	001700	004767 	000260 			call	preset			; /62/ load buff with 1st block of it
     59	001704	103523 				bcs	170$			; /BBS/ it didn't work..
     60
     61	001706	005767 	001552'		60$:	tst	wild			; same level, is it wildcarded?
     62	001712	001517 				beq	160$			; no, we must exit
     63	001714	111400 				movb	(r4)	,r0		; /62/ copy of current nesting level
     64	001716	162700 	000061 			sub	#'0+1	,r0		; /62/ convert to an integer
     65	001722	002414 				blt	100$			; /62/ not a topic line
     66	001724	001405 				beq	70$			; /62/ level "1"  hose "2" and up..
     67	001726	005300 				dec	r0
     68	001730	001405 				beq	80$			; /62/ level "2"  hose "3" and up..
     69	001732	005300 				dec	r0
     70	001734	001405 				beq	90$			; /62/ level "3"  hose "4" and up..
     71	001736	000406 				br	100$			; /62/ level "4"  could need them all
     72	001740	105067 	000620'		70$:	clrb	sub.2			; /62/ clear nested subtopic names
     73	001744	105067 	000720'		80$:	clrb	sub.3			; /62/ as determined (and required)
     74	001750	105067 	001020'		90$:	clrb	sub.4			; /62/ by the current topic level
     75
     76	001754	111402 			100$:	movb	(r4)	,r2		; /62/ topic level for index control
     77	001756	105014 				clrb	(r4)			; /62/ don't print this line
     78	001760					strcpy	#ttbuff	,#htopic	; build a header string up
	001760	012746 	000212'			mov	#htopic	,-(sp)
	001764	012746 	001344'			mov	#ttbuff	,-(sp)
	001770	004767 	000000G			jsr	pc	,strcpy
     79	001774					strcat	r0	,#sub.2		; /62/ fill in as	else null in
	001774	012746 	000620'			mov	#sub.2	,-(sp)
	002000	010046 				mov	r0	,-(sp)
	002002	004767 	000000G			jsr	pc	,strcat
     80	002006					strcat	r0	,#sub.3		; /62/ required by	first byte to
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 14-2
Print help text found by HFIND

	002006	012746 	000720'			mov	#sub.3	,-(sp)
	002012	010046 				mov	r0	,-(sp)
	002014	004767 	000000G			jsr	pc	,strcat
     81	002020					strcat	r0	,#sub.4		; /62/ nesting level	skip past ..
	002020	012746 	001020'			mov	#sub.4	,-(sp)
	002024	010046 				mov	r0	,-(sp)
	002026	004767 	000000G			jsr	pc	,strcat
     82	002032	017701 	000616'			mov	@rmsidx	,r1		; /62/ copy for subtopic string build
     83	002036	005201 				inc	r1			; /62/ skip past the leading number
     84	002040					strcat	r0	,r1		; copy over leading space & topic name
	002040	010146 				mov	r1	,-(sp)
	002042	010046 				mov	r0	,-(sp)
	002044	004767 	000000G			jsr	pc	,strcat
     85	002050					strcpy	#errtxt	,r1		; /62/ save a copy for nested headers
	002050	010146 				mov	r1	,-(sp)
	002052	012746 	000000G			mov	#errtxt	,-(sp)
	002056	004767 	000000G			jsr	pc	,strcpy
     86
     87	002062	105767 	001344'		110$:	tstb	ttbuff			; do we need to print the next topic?
     88	002066	001415 				beq	130$			; no
     89	002070					.newline			; ya
	002070	004767 	000000G			call	l$pcrlf
     90	002074					wrtall	#ttbuff			; dump it please
	002074	012746 	001344'			mov	#ttbuff	,-(sp)		; pass the address
	002100	004767 	000000G			call	wrtall			; do it
     91	002104	005767 	001552'			tst	wild			; /BBS/ if a wildcard dump
     92	002110	001002 				bne	120$			; /BBS/ don't do this newline
     93	002112					.newline
	002112	004767 	000000G			call	l$pcrlf
     94	002116	105067 	001344'		120$:	clrb	ttbuff			; clear topic name out now
     95	002122	105714 			130$:	tstb	(r4)			; if this is a null
     96	002124	001403 				beq	140$			; don't print it
     97	002126					wrtall	r4			; ok to print, dump the text now
	002126	010446 				mov	r4	,-(sp)		; pass the address
	002130	004767 	000000G			call	wrtall			; do it
     98	002134				140$:	.newline
	002134	004767 	000000G			call	l$pcrlf
     99	002140	000167 	177364 			jmp	30$			; /62/ next please
    100
    101	002144	012700 	000001 		150$:	mov	#1	,r0		; return(sub_topic_found)
    102	002150	000401 				br	170$
    103	002152	005000 			160$:	clr	r0			; return(success)
    104	002154				170$:	unsave	<r4,r3,r2>
	002154	012604 				 mov	(sp)+	,r4
	002156	012603 				 mov	(sp)+	,r3
	002160	012602 				 mov	(sp)+	,r2
    105	002162	000207 				return
    106
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 15
Print help text found by HFIND

      1
      2						.sbttl	Preset an I/O channel to an exact block and offset ; /BBS/
      3
      4	002164	016700 	000616'		preset:	mov	rmsidx	,r0		; get copy of indexing pointer
      5	002170					calls	prewind	,<#lun.in,2(r0),4(r0)>	; load and preset buffer
	002170	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002172	016046 	000004 			        mov	4(r0)	,-(sp)	; push it
	002176	016046 	000002 			        mov	2(r0)	,-(sp)	; push it
	002202	012746 	000000G			        mov	#lun.in	,-(sp)	; push it
	002206	010605 				  mov	sp	,r5		; set up the argument list pointer
	002210	004767 	000000G			  jsr	pc	,prewind		; and go to the routine
	002214	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	002220	012605 				  mov	(sp)+	,r5		; /63/ restore r5
      6	002222	000207 				return				; 2(r0)=block 4(r0)=offset
      7
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 16
Preset an I/O channel to an exact block and offset ; /BBS/

      1
      2						.sbttl	Print index
      3
      4					;	passed:	 2(sp)	= sub-topic level at which index is expected
      5					;	assumption:	HLPBUF is already loaded with the current record
      6					;			and rmsidx is pointing to it
      7
      8					; /63/	modified to use an internal index which lives in KRTIDX.MAC
      9
     10	002224				hindex:	save	<r2,r4,r5>
	002224	010246 				 mov	r2	,-(sp)
	002226	010446 				 mov	r4	,-(sp)
	002230	010546 				 mov	r5	,-(sp)
     11	002232	010667 	000412'			mov	sp	,idxdmp		; flag that we have been here
     12	002236	005046 				clr	-(sp)			; allocate
     13	002240	005046 				clr	-(sp)			; some buffers
     14	002242	010605 				mov	sp	,r5		; and a pointer to them
     15	002244	116665 	000014 	000002 		movb	2+<5*2>(sp),2(r5)	; /BBS/ get the passed topic level
     16	002252	126527 	000002 	000061 		cmpb	2(r5)	,#'1		; is this the main menu today?
     17	002260	101002 				bhi	10$			; no, don't reposition the file
     18	002262	105067 	000004'			clrb	hlpbuf			; flag nothing's there
     19	002266				10$:	wrtall	#addinf			; /63/ "Additional information .."
	002266	012746 	000112'			mov	#addinf	,-(sp)		; pass the address
	002272	004767 	000000G			call	wrtall			; do it
     20	002276	012715 	000004 			mov	#4	,(r5)		; number of topic names per line
     21	002302	016704 	000616'			mov	rmsidx	,r4		; /BBS/ recover index into RMS data
     22
     23	002306	011401 			20$:	mov	@r4	,r1		; /BBS/ get pointer to next record
     24	002310	001455 				beq	90$			; /BBS/ nothing left
     25	002312	121165 	000002 			cmpb	@r1	,2(r5)		; /BBS/ check topic level
     26	002316	101047 				bhi	80$			; /BBS/ higher level, ignore it
     27	002320	103451 				blo	90$			; /BBS/ lower level, we need to exit
     28						; /BBS/ this displays topic names longer than 18. bytes ala VMS help
     29	002322	005201 				inc	r1			; skip the level number on the line
     30	002324	005201 				inc	r1			; then skip the space next to it
     31	002326				30$:	strlen	r1			; compute the padding to next column
	002326	010100 				mov	r1	,r0
	002330	004767 	000000G			call	l$len
     32	002334	010002 				mov	r0	,r2		; get copy of length
     33	002336	162702 	000022 		40$:	sub	#18.	,r2		; assume worst case 18. spaces needed
     34	002342	005402 				neg	r2			; we now have the number of spaces
     35	002344	003012 				bgt	50$			; that is, if it's a positive number
     36	002346	005402 				neg	r2			; preset for looping into next column
     37	002350	005315 				dec	(r5)			; is there a next column to overwrite?
     38	002352	001371 				bne	40$			; yes, pad to end of it
     39	002354					wrtall	#fill7			; init a newline to beginning column
	002354	012746 	000167'			mov	#fill7	,-(sp)		; pass the address
	002360	004767 	000000G			call	wrtall			; do it
     40	002364	012715 	000004 			mov	#4	,(r5)		; reset the counter now
     41	002370	000756 				br	30$			; and start fresh again..
     42	002372				50$:	wrtall	r1			; add on the current name
	002372	010146 				mov	r1	,-(sp)		; pass the address
	002374	004767 	000000G			call	wrtall			; do it
     43	002400	005315 				dec	(r5)			; is there room left for the next one?
     44	002402	001407 				beq	70$			; nope
     45	002404	012700 	000040 			mov	#space	,r0		; load a space
     46	002410	004767 	000000G		60$:	call	writ1ch			; dump it to TT
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 16-1
Print index

     47	002414					sob	r2	,60$		; until padded to length of 18. bytes
	002414	005302 				dec	r2
	002416	001374 				bne	60$
     48	002420	000406 				br	80$			; then back for more..
     49	002422				70$:	wrtall	#fill7			; init a newline to beginning column
	002422	012746 	000167'			mov	#fill7	,-(sp)		; pass the address
	002426	004767 	000000G			call	wrtall			; do it
     50	002432	012715 	000004 			mov	#4	,(r5)		; reset the counter now
     51	002436	062704 	000006 		80$:	add	#6	,r4		; bump to next entry
     52	002442	000721 				br	20$			; back for more
     53
     54	002444	022715 	000004 		90$:	cmp	#4	,(r5)		; is the current line blank?
     55	002450	001402 				beq	100$			; ya, skip the extra blank line
     56	002452					.newline			; no, do a newline
	002452	004767 	000000G			call	l$pcrlf
     57						; /BBS/ end of VMS-style hindex patch..
     58	002456	005000 			100$:	clr	r0			; success
     59	002460	010467 	000616'			mov	r4	,rmsidx		; /BBS/ save current RMS index pointer
     60	002464	022626 				cmp	(sp)+	,(sp)+		; pop some local buffers...
     61	002466					unsave	<r5,r4,r2>
	002466	012605 				 mov	(sp)+	,r5
	002470	012604 				 mov	(sp)+	,r4
	002472	012602 				 mov	(sp)+	,r2
     62	002474	012616 				mov	(sp)+	,(sp)		; move return address up
     63	002476	000207 				return
     64
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 17
Print index

      1
      2						.sbttl	Open the help file
      3
      4					; /BBS/ modified to check for correct version of KRTHLP.HLP..
      5
      6	002500	012703 	000006'		hlpopn:	mov	#rtname	,r3		; top of list of file specs to try
      7	002504	005713 			10$:	tst	@r3			; end of the list yet?
      8	002506	001524 				beq	40$			; yes, can't find the help file
      9	002510					calls	fparse	,<@r3,#srcnam>	; use Kermit's DK, not the os default
	002510	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002512	012746 	000000G			        mov	#srcnam	,-(sp)	; push it
	002516	011346 				        mov	@r3	,-(sp)	; push it
	002520	010605 				  mov	sp	,r5		; set up the argument list pointer
	002522	004767 	000000G			  jsr	pc	,fparse		; and go to the routine
	002526	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	002530	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     10	002532					calls	open	,<#srcnam,#lun.in,#text> ; try to open file
	002532	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002534	012746 	000000 			        mov	#text	,-(sp)	; push it
	002540	012746 	000000G			        mov	#lun.in	,-(sp)	; push it
	002544	012746 	000000G			        mov	#srcnam	,-(sp)	; push it
	002550	010605 				  mov	sp	,r5		; set up the argument list pointer
	002552	004767 	000000G			  jsr	pc	,open		; and go to the routine
	002556	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	002562	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     11	002564	005700 				tst	r0			; did it work?
     12	002566	001072 				bne	30$			; no
     13	002570	012704 	000004'			mov	#hlpbuf	,r4		; check for correct help file
     14	002574					calls	getrec	,<r4,#lun.in,#132.> ; /63/ read the first line of it
	002574	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002576	012746 	000204 			        mov	#132.	,-(sp)	; push it
	002602	012746 	000000G			        mov	#lun.in	,-(sp)	; push it
	002606	010446 				        mov	r4	,-(sp)	; push it
	002610	010605 				  mov	sp	,r5		; set up the argument list pointer
	002612	004767 	000000G			  jsr	pc	,getrec		; and go to the routine
	002616	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	002622	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     15	002624	005700 				tst	r0			; error?
     16	002626	001026 				bne	20$			; ya
     17	002630	105061 	000004'			clrb	hlpbuf(r1)		; no, ensure it's .asciz please
     18	002634	004767 	000000G			call	loahlp			; /63/ load overlay containing hident
     19	002640					strlen	#hident			; length of verifying string
	002640	012700 	000000G			mov	#hident	,r0
	002644	004767 	000000G			call	l$len
     20	002650					calls	instr	,<r4,r1,#hident,r0> ; check it
	002650	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002652	010046 				        mov	r0	,-(sp)	; push it
	002654	012746 	000000G			        mov	#hident	,-(sp)	; push it
	002660	010146 				        mov	r1	,-(sp)	; push it
	002662	010446 				        mov	r4	,-(sp)	; push it
	002664	010605 				  mov	sp	,r5		; set up the argument list pointer
	002666	004767 	000000G			  jsr	pc	,instr		; and go to the routine
	002672	062706 	000010 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	002676	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     21	002700	005700 				tst	r0			; a match?
     22	002702	001041 				bne	50$			; found it, file is ok
     23	002704				20$:	wrtall	#errhdr			; /63/ "?KRTHLP-W-"
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 17-1
Open the help file

	002704	012746 	000216'			mov	#errhdr	,-(sp)		; pass the address
	002710	004767 	000000G			call	wrtall			; do it
     24	002714					wrtall	#srcnam			; the bad version's file name
	002714	012746 	000000G			mov	#srcnam	,-(sp)		; pass the address
	002720	004767 	000000G			call	wrtall			; do it
     25	002724					wrtall	#errver			; /63/ " is an incorrect version",cr
	002724	012746 	000307'			mov	#errver	,-(sp)		; pass the address
	002730	004767 	000000G			call	wrtall			; do it
     26	002734					calls	close	,<#lun.in>	; dump the channel to it
	002734	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002736	012746 	000000G			  mov	#lun.in	,-(sp)		; doing it thusly generates less code
	002742	010605 				  mov	sp	,r5		; set pointer to argument list
	002744	004767 	000000G			  jsr	pc	,close		; call the subroutine
	002750	005726 				  tst	(sp)+			; pop parameter list from stack
	002752	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     27	002754	005723 			30$:	tst	(r3)+			; prep for the
     28	002756	000652 				br	10$			; next one
     29
     30	002760				40$:	wrtall	#errhdr			; /63/ "?KRTHLP-W-"
	002760	012746 	000216'			mov	#errhdr	,-(sp)		; pass the address
	002764	004767 	000000G			call	wrtall			; do it
     31	002770					wrtall	#errmis			; /63/ "Can't find KRTHLP.HLP ..",cr
	002770	012746 	000231'			mov	#errmis	,-(sp)		; pass the address
	002774	004767 	000000G			call	wrtall			; do it
     32	003000	012700 	000000G			mov	#er$fnf	,r0		; return file not found error
     33	003004	000403 				br	60$
     34	003006	010667 	000000G		50$:	mov	sp	,inopn		; flag file is open so PF2 will know
     35	003012	005000 				clr	r0			; success
     36	003014	000207 			60$:	return
     37
     38		000001 				.end
KRTHLP	HELP for Kermit-11	MACRO V05.03b  00:01  Page 17-2
Symbol table

ADDINF  000112R     003	C.CRLF= 000004   	HPRINT  001400R     002	PAR$MA  000003   	STRCPY= ****** GX
ALSIZE= 001000   	C.LCUC= 000040   	HTOPIC  000212R     004	PAR$NO  000000   	SUBWIL  001120R     004
ARGBUF= ****** GX	C.LSPA= 000010   	IDXDMP  000412R     004	PAR$OD  000001   	SUB.0   000000R     003
AT.ALL  000177   	C.SSPA= 000020   	INOPN = ****** GX	PAR$SP  000004   	SUB.2   000620R     004
AT.CDT  000001   	C.TSPA= 000200   	INSTR = ****** GX	PRBUFF  000414R     004	SUB.3   000720R     004
AT.INF  000002   	DBLDAS  000212R     003	JSW   = 000044   	PRESET  002164R     002	SUB.4   001020R     004
AT.LEN  000004   	DECNAT  000002   	KRTINC= 000001   	PREWIN= ****** GX	SUCCS$= 000001
AT.ON   100000   	DEL   = 000177   	LF    = 000012   	PRMPTD  000614R     004	TAB   = 000011
AT.PRO  000010   	DIRER$= ****** GX	LN$CNT= 000003   	PTOPIC  000433R     003	TERMIN  177777
AT.SYS  000020   	DOT   = 000056   	LN$MAX= 000120   	P.CAPA= 000011   	TEXT    000000
AT.TYP  000040   	ERBFSI= 000170   	LOAHLP= ****** GX	P.CHKT= 000007   	TILDE = 000176
AT.XLE  000100   	ERRBYT= 000052   	LOG$AL= 000003   	P.EOL = 000004   	TOPBUF  001142R     004
BACKLE  000000R     004	ERRHDR  000216R     003	LOG$CO= 000002   	P.MXL1= 000013   	TOPICS  001122R     004
BACKUP  000002R     004	ERRMIS  000231R     003	LOG$DE= 000020   	P.MXL2= 000014   	TOPLEV  001342R     004
BELL  = 000007   	ERROR$= 000004   	LOG$IO= 000010   	P.NPAD= 000002   	TTBUFF  001344R     004
BINARY  000001   	ERRTXT= ****** GX	LOG$ON= 040000   	P.PADC= 000003   	TTY   = 000001
BS    = 000010   	ERRVER  000307R     003	LOG$OP= 100000   	P.QBIN= 000006   	UPCASE= ****** GX
BUGTXT  000201R     003	ER$FNF= ****** GX	LOG$PA= 000001   	P.QCTL= 000005   	USERRB= 000053
CAPA.A= 000010   	ER$LBY= ****** GX	LOG$RP= 000004   	P.REPT= 000010   	VT100 = 000002
CAPA.L= 000002   	ESC   = 000033   	LUN.IN= ****** GX	P.SPSI= 000000   	VT200 = 000003
CAPA.S= 000004   	FATAL$= 000020   	LUN.OU= ****** GX	P.TIME= 000001   	WARN$ = 000002
CLOSE = ****** GX	FF    = 000014   	L$LEN = ****** GX	P.VEND= 000017   	WILD    001552R     004
COMMA = 000054   	FILL    000177R     003	L$PCRL= ****** GX	P.WIND= 000012   	WRIT1C= ****** GX
CON$ES= 000034   	FILL7   000167R     003	MAXLNG= 001130   	READCM= ****** GX	WRTALL= ****** GX
CR    = 000015   	FPARSE= ****** GX	MAXPAK  000136   	RMSIDX  000616R     004	XOFF  = 000023
CREATE= ****** GX	GETREC= ****** GX	NOHELP  000360R     003	RTNAME  000006R     003	XON   = 000021
CTRL$N= 000016   	HFIND   001002R     002	NONEIS= 000001   	SCOLON= 000073   	XPRINT= ****** GX
CTRL$O= 000017   	HIDENT= ****** GX	NOSCOP= 000000   	SEVER$= 000010   	$ALLSI= 001144
CVTARG= 000274   	HINDEX  002224R     002	OPEN  = ****** GX	SOH   = 000001   	$$    = 000001
CVT$$ = ****** GX	HLPBUF  000004R     004	OUTOPN= ****** GX	SPACE = 000040   	$$1   = 000001
C$BUG   000076RG    002	HLPOPN  002500R     002	PARSE   000706R     002	SRCNAM= ****** GX	$$2   = 000000
C$HELP  000112RG    002	HLP2LP  000342R     003	PAR$EV  000002   	STRCAT= ****** GX	$$5   = 000027
C$PHLP  000000RG    002

. ABS.	000000    000	(RW,I,GBL,ABS,OVR)
      	000000    001	(RW,I,LCL,REL,CON)
$CODE 	003016    002	(RO,I,LCL,REL,CON)
$PDATA	000464    003	(RO,D,LCL,REL,CON)
$RWDAT	001554    004	(RW,D,LCL,REL,CON)
Errors detected:  0

*** Assembler statistics


Work  file  reads: 0
Work  file writes: 0
Size of work file: 12485 Words  ( 49 Pages)
Size of core pool: 12544 Words  ( 49 Pages)
Operating  system: RT-11

Elapsed time: 00:00:00.36
KRTHLP,KRTHLP=KRTNHD,KRTHLP
