.MAIN.	MACRO V05.03b  00:01
Table of contents

    1-   1	KRTNHD	EIS macros for a non-EIS CPU
    4-   1	KRTMAC	Various handy constants and macros
    6-   2	Utility macros
    8-   2	Local macros
    9-   2	Local data
   10-   3	SET MODEM-TYPE		; /BBS/ almost 100% new..
   11-   2	SET DTR and HANGUP
   12-   2	The real work of SET MODEM
   13-   2	The real work of SET DTR
   14-   2	The REDIAL command	; /BBS/ slightly modified..
   15-   2	The DIAL command	; /BBS/ substantially changed..
   16-   2	Reset the modem		; /BBS/ all new
   17-   2	Restore last set speed	; /BBS/ added..
   18-   2	Find location of a modem's data structure
   19-   2	Find a defined phone number
   20-   2	Wake up (init) modem	; /BBS/ almost 100% new..
   21-   2	Dial the number		; /BBS/ moderately modified..
   22-   2	Get final result of dialing	; /BBS/ somewhat modified
   23-   2	Check modem's response	; /39/ 4-DEC-1985, Brian Nelson
   24-   2	Format dial string
   25-   2	Wait for a response	; /BBS/ moderately revised..
   26-   2	Eat junk from modem
   27-   2	Send a string to the modem
   28-   2	SHOW MODEM, SHOW DIAL	; /BBS/ heavily hacked
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 1
KRTNHD	EIS macros for a non-EIS CPU

      1						.sbttl	KRTNHD	EIS macros for a non-EIS CPU
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					; /62/	27-Jul-93  Billy Youdelman  V03.62
      6					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
      7					;
      8					;	Assemble Kermit-11 modules with this for use on a
      9					;	non-EIS CPU.  This calls p$mul and p$div, assembly
     10					;	of which into KRTSUB depends on defining "NONEIS".
     11					;	KRTASM.NON assembles everything for non-EIS use.
     12
     13					;	10-Apr-84  09:37:15  Brian Nelson
     14
     15		000001 				NONEIS	=	1		; force p$mul,p$div into KRTSUB.MAC
     16
     17						.macro	mul	src,reg		; single precision
     18						.ntype	$$	,reg		; save number of input register
     19						mov	src	,-(sp)		; pass multiplier to p$mul
     20						mov	reg	,-(sp)		; pass multiplicand too
     21						call	p$mul			; multiply, returns a 16-bit product
     22						.iif eq <$$-1>	mov	(sp)+	,r1	; ..if input register was r1
     23						.iif eq <$$-3>	mov	(sp)+	,r3	; ditto if r3
     24						.iif eq <$$-5>	mov	(sp)+	,r5	; ditto if r5
     25						.iif ne <<$$+1>&1> .error      <; bad dst reg for MUL macro>
     26						.endm	mul
     27
     28						.macro	div	src,reg		; /BBS/ made this double precision
     29						.ntype	$$	,reg		; # of register with dividend hi word
     30						mov	src	,-(sp)		; divisor
     31						.if eq $$			; hi word is in r0
     32						mov	r1	,-(sp)		; dividend low word
     33						mov	r0	,-(sp)		; dividend high word
     34						.endc
     35						.if eq $$-2			; hi word is in r2
     36						mov	r3	,-(sp)
     37						mov	r2	,-(sp)
     38						.endc
     39						.if eq $$-4			; hi word is in r4
     40						mov	r5	,-(sp)
     41						mov	r4	,-(sp)
     42						.endc
     43						call	p$div			; divide
     44						.if eq $$			; using r0..
     45						mov	(sp)+	,r1		; remainder
     46						mov	(sp)+	,r0		; this only returns a 16-bit quotient
     47						.endc
     48						.if eq $$-2			; using r2..
     49						mov	(sp)+	,r3
     50						mov	(sp)+	,r2
     51						.endc
     52						.if eq $$-4			; using r4..
     53						mov	(sp)+	,r5
     54						mov	(sp)+	,r4
     55						.endc
     56						.endm	div
     57
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 1-1
KRTNHD	EIS macros for a non-EIS CPU

     58						.macro	sob	reg,dst		; subtract one and branch if not zero
     59						dec	reg
     60						bne	dst
     61						.endm	sob
     62
     63						.macro	ash	amount,reg	; arithmetic shift
     64						.ntype	$$$0	,amount
     65						.iif ne <27-$$$0> .error       <; must be auto pc for ASH macro>
     66						$$type	= 1			; assume left shift
     67						$$size	= 0			; how many ASLs or ASRs to generate
     68						  .irpc	$a ,<amount>		; parse the first argument
     69						  $c	= ''$a			; get the character as a literal
     70						  .iif eq <$c - '-> $$type = -1	; if a minus sign then assume right
     71						  .iif eq <$c - '.> .error     <; only use octal in ASH macro please>
     72						  .iif eq <$c - '^> .error     <; only use octal in ASH macro please>
     73						  $c	= $c - '0		; check for a digit now
     74						    .if ge $c			; perhaps a digit
     75						      .if le $c-7		; got a digit
     76						      $$size = <$$size*10>+$c	; add into accumulator
     77						      .endc
     78						    .endc
     79						  .endr
     80						.rept	$$size
     81						.iif gt <$$type>  asl	reg
     82						.iif lt <$$type>  asr	reg
     83						.endr
     84						.endm
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 2
KRTNHD	EIS macros for a non-EIS CPU

      1						.title	KRTDIA	Dial command and related items
      2						.ident	"V03.63"
      3
      4					; /63/  27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	use opentt in place of ttyini to set linksts flag
      7					;	move the modem definitions to a separate module KRTMDM.MAC
      8					;	SET$DTR and SET$MODEM back here from KRTDSP
      9
     10					; /62/	27-Jul-93  Billy Youdelman  V03.62
     11					;
     12					;	add support for call back modems, SET DIAL/PHONE [NO]ANSWER
     13					;
     14					;	add a one-tick pacing delay in DODIAL's loop at 50$ (when the modem
     15					;	doesn't echo commands) to match what was done for echoing modems
     16					;
     17					;	fix SHO MODEM for changes to SET DIAL [NO]ECHO and [NO]INIT-ONCE
     18					;	add initiate-prompt, dial-ack, confirm-ack, [no]binary-response
     19					;
     20					;	added x.result (default "Hayes" xmode) and time.settle defaults,
     21					;	and in "Hayes" and Telebit modem definitions
     22					;
     23					;	if DCD is high when exiting program, hang up modem
     24					;	add support for 38.4kb
     25					;	add Telebit T3000 modem def, needs KM handler and SET FLOW-CONTROL RTS
     26					;
     27					;	double the settle-time value for the wait after dropping DTR,
     28					;	as some modems (like the T3000) need more time to recover
     29
     30					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     31					;
     32					;	set$mo now won't write bad modem name into modem:
     33					;	if DIAL/REDIAL succeeds jump to CONNECT automatically
     34					;	set linksts when dialing so ^C abort will catch correct ttname
     35					;	findmodem now does not try to process an empty string in modem:
     36					;	added c$idle, call to reset modem to idle (answer) mode
     37					;	findmodem/findnumber will match on partial input string
     38					;	added %X format effector for setting Hayes extended response mode
     39					;	added Telebit T2500 modem definitions
     40					;
     41					;	redial loop moved to c$dial, runs faster without initializing
     42					;	the modem's lun every pass thru the loop, reduces cpu usage too
     43					;
     44					;	load buffer with defmsg after displaying RING, to not overwrite
     45					;	the default message with call status stuff
     46					;
     47					;	if DIAL can't translate an alias, say so then die (instead of
     48					;	prompting to continue with an empty number buffer)
     49					;
     50					;	added xredial flag word, for keeping return path straight when
     51					;	connecting after a successful REDIAL. speed up redial process for
     52					;	modems which define init.once by not initting before every retry.
     53					;	init.once and mready (status flag) were added to support all this..
     54					;
     55					;	while waiting for a response after dialing modem, check for
     56					;	input from keyboard, allowing an easy abort
     57					;
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 2-1
KRTNHD	EIS macros for a non-EIS CPU

     58					;	.default patched to get/set handler speed from modem response,
     59					;	old speed is saved and restored, unless set different after..
     60					;	Hayes definition completed and moved to it.  this also renders
     61					;	Hayes responses displayable via SHO MODEM.
     62					;
     63					;	diatmo from SET DIAL TIME-OUT gets written into dial.time(r4)
     64					;	when either c$dial or sho$dial is called.  it's now usable with
     65					;	any modem type (not just user-defined) by setting the modem's
     66					;	internal timer to the max (ATS7=255 etc) then letting Kermit's
     67					;	timer take action first.
     68					;
     69					;	modified waitfor to test for keyboard input, allowing a "strike
     70					;	any char" abort during dialing, now including the init string.
     71					;	DTR is dropped to ensure the modem will actually abort the call.
     72					;
     73					;	SHO MODEM expanded to display everything
     74					;	result message must match from 1st byte to avoid embedded strings
     75					;	save modem init status to drop unnecessary inits
     76					;	SET MODEM now inits same, if a line (and speed) have been set
     77					;	echo everything from modem (if it echoes) during DIAL
     78					;	add CONNECT/nnnn for Hayes to alter DTE speed w/TSX and CL
     79					;	add Concord Data Systems 224 Auto-dial modem
     80					;
     81					;	moved SET DTR code here, and reinit modem after DTR drop if one
     82					;	was on-line before it
     83
     84					;	Copyright 1985,1986 Change Software, Inc.
     85					;
     86					;	18-Oct-85  20:06:09 Brian Nelson
     87					;
     88					;	04-Dec-85  11:22:32 BDN	 Add optional linked list structure to
     89					;				 define modem responses, will be useful
     90					;				 when adding a SET DIAL command
     91					;	09-Jan-86  17:48:17 RTM  Added support for the RIXON Intelligent
     92					;				 auto-dial modem (R212A) (edit RTM01)
     93					;	13-Feb-86  10:10:08 BDN	 Put the DF112 and DF224 responses into
     94					;				 linked lists
     95					;	23-Sep-86  14:10:30 BDN	 Vadic 4224 modems
     96					;	23-Sep-86  14:10:42 BDN	 Added format effector %M for pulse/tone
     97					;				 if a SET PHONE PULSE/TONE was done
     98					;				 Added %B for "blind" dialing, enabled if
     99					;				 SET PHONE BLIND
    100					;	30-Sep-86  13:05:53 BDN	 Added CTS2424, Also SHO DIAL
    101					;	09-Feb-89  00:00:00 JCH  Complete definition of DF224 modem
    102
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 3
KRTNHD	EIS macros for a non-EIS CPU

      1
      2						.include "IN:KRTMAC.MAC"
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 4
KRTMAC	Various handy constants and macros

      1						.sbttl	KRTMAC	Various handy constants and macros
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	add support for SET ATTRIBUTES
      7					;	add flag to suspend logging to a disk file
      8					;	make $LN$MAX 132. bytes for EIS assembly
      9					;	pulled message macro, no longer used..
     10
     11					; /62/	27-Jul-93  Billy Youdelman  V03.62
     12					;
     13					;	move dispatch macro to KRTSER
     14					;	move erbfsiz here from KRTPAK
     15					;	condense logging (debug) modes
     16					;	increase efficiency of incm64 macro
     17					;	increase MAXLNG (long-packet size) to 1920.
     18					;	reduce MAXLNG to 600. for NONEIS assembly, so pgm loads under FB..
     19					;	ditto for ALSIZE (phone # buffer) and LN$CNT (SL # of lines saved)
     20
     21					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     22					;
     23					;	modified message macro to call .newline instead of saving CR/LF
     24					;	and null for each new line, knocking 1042. bytes off the size
     25					;	of this version..  also changed ".print" emulation to wrtall,
     26					;	for a similar savings in compiled program size.
     27					;
     28					;	dump raw I/O logging from log$al (SET DEB ALL) - too confusing
     29					;	also pulled log$rp out and made it a completely separate item..
     30					;
     31					;	added a couple upper case macros
     32
     33					;	include file for Kermit-11
     34					;
     35					;	Brian Nelson  01-Dec-83  13:56:12
     36
     37						.NLIST	BEX
     38						.LIST	MEB			; /62/
     39
     40		000001 				KRTINC	=	1		; for .include error checking
     41
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 5
KRTMAC	Various handy constants and macros

      1
      2	000000					.psect	$code	,ro,i,lcl,rel,con ; psect ordering..
      3	000000					.psect	$pdata	,ro,d,lcl,rel,con
      4
      5					;	various ascii chars
      6		000001 				SOH	=   1		; default packet start of header
      7		000007 				BELL	=   7		; beep
      8		000010 				BS	=  10		; backspace
      9		000011 				TAB	=  11		; tab
     10		000012 				LF	=  12		; line feed
     11		000014 				FF	=  14		; form feed
     12		000015 				CR	=  15		; carriage return
     13		000016 				CTRL$N	=  16		; ^N VT-100 line drawing on
     14		000017 				CTRL$O	=  17		; ^O VT-100 line drawing off
     15		000021 				XON	=  'Q&37	; ^Q
     16		000023 				XOFF	=  'S&37	; ^S
     17		000033 				ESC	=  33		; escape
     18		000040 				SPACE	=  40
     19		000054 				COMMA	=  54
     20		000056 				DOT	=  56		; /63/
     21		000073 				SCOLON	=  73		; /63/
     22		000176 				TILDE	= 176		; /63/
     23		000177 				DEL	= 177		; delete
     24
     25					;	system data locations
     26		000044 				JSW	= 44		; job status word
     27		000052 				ERRBYT	= 52		; emt error byte
     28		000053 				USERRB	= 53		; /62/ user error byte
     29		000001 					SUCCS$	=  1	; no error
     30		000002 					WARN$	=  2	; warning
     31		000004 					ERROR$	=  4	; error
     32		000010 					SEVER$	= 10	; sever error
     33		000020 					FATAL$	= 20	; fatal error
     34
     35					;	byte offsets into SINIT parameter vector
     36		000000 				P.SPSIZ	= 0		; set packet length
     37		000001 				P.TIME	= 1		; time-out
     38		000002 				P.NPAD	= 2		; number of pad chars
     39		000003 				P.PADC	= 3		; the pad character
     40		000004 				P.EOL	= 4		; eol char
     41		000005 				P.QCTL	= 5		; control char quoting
     42		000006 				P.QBIN	= 6		; 8-bit quote
     43		000007 				P.CHKT	= 7		; checksum type
     44		000010 				P.REPT	= 10		; repeated character prefix
     45		000011 				P.CAPAS	= 11		; capability bitmask
     46		000010 					CAPA.A	= 10	; attribute handling
     47		000002 					CAPA.L	= 2	; /42/ long packets
     48		000004 					CAPA.S	= 4	; /42/ sliding windows
     49		000012 				P.WINDS	= 12		; /43/ window size, # of packets
     50		000013 				P.MXL1	= 13		; /43/ high order of long packet size
     51		000014 				P.MXL2	= 14		; /43/ low order of long packet size
     52		000017 				P.VEND	= 17		; end of parameter vector
     53
     54					; /62/	bits in doattr (file attribute processing)
     55		000001 				AT.CDT	=: 1		; create date
     56		000002 				AT.INF	=: 2		; /63/ system specific info
     57		000004 				AT.LEN	=: 4		; length
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 5-1
KRTMAC	Various handy constants and macros

     58		000010 				AT.PRO	=: 10		; file protection
     59		000020 				AT.SYS	=: 20		; system ID
     60		000040 				AT.TYP	=: 40		; file type
     61		000100 				AT.XLE	=: 100		; exact length in bytes
     62		100000 				AT.ON	=: 100000	; /63/ do attribute processing
     63		000177 				AT.ALL	=: AT.CDT!AT.INF!AT.LEN!AT.PRO!AT.SYS!AT.TYP!AT.XLE
     64
     65					;	bits in trace (debug status word)
     66		000001 				LOG$PA	= 1		; log all packets
     67		000002 				LOG$CO	= 2		; /62/ CONNECT logging to disk
     68		000004 				LOG$RP	= 4		; /62/ rpack chars to TT
     69		000010 				LOG$IO	= 10		; /62/ everything received or sent
     70		000020 				LOG$DE	= 20		; /62/ debugging to TT
     71		040000 				LOG$ON	= 40000		; /63/ set to write to disk, clear to suspend
     72		100000 				LOG$OP	= 100000	; logfile is open
     73		000003 				LOG$AL	= LOG$PA!LOG$CO	; /62/ ALL
     74
     75					;	parity options
     76		000000 				PAR$NO	=: 0		; none
     77		000001 				PAR$OD	=: 1		; odd
     78		000002 				PAR$EV	=: 2		; even
     79		000003 				PAR$MA	=: 3		; mark
     80		000004 				PAR$SP	=: 4		; space
     81
     82					;	file types
     83		177777 				TERMINAL=: -1		; file to term ala xreply, not to disk
     84		000000 				TEXT	=:  0		; normal ascii text files
     85		000001 				BINARY	=:  1		; image mode
     86		000002 				DECNAT	=:  2		; /52/ 8-bit text files
     87
     88					;	terminal types
     89		000000 				NOSCOPE	= 0		; /BBS/ hard copy terminal
     90		000001 				TTY	= 1		; a dumb tube terminal
     91		000002 				VT100	= 2		; itself
     92		000003 				VT200	= 3		; ditto..
     93
     94					;	supported CVT$$ cvt_bit_pattern bits
     95		000004 				C.CRLF	= 4		; discard CR LF FF ESC
     96		000010 				C.LSPA	= 10		; discard leading spaces and tabs
     97		000020 				C.SSPA	= 20		; reduce spaces and tabs to a single space
     98		000040 				C.LCUC	= 40		; lower case to upper case
     99		000200 				C.TSPA	= 200		; discard trailing spaces and tabs
    100
    101		000034 				CON$ESC	=  '\-100	; default CONNECT escape char
    102		000170 				ERBFSIZ	=  120.		; /62/ error msg text buff size
    103		000136 				MAXPAK	=:  94.		; /63/ max_packet_length - max_checksum_length
    104
    105						.if df	NONEIS		; /62/ using NONEIS for convenience..
    106		001000 				ALSIZE	=   1000	; /63/ bufsiz for SET DIAL/PHO NUM
    107		000003 				LN$CNT	=      3.	; /62/ save/recall 3. commands
    108		000120 				LN$MAX	=     80.	; /63/ max command line length
    109		001130 				MAXLNG	=    600.	; /63/ so image is small enuff to run
    110						.iff
    111						ALSIZE	=   2000	; /62/ bufsiz for SET DIAL/PHO NUM
    112						LN$CNT	=     10.	; /63/ save/recall 10. commands
    113						LN$MAX	=    132.	; /63/ max command line length
    114						MAXLNG	=   1920.	; /63/ use max long-packet buff size
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 5-2
KRTMAC	Various handy constants and macros

    115						.endc
    116		001144 				$ALLSIZ	= <MAXLNG+14>&177776 ; /62/ make it this for safety
    117
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 6
KRTMAC	Various handy constants and macros

      1
      2						.sbttl	Utility macros
      3
      4						.macro	.br to		; /63/ added
      5						.if df	to
      6						.if ne	to-.
      7						.error	<; not at location to;>
      8						.endc
      9						.endc
     10						.endm	.br
     11
     12						.macro	.chksp	arg
     13						.ntype	$$5	,arg
     14						.iif eq <<$$5&7>-6> .error arg <; Illegal use of SP (r6) in call>
     15						.endm	.chksp
     16
     17						.macro	calls	name	,arglst
     18					;	subroutine call with arguments passed in an area pointed to by r5
     19					;	(as with F4 and BP2).  all args are pushed onto the stack in the
     20					;	order specified.  r5 points to the sp before the call and is saved
     21					;	and restored.
     22						$$ = 0				; init # of args count
     23						  .irp x ,<arglst>		; count up # of args passed
     24						  $$ = $$+1			; one at a time
     25						  .endr				; got it
     26						.if eq $$			; no args present?
     27						jsr	pc	,name		; if so, substitute a simple call
     28						.iff				; at least one arg in <arglst>
     29						mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
     30						  .if eq $$-1			; is it one or more than one arg?
     31						  .chksp	arglst		; one arg, check for legal SP modes
     32						  mov	arglst	,-(sp)		; doing it thusly generates less code
     33						  mov	sp	,r5		; set pointer to argument list
     34						  jsr	pc	,name		; call the subroutine
     35						  tst	(sp)+			; pop parameter list from stack
     36						  mov	(sp)+	,r5		; /63/ restore r5
     37						  .iff				; arg_count > 1
     38						  $$2 = $$			; extract the args in
     39						    .rept	$$		; reverse order so that
     40						    $$1 = 0			; we might save a little
     41						      .irp x ,<arglst>		; core (four words)
     42						      $$1 = $$1+1		; scan the arg list until we come to
     43						        .if eq $$2-$$1		; the last one before one we just did
     44						        .chksp	x		; check for SP addressing mode
     45						        mov	x	,-(sp)	; push it
     46						        .mexit			; and exit the .irp
     47						        .endc
     48						      .endr
     49						    $$2 = $$2-1			; backwards to previous arg
     50						    .endr
     51						  mov	sp	,r5		; set up the argument list pointer
     52						  jsr	pc	,name		; and go to the routine
     53						  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
     54						  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
     55						  mov	(sp)+	,r5		; /63/ restore r5
     56						  .endc
     57						.endc
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 6-1
Utility macros

     58						.endm	calls
     59
     60						.macro	ctl	src ,dst
     61						clr	-(sp)
     62						bisb	src	,@sp
     63						call	l$xor
     64						movb	(sp)+	,dst
     65						.endm	ctl
     66
     67						.macro	copyz	from ,to ,maxlen
     68						.if  b	<maxlen>
     69						clr	-(sp)
     70						.iff
     71						mov	maxlen	,-(sp)
     72						.endc
     73						mov	from	,-(sp)
     74						mov	to	,-(sp)
     75						call	copyz$
     76						.endm	copyz
     77
     78						.macro	deccvt	val ,buf ,width
     79						mov	r5	,-(sp)
     80						.if  b	<width>
     81						clr	-(sp)
     82						.iff
     83						mov	width	,-(sp)
     84						.endc
     85						mov	val	,-(sp)
     86						mov	buf	,-(sp)
     87						mov	sp	,r5
     88						call	l$cvtnum
     89						add	#6	,sp
     90						mov	(sp)+	,r5
     91						.endm	deccvt
     92
     93						.macro	decout	val
     94						mov	r5	,-(sp)
     95						mov	val	,-(sp)		; /62/ l$wrdec pops this buffer
     96						mov	sp	,r5
     97						call	l$wrdec
     98						mov	(sp)+	,r5
     99						.endm	decout
    100
    101						.macro	direrr	val
    102						mov	val	,-(sp)
    103						call	direr$
    104						.endm	direrr
    105
    106						.macro	incm64	val
    107						inc	val
    108						bic	#^c<77>	,val		; /62/ faster
    109						.endm	incm64
    110
    111						.macro	indexm	reg		; check for auto increment/decrement
    112						.ntype	$$$0	,reg		; modes for macros that can't have..
    113						.if  ne	$$$0-27			; always allow pc autoincrement
    114						$$$0 =	<$$$0&177770>/10	; ..these modes in their arg list
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 6-2
Utility macros

    115						.ift				; get the mode into 0..7
    116						  .if  ge $$$0-2		; if mode >=2 and mode <=5 then error
    117						  .iif ge <5-$$$0> .error      <; Can't use auto inc/dec mode here>
    118						  .endc
    119						.endc
    120						.endm	indexm
    121
    122						.macro	ixor	reg ,dst
    123					;	get around the mode restrictions for the hardware XOR instruction
    124					;	and fix for RT-11 systems that don't have the EIS chip option
    125						.chksp	reg			; can't allow sp args
    126						.chksp	dst			; in either register
    127						indexm	reg			; check for allowed
    128						indexm	dst			; addressing mode
    129						mov	reg	,-(sp)		; it's much simpler to do this
    130						bic	dst	,@sp		; for all RT-11 systems rather
    131						bic	reg	,dst		; than to be selective
    132						bis	(sp)+	,dst		; done
    133						.endm	ixor
    134
    135						.macro	.newline		; print CR/LF on TT
    136						call	l$pcrlf
    137						.endm	.newline
    138
    139						.macro	octout	val
    140						calls	l$wroct	,<val>
    141						.endm	octout
    142
    143						.macro	prsbuf	dst
    144						mov	dst	,r0
    145						call	prsarg
    146						.endm	prsbuf
    147
    148						.macro	rpack	len.a ,pakn.a ,msg.a ,max.len	; /62/
    149						sub	#10	,sp
    150						mov	sp	,r1
    151						calls	rpack$	,<msg.a,r1,max.len>
    152						mov	(r1)+	,len.a
    153						mov	(r1)+	,pakn.a
    154						mov	@r1	,r1
    155						add	#10	,sp
    156						.endm	rpack
    157
    158						.macro	save	list
    159						.if  b	<list>
    160						 save	<r0,r1,r2,r3,r4,r5>
    161						.iff
    162						.irp	x ,<list>
    163						 mov	x	,-(sp)
    164						.endr
    165						.endc
    166						.endm	save
    167
    168						.macro	scan	ch ,str
    169						mov	str	,-(sp)
    170						clr	-(sp)
    171						bisb	ch	,@sp
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 6-3
Utility macros

    172						call	scanch
    173						.endm	scan
    174
    175						.macro	setpar	src ,dst
    176						movb	src	,-(sp)
    177						call	dopari
    178						movb	(sp)+	,dst
    179						.endm	setpar
    180
    181						.macro	spack	type ,pnum ,len ,msg
    182						.if  b	<len>
    183						.iif nb	<msg>	.error	<; bad call to SPACK macro>
    184						calls	spack$	,<type,pnum,#0,#null>
    185						.iff
    186						calls	spack$	,<type,pnum,len,msg>
    187						.endc
    188						.endm	spack
    189
    190						.macro	strcat	dst ,src
    191						mov	src	,-(sp)
    192						mov	dst	,-(sp)
    193						jsr	pc	,strcat
    194						.endm	strcat
    195
    196						.macro	strcpy	dst ,src
    197						mov	src	,-(sp)
    198						mov	dst	,-(sp)
    199						jsr	pc	,strcpy
    200						.endm	strcpy
    201
    202						.macro	strlen	string
    203						mov	string	,r0
    204						call	l$len
    205						.endm	strlen
    206
    207						.macro	textsrc	text
    208						.if  b	<text>
    209						clr	getcroutine		; /62/ reset to file I/O
    210						clr	tgetaddr
    211						.iff
    212						mov	#tgetcr0,getcroutine
    213						mov	text	,tgetaddr
    214						.endc
    215						.endm	textsrc
    216
    217						.macro	tochar	src ,dst
    218						clr	-(sp)
    219						bisb	src	,@sp
    220						add	#40	,@sp
    221						movb	(sp)+	,dst
    222						.endm	tochar
    223
    224						.macro	unchar	src ,dst
    225						clr	-(sp)
    226						bisb	src	,@sp
    227						sub	#40	,@sp
    228						movb	(sp)+	,dst
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 6-4
Utility macros

    229						.endm	unchar
    230
    231						.macro	unsave	list
    232						.if b <list>
    233						unsave	<r5,r4,r3,r2,r1,r0>
    234						.iff
    235						.irp	x ,<list>
    236						 mov	(sp)+	,x
    237						.endr
    238						.endc
    239						.endm	unsave
    240
    241						.macro	upcase	s		; /BBS/ added ..
    242						mov	s	,r0
    243						call	upcase			; /BBS/ upcase until null terminator
    244						.endm	upcase
    245
    246						.macro	upone	s		; /BBS/ added ..
    247						mov	s	,r0
    248						call	upone			; /BBS/ upcase only to next delimiter
    249						.endm	upone
    250
    251						.macro	wrtall	arg		; IO.WAL for an .asciz string
    252						mov	arg	,-(sp)		; pass the address
    253						call	wrtall			; do it
    254						.endm	wrtall
    255
    256						.macro	xor	reg ,dst
    257						ixor	reg	,dst
    258						.endm	xor
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 7
Utility macros

      1						.iif ndf  KRTINC  .error	<; .include for IN:KRTMAC.MAC failed>
      2
      3
      4					; /BBS/	This is used by SHOW MODEM to format the display of response messages
      5					; and actions to them.  It's the column at which the actions begin and may be
      6					; increased if longer response strings must accommodated.
      7
      8		000022 				COL.ACT	  =	18.
      9
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 8
Utility macros

      1
      2						.sbttl	Local macros
      3
      4		000000 				$$TRIP	= 0			; /63/ init trip counter
      5
      6						.macro	des  type ,offset ,title
      7						.save				; /63/
      8						.psect	$pdata			; /63/
      9						.if  b	<type>
     10						.byte	0	,0
     11						.even				; /63/ do this here, once is enough..
     12						$$trip=0			; /63/ reset for possible future use
     13						.iff
     14						  .if eq $$trip			; /63/ if at the first list entry
     15					deslist:				; /63/ insert the label for the list
     16						  .endc
     17						  $$trip=1			; /63/ not the first entry any more
     18						.byte	type	,offset		; type_0=integer, type_1=string
     19						.asciz	@title@			; /62/ type_2=on/off
     20						.endc
     21						.restore			; /63/
     22						.endm	des
     23
     24						.macro	ttgetc	wait		; get one char from the link device
     25						.if  b	<wait>			; wait value is in seconds
     26						calls	xbinread,<#1>		; /62/ this waits up to one second
     27						.iff
     28						calls	xbinread,<wait>
     29						.endc
     30						.endm	ttgetc
     31
     32						.macro	ttputc	c		; send one char to the link device
     33						clr	-(sp)			; create a one word buffer
     34						bisb	c	,(sp)		; stuff in byte sans sign extension
     35						mov	sp	,r0		; point to buffer
     36						calls	binwri	,<r0,#1>	; send it
     37						tst	(sp)+			; pop buffer
     38						.endm	ttputc
     39
     40						.macro	ttputs	s		; send a string to the link device
     41						mov	r1	,-(sp)		; a one word buffer
     42						mov	s	,r1		; pass string location to do.put
     43						call	do.put			; /63/ send it
     44						mov	(sp)+	,r1		; pop buffer
     45						.endm	ttputstr
     46
     47						.macro	waitfor  s ,time ,fail	; wait for a response from modem
     48						.if  b	<time>			; time value is in seconds
     49						clr	-(sp)			; time buffer
     50						inc	@sp			; /BBS/ default wait is one second
     51						.iff
     52						mov	time	,-(sp)		; pass time to wait
     53						.endc
     54						mov	s	,-(sp)		; and address of expected string
     55						call	waitfor			; go look for it
     56						.if nb	<fail>			; if given a failure routine address
     57						tst	r0			; check to see if it worked..
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 8-1
Local macros

     58						beq	fail			; it did not
     59						.endc
     60						.endm	waitfor
     61
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 9
Local macros

      1
      2						.sbttl	Local data
      3
      4	000000					.psect	$pdata			; /63/ consolidate all data here
      5	000000	   045 	   040 	   101 	abort:	.asciz	"% Aborted from keyboard"
      6	000030	   007 	   007 	   000 	bells:	.byte	bell ,bell ,0		; two bells when CONNECTing
      7	000033	   045 	   040 	   124 	defmsg:	.asciz	"% Timed out"
      8	000047	   124 	   157 	   147 	dia.01:	.asciz	"Toggling DTR.."	; /63/ moved message macro data here
      9	000066	   122 	   145 	   055 	dia.02:	.asciz	"Re-initting modem.."
     10	000112	   040 	   155 	   157 	dia.03:	.asciz	" modem is on-line"<cr><lf>
     11	000136	   124 	   162 	   171 	dia.04:	.asciz	"Try #"
     12	000144	   072 	   015 	   012 	dia.05:	.asciz	":"<cr><lf>
     13	000150	   124 	   150 	   145 	dia.06:	.asciz	"The known modem types are:"<cr><lf>
     14	000205	   045 	   040 	   116 	dia.07:	.asciz	"% No answer"<cr><lf>
     15	000223	   131 	   145 	   163 	dia.08:	.asciz	"Yes"
     16	000227	   116 	   157 	   000 	dia.09:	.asciz	"No"
     17	000232	   104 	   151 	   141 	dia.10:	.asciz	"Dial time-out secs: "
     18	000257	   123 	   145 	   164 	dia.11:	.asciz	"Settle-time ticks:  "
     19	000304	   045 	   130 	   040 	dia.12:	.asciz	'%X = "X'
     20	000314	   102 	   151 	   156 	dia.13:	.asciz	"Binary-responses:   "
     21	000341	   122 	   145 	   163 	dia.14:	.asciz	"Result strings:"<cr><lf>
     22	000363	   123 	   165 	   143 	dia.15:	.asciz	"Success"
     23	000373	   122 	   151 	   156 	dia.16:	.asciz	"Rings+1"<cr><lf>
     24	000405	   106 	   141 	   151 	dia.17:	.asciz	"Failure"<cr><lf>
     25	000417	   114 	   151 	   156 	dia.18:	.asciz	"Link "
     26	000425	   040 	   144 	   151 	dia.19:	.asciz	" disconnected"<cr><lf>
     27	000445	   054 	   040 	   040 	msg$dte:.asciz	",  DTE is forced to "	; /63/ tag messages that alter speed
     28	000472	   106 	   157 	   162 	msg$fmt:.asciz	"Format effectors:   "	; /62/
     29	000517	   045 	   040 	   116 	nodpro:	.asciz	"% No dial$prompt"
     30	000540	   045 	   040 	   116 	nod.go:	.asciz	"% No dial$go"
     31	000555	   045 	   040 	   116 	nod.ack:.asciz	"% No dial$ack"
     32	000573	   040 	   075 	   040 	prefix:	.asciz	\ = "\			; /62/ prefix for format effector data
     33	000600	   042 	   040 	   040 	tripsp:	.asciz	\"   \			; /62/ a " followed by three blanks
     34						.even
     35
     36	000000					.psect	$rwdata	,rw,d,lcl,rel,con
     37	000000				buffer:	.blkb	84.			; /BBS/ general purpose buffer
     38	000124	000000 			mute:	.word	0			; /BBS/ use to mute output to TT
     39	000126	000000 			retries:.word	0			; /BBS/ redial this many times..
     40
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 10
Local data

      1
      2	000000					.psect	$code
      3						.sbttl	SET MODEM-TYPE		; /BBS/ almost 100% new..
      4
      5	000000				set$mo::strcpy	#spare1	,#modem		; save copy of what's there now
	000000	012746 	000000G			mov	#modem	,-(sp)
	000004	012746 	000000G			mov	#spare1	,-(sp)
	000010	004767 	000000G			jsr	pc	,strcpy
      6	000014	016704 	000000G			mov	modtype	,r4		; address of its structure
      7	000020	016703 	000000G			mov	mready	,r3		; and its status
      8	000024					upcase	argbuf			; upper case the argument
	000024	016700 	000000G			mov	argbuf	,r0
	000030	004767 	000000G			call	upcase			; /BBS/ upcase until null terminator
      9	000034					copyz	argbuf	,#modem ,#40	; copy new modem name over
	000034	012746 	000040 			mov	#40	,-(sp)
	000040	016746 	000000G			mov	argbuf	,-(sp)
	000044	012746 	000000G			mov	#modem	,-(sp)
	000050	004767 	000000G			call	copyz$
     10	000054	004767 	001352 			call	findmodem		; and look for it in the list
     11	000060	005700 				tst	r0			; did it work?
     12	000062	001016 				bne	10$			; ya
     13
     14	000064					strcpy	#modem	,#spare1	; no, restore the old modem type
	000064	012746 	000000G			mov	#spare1	,-(sp)
	000070	012746 	000000G			mov	#modem	,-(sp)
	000074	004767 	000000G			jsr	pc	,strcpy
     15	000100	010367 	000000G			mov	r3	,mready		; its status
     16	000104	010467 	000000G			mov	r4	,modtype	; and its structure's address
     17	000110	004767 	000000G			call	incsts			; flag error, so r0 can be cleared
     18	000114	005000 				clr	r0			; strcpy, just above, trashes this reg
     19	000116	000207 				return				; error already handled by findmodem
     20
     21	000120	005067 	000000G		10$:	clr	blind			; reset this
     22					;	clr	pulse			; commented out, phone line is same..
     23	000124	016067 	000000G	000000G		mov	dial.time(r0),diatmo	; /62/ start with default time-out
     24	000132	016067 	000000G	000000G		mov	time.set(r0) ,settle	; /62/ and settle-time
     25	000140	012701 	000000G			mov	#xresult     ,r1	; /62/ where to put new extended mode
     26	000144	016000 	000000G			mov	x.result(r0) ,r0	; /62/ default supplied?
     27	000150	100402 				bmi	20$			; /62/ no, let null say it's nothing..
     28	000152	004767 	000000G			call	L10012			; /62/ ya, write it as ascii number(s)
     29	000156	105011 			20$:	clrb	(r1)			; /62/ null terminate the string
     30	000160	005000 				clr	r0			; preset to no error
     31	000162	105767 	000000G			tstb	ttname			; is line to modem set yet?
     32	000166	001422 				beq	30$			; no
     33	000170	004767 	000000G			call	ttyhang			; ya, assert DTR on PRO, reset modem
     34	000174	005700 				tst	r0			; did it work?
     35	000176	001016 				bne	30$			; no, ttyini handles its own error
     36	000200	016700 	000000G			mov	settle	,r0		; /62/ double the wait here because
     37	000204	006300 				asl	r0			; /62/ some modems are just too slow!
     38	000206					calls	suspend	,<#0,r0>	; /62/ let modem recover from DTR drop
	000206	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000210	010046 				        mov	r0	,-(sp)	; push it
	000212	012746 	000000 			        mov	#0	,-(sp)	; push it
	000216	010605 				  mov	sp	,r5		; set up the argument list pointer
	000220	004767 	000000G			  jsr	pc	,suspend		; and go to the routine
	000224	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	000226	012605 				  mov	(sp)+	,r5		; /63/ restore r5
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 10-1
SET MODEM-TYPE		; /BBS/ almost 100% new..

     39	000230	004767 	000104 			call	set.mo			; shared code
     40	000234	005700 			30$:	tst	r0			; did all this work?
     41	000236	001031 				bne	dia.er			; /63/ no, goto error handler
     42	000240	000207 				return
     43
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 11
SET MODEM-TYPE		; /BBS/ almost 100% new..

      1
      2						.sbttl	SET DTR and HANGUP
      3
      4	000242	004767 	000210 		set$dt::call	set.dtr			; toggle DTR
      5	000246	005700 				tst	r0			; did it work?
      6	000250	001024 				bne	dia.er			; /63/ no
      7	000252					.newline
	000252	004767 	000000G			call	l$pcrlf
      8	000256	000207 				return
      9
     10	000260	004767 	000172 		c$hang::call	set.dtr			; toggle DTR
     11	000264	005700 				tst	r0			; did it work?
     12	000266	001015 				bne	dia.er			; /63/ no
     13	000270					wrtall	#dia.18			; "Link "
	000270	012746 	000417'			mov	#dia.18	,-(sp)		; pass the address
	000274	004767 	000000G			call	wrtall			; do it
     14	000300					wrtall	#ttname			; include the device name
	000300	012746 	000000G			mov	#ttname	,-(sp)		; pass the address
	000304	004767 	000000G			call	wrtall			; do it
     15	000310					wrtall	#dia.19			; " disconnected"<cr><lf>
	000310	012746 	000425'			mov	#dia.19	,-(sp)		; pass the address
	000314	004767 	000000G			call	wrtall			; do it
     16	000320	000207 				return
     17
     18	000322				dia.er:	direrr	r0			; /63/ dump error message
	000322	010046 				mov	r0	,-(sp)
	000324	004767 	000000G			call	direr$
     19	000330	004767 	000000G			call	incsts			; flag error, so r0 can be cleared
     20	000334	005000 				clr	r0			; only do error message once
     21	000336	000207 				return
     22
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 12
SET DTR and HANGUP

      1
      2						.sbttl	The real work of SET MODEM
      3
      4	000340	016702 	000000G		set.mo:	mov	linksts	,r2		; save link open/closed status
      5	000344	001004 				bne	10$			; it's open now
      6	000346	004767 	000000G			call	opentt			; /63/ open link device
      7	000352	005700 				tst	r0			; successful open on line?
      8	000354	001030 				bne	20$			; no, give up
      9
     10	000356	004767 	001014 		10$:	call	fixspeed		; restore set speed if need be
     11	000362	010667 	000124'			mov	sp	,mute		; turn off echo
     12	000366	004767 	001536 			call	getatn			; try to get modems attention
     13	000372	005067 	000124'			clr	mute			; turn echo back on
     14	000376	005700 				tst	r0			; success?
     15	000400	001016 				bne	20$			; no
     16	000402	005767 	000000G			tst	sy.ini			; come here while executing KRT.INI?
     17	000406	001013 				bne	20$			; ya, don't echo modem I/O
     18	000410	005767 	000000G			tst	infomsg			; SET TT QUIET?
     19	000414	001410 				beq	20$			; ya..
     20	000416					wrtall	#modem			; no, display name of modem
	000416	012746 	000000G			mov	#modem	,-(sp)		; pass the address
	000422	004767 	000000G			call	wrtall			; do it
     21	000426					wrtall	#dia.03			; /63/ " modem is on-line"<cr><lf>
	000426	012746 	000112'			mov	#dia.03	,-(sp)		; pass the address
	000432	004767 	000000G			call	wrtall			; do it
     22										; note r0 still =0 here, from above..
     23	000436	010046 			20$:	mov	r0	,-(sp)		; save error
     24	000440	010267 	000000G			mov	r2	,linksts	; restore link status
     25	000444	001002 				bne	30$			; it was open, leave it that way
     26	000446	004767 	000000G			call	ttyfin			; close the link
     27	000452	012600 			30$:	mov	(sp)+	,r0		; restore error
     28	000454	000207 				return
     29
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 13
The real work of SET MODEM

      1
      2						.sbttl	The real work of SET DTR
      3						.enabl	lsb
      4
      5	000456				set.dtr:wrtall	#dia.01			; /63/ "Toggling DTR.."
	000456	012746 	000047'			mov	#dia.01	,-(sp)		; pass the address
	000462	004767 	000000G			call	wrtall			; do it
      6	000466	004767 	000000G			call	l$nolf			; just a return, unless TT is NOSCOPE
      7	000472	004767 	000000G			call	ttyhang			; drop DTR for 0.5sec
      8	000476	005700 				tst	r0			; did it work?
      9	000500	001035 				bne	10$			; no
     10	000502	005767 	000000G			tst	modtype			; was a modem on-line?
     11	000506	001432 				beq	10$			; no
     12	000510	016700 	000000G			mov	settle	,r0		; /62/ double the wait here because
     13	000514	006300 				asl	r0			; /62/ some modems are just too slow!
     14	000516					calls	suspend	,<#0,r0>	; /62/ let modem recover from DTR drop
	000516	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000520	010046 				        mov	r0	,-(sp)	; push it
	000522	012746 	000000 			        mov	#0	,-(sp)	; push it
	000526	010605 				  mov	sp	,r5		; set up the argument list pointer
	000530	004767 	000000G			  jsr	pc	,suspend		; and go to the routine
	000534	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	000536	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     15	000540					.br	reinit			; /63/
     16
     17	000540				reinit::wrtall	#dia.02			; /63/ "Re-initting modem.."
	000540	012746 	000066'			mov	#dia.02	,-(sp)		; pass the address
	000544	004767 	000000G			call	wrtall			; do it
     18	000550	004767 	000000G			call	l$nolf			; just a return
     19	000554	016746 	000000G			mov	infomsg	,-(sp)		; save state of SET TT [NO]QUIET
     20	000560	005067 	000000G			clr	infomsg			; temporarily off display
     21	000564	004767 	177550 			call	set.mo			; go re-init the modem
     22	000570	012667 	000000G			mov	(sp)+	,infomsg	; restore SET TT [NO]QUIET
     23	000574	000207 			10$:	return
     24
     25						.dsabl	lsb
     26
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 14
The real work of SET DTR

      1
      2						.sbttl	The REDIAL command	; /BBS/ slightly modified..
      3
      4	000576	016703 	000000G		c$redi::mov	argbuf	,r3		; argbuf address
      5	000602	016702 	000000G			mov	phnum	,r2		; address of phone number
      6	000606	012704 	177777 			mov	#-1	,r4		; default repeat count = 65535.
      7	000612	105713 				tstb	@r3			; any repeat count passed?
      8	000614	001416 				beq	20$			; no
      9	000616					calls	l$val	,<r3>		; convert ascii to integer
	000616	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000620	010346 				  mov	r3	,-(sp)		; doing it thusly generates less code
	000622	010605 				  mov	sp	,r5		; set pointer to argument list
	000624	004767 	000000G			  jsr	pc	,l$val		; call the subroutine
	000630	005726 				  tst	(sp)+			; pop parameter list from stack
	000632	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     10	000634	005700 				tst	r0			; success?
     11	000636	001002 				bne	10$			; no
     12	000640	010104 				mov	r1	,r4		; save repeat count
     13	000642	001003 				bne	20$			; disallow 0, it would really = 65536.
     14	000644	012700 	000000G		10$:	mov	#er$inr	,r0		; invalid number of retires
     15	000650	000420 				br	40$			; go handle error
     16	000652	105712 			20$:	tstb	@r2			; anything to dial?
     17	000654	001003 				bne	30$			; yes
     18	000656	012700 	000000G			mov	#er$npn	,r0		; no previous number dialed
     19	000662	000413 				br	40$			; bail out
     20	000664				30$:	strcpy	r3	,r2		; copy old phone num to argbuf
	000664	010246 				mov	r2	,-(sp)
	000666	010346 				mov	r3	,-(sp)
	000670	004767 	000000G			jsr	pc	,strcpy
     21	000674	010667 	000000G			mov	sp	,xredial	; flag c$dial was called by c$redial
     22	000700	005067 	000126'			clr	retries			; init number of tries counter
     23	000704	004767 	000020 			call	c$dial			; redial loop moved to c$dial
     24	000710	000405 				br	50$			; c$dial handles its own errors
     25
     26	000712				40$:	direrr	r0			; for local errors
	000712	010046 				mov	r0	,-(sp)
	000714	004767 	000000G			call	direr$
     27	000720	004767 	000000G			call	incsts			; set global flag also
     28	000724	005000 			50$:	clr	r0			; error was just handled
     29	000726	000207 				return
     30
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 15
The REDIAL command	; /BBS/ slightly modified..

      1
      2						.sbttl	The DIAL command	; /BBS/ substantially changed..
      3						.enabl	lsb
      4
      5	000730	005767 	000000G		c$dial::tst	signon			; if coming here from init file
      6	000734	001002 				bne	10$			; dump sign-on stuff before dial
      7	000736	004767 	000000G			call	sho$line
      8
      9	000742	105767 	000000G		10$:	tstb	ttname			; check for a real terminal name
     10	000746	001003 				bne	20$			; ok
     11	000750	012700 	000000G			mov	#er$pls	,r0		; please SET LINE first
     12	000754	000457 				br	70$			; goto error handler
     13
     14	000756	004767 	000000G		20$:	call	inqcd			; /62/ check to see if already talking
     15	000762	005700 				tst	r0			; /62/ or prior session not dead yet
     16	000764	003403 				ble	30$			; /62/ no data carrier is now present
     17	000766	012700 	000000G			mov	#er$dcd	,r0		; /62/ can't DIAL whilst DCD asserted
     18	000772	000450 				br	70$			; goto error handler
     19
     20	000774	004767 	000670 		30$:	call	findnumber		; perhaps a SET PHONE NUMBER?
     21	001000	103506 				bcs	100$			; findnu handles its own error
     22	001002	004767 	000000G			call	loamdm			; /63/ ensure modem data are loaded
     23	001006	016700 	000000G			mov	modtype	,r0		; recover the address of descriptor
     24	001012	001003 				bne	40$			; ok
     25	001014	012700 	000000G			mov	#er$mdm	,r0		; please SET MODEM first
     26	001020	000435 				br	70$			; goto error handler
     27
     28	001022	005067 	000124'		40$:	clr	mute			; turn echo back on just in case
     29	001026	016000 	000000G			mov	dial.string(r0),r0	; get dial format string address
     30	001032	105710 				tstb	@r0			; anything there?
     31	001034	001003 				bne	50$			; yes
     32	001036	012700 	000000G			mov	#er$ndf	,r0		; no dial format string defined
     33	001042	000424 				br	70$			; goto error handler
     34
     35	001044	004767 	000000G		50$:	call	opentt			; /63/ open the link device
     36	001050	005700 				tst	r0			; successful?
     37	001052	001061 				bne	100$			; no, ttyini does the error message
     38	001054	004767 	000316 			call	fixspeed		; restore set speed if need be
     39	001060	004767 	004014 			call	eatjunk			; /63/ flush any late redial response
     40	001064	016700 	000000G			mov	modtype	,r0		; recover top of list
     41	001070	005760 	000000G			tst	init.once(r0)		; need to re-init modem?
     42	001074	001403 				beq	60$			; evidently..
     43	001076	005767 	000000G			tst	mready			; is the modem now on-line?
     44	001102	001010 				bne	80$			; ya
     45	001104	004767 	001020 		60$:	call	getatn			; try to get modems attention
     46	001110	005700 				tst	r0			; did getting modems attn succeed?
     47	001112	001404 				beq	80$			; ya
     48	001114				70$:	direrr	r0			; no, emit error msg
	001114	010046 				mov	r0	,-(sp)
	001116	004767 	000000G			call	direr$
     49	001122	000435 				br	100$			; /62/ and exit
     50
     51	001124	005767 	000000G		80$:	tst	cccnt			; abort?
     52	001130	001032 				bne	100$			; ya..
     53	001132	005767 	000000G			tst	xredial			; redialing?
     54	001136	001416 				beq	90$			; no
     55	001140	005267 	000126'			inc	retries			; ya, bump retries count
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 15-1
The DIAL command	; /BBS/ substantially changed..

     56	001144					wrtall	#dia.04			; /63/ "Try #"
	001144	012746 	000136'			mov	#dia.04	,-(sp)		; pass the address
	001150	004767 	000000G			call	wrtall			; do it
     57	001154	016700 	000126'			mov	retries	,r0		; copy for integer to ascii conv
     58	001160	004767 	000000G			call	L10266			; print integer as decimal numb
     59	001164					wrtall	#dia.05			; /63/ ":"<cr><lf>
	001164	012746 	000144'			mov	#dia.05	,-(sp)		; pass the address
	001170	004767 	000000G			call	wrtall			; do it
     60
     61	001174	004767 	001474 		90$:	call	dodial			; actually try to dial the number now
     62	001200	005700 				tst	r0			; returns 1 for success, 0 if failed
     63	001202	001015 				bne	130$			; success, go CONNECT
     64	001204	005767 	000000G			tst	xredial			; redialing this?
     65	001210	001402 				beq	100$			; no, die..
     66	001212					sob	r4	,80$		; ya, try again?
	001212	005304 				dec	r4
	001214	001343 				bne	80$
     67
     68	001216	004767 	000000G		100$:	call	incsts			; set global error flag
     69
     70	001222	004767 	000000G		110$:	call	ttyfin			; close the handler
     71	001226	005067 	000000G			clr	linksts			; flag for ccast
     72	001232	005000 			120$:	clr	r0			; /62/ error already handled
     73	001234	000207 				return
     74
     75	001236	005767 	000000G		130$:	tst	xredial			; come here from c$redial?
     76	001242	001401 				beq	140$			; nope
     77	001244	005726 				tst	(sp)+			; ya, pop its return address
     78	001246	000167 	000000G		140$:	jmp	c$conn			; and CONNECT automatically..
     79
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 16
The DIAL command	; /BBS/ substantially changed..

      1
      2						.sbttl	Reset the modem		; /BBS/ all new
      3
      4	001252	004767 	000000G		c$idle::call	loamdm			; /63/ ensure modem data are loaded
      5	001256	016704 	000000G			mov	modtype	,r4		; get modem type
      6	001262	001763 				beq	120$			; no modem is on-line
      7	001264	005767 	000000G			tst	r50dev			; is there a line set?
      8	001270	001760 				beq	120$			; no, thus can't talk to modem
      9	001272	004767 	000000G			call	inqcd			; /62/ ya, is the modem active?
     10	001276	005700 				tst	r0			; /62/ well..
     11	001300	003414 				ble	150$			; /62/ probably not, do the init
     12	001302	004767 	000000G			call	ttyhang			; /62/ ya, try to hang it up!
     13	001306					calls	suspend	,<#0,settle>	; /62/ let modem recover from DTR drop
	001306	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001310	016746 	000000G			        mov	settle	,-(sp)	; push it
	001314	012746 	000000 			        mov	#0	,-(sp)	; push it
	001320	010605 				  mov	sp	,r5		; set up the argument list pointer
	001322	004767 	000000G			  jsr	pc	,suspend		; and go to the routine
	001326	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	001330	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     14	001332	005067 	000000G		150$:	clr	mready			; no longer ready no matter what
     15	001336	004767 	000000G			call	opentt			; /63/ init handler, etc..
     16	001342	005700 				tst	r0			; get a successful open on line?
     17	001344	001403 				beq	160$			; ya
     18	001346	012700 	000000G			mov	#er$idl	,r0		; can't release modem
     19	001352	000660 				br	70$			; and off to common code..
     20
     21	001354	004767 	000016 		160$:	call	fixspeed		; restore set speed if need be
     22	001360					ttputs	dial.idle(r4)		; send idle command string to modem
	001360	010146 				mov	r1	,-(sp)		; a one word buffer
	001362	016401 	000000G			mov	dial.idle(r4)	,r1		; pass string location to do.put
	001366	004767 	003544 			call	do.put			; /63/ send it
	001372	012601 				mov	(sp)+	,r1		; pop buffer
     23	001374	000712 				br	110$			; and off to common code..
     24
     25						.dsabl	lsb
     26
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 17
Reset the modem		; /BBS/ all new

      1
      2						.sbttl	Restore last set speed	; /BBS/ added..
      3
      4	001376	005767 	000000G		fixspeed:tst	b4speed			; did last call alter speed?
      5	001402	001412 				beq	10$			; nope
      6	001404					calls	setspd	,<b4speed>	; restore speed before that happened
	001404	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001406	016746 	000000G			  mov	b4speed	,-(sp)		; doing it thusly generates less code
	001412	010605 				  mov	sp	,r5		; set pointer to argument list
	001414	004767 	000000G			  jsr	pc	,setspd		; call the subroutine
	001420	005726 				  tst	(sp)+			; pop parameter list from stack
	001422	012605 				  mov	(sp)+	,r5		; /63/ restore r5
      7	001424	005067 	000000G			clr	b4speed			; once iz enuff..
      8	001430	000207 			10$:	return
      9
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 18
Restore last set speed	; /BBS/ added..

      1
      2						.sbttl	Find location of a modem's data structure
      3
      4					;	F I N D M O D E M		; /BBS/ substantially revised..
      5					;
      6					;	assumes:  modem	= name of the desired modem
      7					;	returns:    r0	= address of modem data structure or 0 if not found
      8
      9	001432				findmo:	save	<r3>
	001432	010346 				 mov	r3	,-(sp)
     10	001434	105767 	000000G			tstb	modem			; did caller supply a modem name?
     11	001440	001510 				beq	80$			; nope..
     12	001442	004767 	000000G			call	loamdm			; /63/ load predefined modems' data
     13	001446	010003 				mov	r0	,r3		; /63/ get address of head of list
     14	001450	122767 	000077 	000000G		cmpb	#'?	,modem		; come here for help?
     15	001456	001434 				beq	40$			; ya, format display accordingly
     16
     17	001460	016300 	000000G		10$:	mov	mod.string(r3),r0	; allow match if ok up to end of
     18	001464	012701 	000000G			mov	#modem	,r1		; argbuf so partial string works
     19	001470	122021 			20$:	cmpb	(r0)+	,(r1)+		; are they the same
     20	001472	001014 				bne	30$			; no
     21	001474	105711 				tstb	(r1)			; end of argbuf?
     22	001476	001374 				bne	20$			; no, continue
     23	001500	010367 	000000G			mov	r3	,modtype	; save address of the structure
     24	001504					copyz	mod.string(r3),#modem	; be sure whole name is there
	001504	005046 				clr	-(sp)
	001506	016346 	000000G			mov	mod.string(r3)	,-(sp)
	001512	012746 	000000G			mov	#modem	,-(sp)
	001516	004767 	000000G			call	copyz$
     25	001522	000455 				br	70$			; done
     26
     27	001524	016303 	000000G		30$:	mov	mod.next(r3),r3		; no, try the next one please
     28	001530	001353 				bne	10$			; keep going
     29	001532					direrr	#er$unm			; modem type is unknown
	001532	012746 	000000G			mov	#er$unm	,-(sp)
	001536	004767 	000000G			call	direr$
     30	001542	005767 	000000G			tst	infomsg			; SET TT QUIET?
     31	001546	001445 				beq	80$			; ya, skip list of possibilities
     32
     33	001550				40$:	wrtall	#dia.06			; /63/ "..known modem types.."<cr><lf>
	001550	012746 	000150'			mov	#dia.06	,-(sp)		; pass the address
	001554	004767 	000000G			call	wrtall			; do it
     34	001560	004767 	000000G			call	loamdm			; /63/ load predefined modems' data
     35	001564	010003 				mov	r0	,r3		; /63/ get address of head of list
     36	001566				50$:	wrtall	mod.string(r3)		; now print the list of modems
	001566	016346 	000000G			mov	mod.string(r3)	,-(sp)		; pass the address
	001572	004767 	000000G			call	wrtall			; do it
     37	001576					strlen	mod.string(r3)		; length of modem type
	001576	016300 	000000G			mov	mod.string(r3)	,r0
	001602	004767 	000000G			call	l$len
     38	001606	162700 	000020 			sub	#20	,r0		; cut to 16. for tighter display
     39	001612	005400 				neg	r0			; make it a positive number
     40	001614	010001 				mov	r0	,r1		; stash a copy for the loop
     41	001616	012700 	000040 			mov	#space	,r0		; load up a space
     42	001622	004767 	000000G		60$:	call	writ1ch			; write it to TT
     43	001626					sob	r1	,60$		; loop until properly padded
	001626	005301 				dec	r1
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 18-1
Find location of a modem's data structure

	001630	001374 				bne	60$
     44	001632					wrtall	mod.com(r3)		; dump comment string
	001632	016346 	000000G			mov	mod.com(r3)	,-(sp)		; pass the address
	001636	004767 	000000G			call	wrtall			; do it
     45	001642					.newline
	001642	004767 	000000G			call	l$pcrlf
     46	001646	016303 	000000G			mov	mod.next(r3),r3		; next one in list
     47	001652	001345 				bne	50$			; ok
     48	001654	000402 				br	80$			; exit with failure
     49
     50	001656	010300 			70$:	mov	r3	,r0		; return address of structure
     51	001660	000401 				br	90$
     52	001662	005000 			80$:	clr	r0			; failure
     53	001664				90$:	unsave	<r3>
	001664	012603 				 mov	(sp)+	,r3
     54	001666	000207 				return
     55
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 19
Find location of a modem's data structure

      1
      2						.sbttl	Find a defined phone number
      3
      4	001670				findnu:	save	<r3,r2>			; /45/ Added 20-Feb-86 13:00:50 BDN
	001670	010346 				 mov	r3	,-(sp)
	001672	010246 				 mov	r2	,-(sp)
      5	001674					strcpy	#errtxt	,argbuf		; /63/ save a copy of input string
	001674	016746 	000000G			mov	argbuf	,-(sp)
	001700	012746 	000000G			mov	#errtxt	,-(sp)
	001704	004767 	000000G			jsr	pc	,strcpy
      6	001710	127727 	000000G	000060 		cmpb	@argbuf	,#'0		; only if not number in first position
      7	001716	103404 				blo	10$			; ok
      8	001720	127727 	000000G	000071 		cmpb	@argbuf	,#'9		; well?
      9	001726	101464 				blos	70$			; /BBS/ it's a number
     10	001730	012702 	000000G		10$:	mov	#pnhead	,r2		; get listhead
     11
     12	001734	011202 			20$:	mov	(r2)	,r2		; loop a little, get next entry
     13	001736	001452 				beq	60$			; nothing there
     14	001740	010203 				mov	r2	,r3		; get address of text
     15	001742	062703 	000002 			add	#2	,r3		; +2 is offset for the data
     16
     17	001746					strcpy	#errtxt	,r3		; /63/ save a copy of input string
	001746	010346 				mov	r3	,-(sp)
	001750	012746 	000000G			mov	#errtxt	,-(sp)
	001754	004767 	000000G			jsr	pc	,strcpy
     18	001760	012701 	000000G			mov	#errtxt	,r1		; /63/ save un-upper-cased name here
     19	001764	012700 	000000'			mov	#buffer	,r0		; store temp copy here
     20	001770	121327 	000040 		30$:	cmpb	(r3)	,#space		; all done looking?
     21	001774	001403 				beq	40$			; yes
     22	001776	111321 				movb	(r3)	,(r1)+		; /63/ copy for "last # dialed"
     23	002000	112320 				movb	(r3)+	,(r0)+		; no, copy more of the name
     24	002002	001372 				bne	30$			; and continue
     25	002004	105010 			40$:	clrb	(r0)			; ensure .asciz please
     26	002006	105011 				clrb	(r1)			; /63/ ditto
     27
     28						; /BBS/ checking for end of argbuf matches on any partial string
     29	002010					upcase	argbuf			; also leaves r0 -> argbuf
	002010	016700 	000000G			mov	argbuf	,r0
	002014	004767 	000000G			call	upcase			; /BBS/ upcase until null terminator
     30	002020	010001 				mov	r0	,r1		; save pointer
     31	002022					upcase	#buffer			; /62/ temp buff allows upcasing name
	002022	012700 	000000'			mov	#buffer	,r0
	002026	004767 	000000G			call	upcase			; /BBS/ upcase until null terminator
     32	002032	122021 			50$:	cmpb	(r0)+	,(r1)+		; are they the same?
     33	002034	001337 				bne	20$			; no
     34	002036	105711 				tstb	(r1)			; ya, hit end of argbuf yet?
     35	002040	001374 				bne	50$			; no, continue
     36	002042	005203 				inc	r3			; point to number field
     37	002044	105713 				tstb	(r3)			; anything really there?
     38	002046	001406 				beq	60$			; /BBS/ no, go print error message
     39	002050					strcpy	argbuf	,r3		; copy into the real argument buffer
	002050	010346 				mov	r3	,-(sp)
	002052	016746 	000000G			mov	argbuf	,-(sp)
	002056	004767 	000000G			jsr	pc	,strcpy
     40	002062	000406 				br	70$			; /BBS/ go clear carry and exit
     41
     42	002064				60$:	direrr	#er$nnf			; /BBS/ say why it's gonna die
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 19-1
Find a defined phone number

	002064	012746 	000000G			mov	#er$nnf	,-(sp)
	002070	004767 	000000G			call	direr$
     43	002074	000261 				sec				; /51/ failure
     44	002076	000411 				br	80$
     45	002100				70$:	copyz	#errtxt	,phnum,#60	; /63/ stash copy for "last # dialed"
	002100	012746 	000060 			mov	#60	,-(sp)
	002104	012746 	000000G			mov	#errtxt	,-(sp)
	002110	016746 	000000G			mov	phnum	,-(sp)
	002114	004767 	000000G			call	copyz$
     46	002120	000241 				clc				; /51/ success
     47	002122				80$:	unsave	<r2,r3>
	002122	012602 				 mov	(sp)+	,r2
	002124	012603 				 mov	(sp)+	,r3
     48	002126	000207 				return
     49
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 20
Find a defined phone number

      1
      2						.sbttl	Wake up (init) modem	; /BBS/ almost 100% new..
      3
      4					;	G E T A T N
      5					;
      6					;	In case the modem is already awake (at command prompt mode)
      7					;	we will dump the string,  wait for the  acknowledgment  and
      8					;	loop until we are sure there are no more data.  For example
      9					;	the VA212 will send back an  INVALID  COMMAND\n* string for
     10					;	for the ^E and one also for the <CR>.  We could, of course,
     11					;	first send the modem its idle command,  but there are times
     12					;	when that may be undesirable,  like when the modem is being
     13					;	accessed via some sort of LAN or PABX.
     14					;
     15					;	input:	modtyp	= address of modem descriptor
     16					;	return:	  r0	= if <>, the error code
     17
     18	002130				getatn:	save	<r1,r2,r3,r4>
	002130	010146 				 mov	r1	,-(sp)
	002132	010246 				 mov	r2	,-(sp)
	002134	010346 				 mov	r3	,-(sp)
	002136	010446 				 mov	r4	,-(sp)
     19	002140	005046 				clr	-(sp)			; init "msg rec'd" flag
     20	002142	012702 	000000'			mov	#buffer	,r2		; write init string here
     21	002146	004767 	000000G			call	loamdm			; /63/ ensure modem data are loaded
     22	002152	016704 	000000G			mov	modtype	,r4		; get address of structure
     23	002156	005067 	000000G			clr	mready			; modem is no longer ready
     24	002162	016403 	000000G			mov	wake.string(r4),r3	; point to the init string
     25	002166	105713 				tstb	(r3)			; is there one to send?
     26	002170	001004 				bne	10$			; ya
     27	002172	012700 	000000G			mov	#er$wks	,r0		; nope..
     28	002176	000167 	000446 			jmp	200$			; handle the error
     29
     30	002202	105713 			10$:	tstb	(r3)			; done?
     31	002204	001432 				beq	70$			; yes
     32	002206	121327 	000045 			cmpb	(r3)	,#'%		; look for a format effector
     33	002212	001024 				bne	50$			; ya, not no..
     34	002214	126327 	000001 	000170 		cmpb	1(r3)	,#'x!40		; "%X" to set Hayes extended mode?
     35	002222	001404 				beq	20$			; yes
     36	002224	126327 	000001 	000130 		cmpb	1(r3)	,#'X&137	; check both cases
     37	002232	001014 				bne	50$			; not formatting, copy char over
     38	002234	105767 	000000G		20$:	tstb	xresult			; is there an extended mode set?
     39	002240	001406 				beq	40$			; no, kill leading space here
     40	002242	112722 	000130 			movb	#'X&137	,(r2)+		; ya, insert an "X"
     41	002246	012701 	000000G			mov	#xresult,r1		; make copy to auto-increment
     42	002252	112122 			30$:	movb	(r1)+	,(r2)+		; then insert the mode, ala "X4"
     43	002254	001376 				bne	30$			; stop on the first null
     44	002256	005302 			40$:	dec	r2			; then back up over it
     45	002260	005203 				inc	r3			; skip over the "%" please
     46	002262	000401 				br	60$			; next please
     47	002264	111322 			50$:	movb	(r3)	,(r2)+		; not formatting, copy character
     48	002266	005203 			60$:	inc	r3			; skip over current char now
     49	002270	000744 				br	10$			; next
     50	002272	105012 			70$:	clrb	(r2)			; .asciz
     51
     52	002274	012703 	000003 			mov	#3	,r3		; loop a little to get modem going
     53	002300	004767 	002574 		80$:	call	eatjunk			; trash stuff that may be waiting
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 20-1
Wake up (init) modem	; /BBS/ almost 100% new..

     54	002304	012702 	000000'			mov	#buffer	,r2		; get address of wakeup string
     55	002310	000422 				br	100$			; for display format on abort
     56
     57	002312	105722 			90$:	tstb	(r2)+			; /62/ next byte..
     58	002314	001520 				beq	140$			; /62/ that's all there is
     59	002316	005767 	000124'			tst	mute			; allow strike any key abort?
     60	002322	001015 				bne	100$			; no, not this time
     61	002324	004767 	000000G			call	chkabo			; strike any key to abort
     62	002330	005700 				tst	r0			; get anything?
     63	002332	001411 				beq	100$			; nope
     64	002334	005267 	000000G			inc	cccnt			; fake abort so modem is stopped
     65	002340	004767 	000000G			call	clrcns			; eat LF after a CR, etc..
     66	002344	005716 				tst	(sp)			; /62/ anything typed out yet?
     67	002346	001533 				beq	180$			; /62/ no
     68	002350					.newline			; ya, ensure abort message is on \n
	002350	004767 	000000G			call	l$pcrlf
     69	002354	000530 				br	180$			; and bail out..
     70
     71	002356				100$:	ttputc	(r2)			; /62/ put a char to the modem
	002356	005046 				clr	-(sp)			; create a one word buffer
	002360	151216 				bisb	(r2)	,(sp)		; stuff in byte sans sign extension
	002362	010600 				mov	sp	,r0		; point to buffer
	002364	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002366	012746 	000001 			        mov	#1	,-(sp)	; push it
	002372	010046 				        mov	r0	,-(sp)	; push it
	002374	010605 				  mov	sp	,r5		; set up the argument list pointer
	002376	004767 	000000G			  jsr	pc	,binwri		; and go to the routine
	002402	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	002404	012605 				  mov	(sp)+	,r5		; /63/ restore r5
	002406	005726 				tst	(sp)+			; pop buffer
     72	002410	005764 	000000G			tst	dial.echo(r4)		; /62/ does it echo?
     73	002414	001424 				beq	110$			; /62/ no
     74	002416					ttgetc	#-1			; then look for its echo
	002416	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002420	012746 	177777 			  mov	#-1	,-(sp)		; doing it thusly generates less code
	002424	010605 				  mov	sp	,r5		; set pointer to argument list
	002426	004767 	000000G			  jsr	pc	,xbinread		; call the subroutine
	002432	005726 				  tst	(sp)+			; pop parameter list from stack
	002434	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     75	002436	005700 				tst	r0			; anything there?
     76	002440	001033 				bne	130$			; no
     77	002442	142701 	177600 			bicb	#^c<177>,r1		; remove parity always
     78	002446	120127 	000015 			cmpb	r1	,#cr		; is it a return?
     79	002452	001426 				beq	130$			; ya, don't echo it
     80	002454	120127 	000012 			cmpb	r1	,#lf		; is it a line feed?
     81	002460	001423 				beq	130$			; ya, don't echo it
     82	002462	110100 				movb	r1	,r0		; get a copy of it
     83	002464	000413 				br	120$			; /62/ and go dump same to the screen
     84	002466				110$:	calls	suspend	,<#0,#1>	; /62/ match above ttgetc 1 tick lag
	002466	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002470	012746 	000001 			        mov	#1	,-(sp)	; push it
	002474	012746 	000000 			        mov	#0	,-(sp)	; push it
	002500	010605 				  mov	sp	,r5		; set up the argument list pointer
	002502	004767 	000000G			  jsr	pc	,suspend		; and go to the routine
	002506	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	002510	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     85	002512	111300 				movb	(r3)	,r0		; cop char just sent
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 20-2
Wake up (init) modem	; /BBS/ almost 100% new..

     86	002514	005767 	000124'		120$:	tst	mute			; echo this to TT?
     87	002520	001003 				bne	130$			; no, don't echo modem I/O
     88	002522	010016 				mov	r0	,@sp		; set "msg rec'd" flag
     89	002524	004767 	000000G			call	writ1char		; and echo to TT
     90	002530				130$:	calls	suspend	,<#0,wake.rate(r4)> ; no, pause if need be
	002530	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002532	016446 	000000G			        mov	wake.rate(r4)	,-(sp)	; push it
	002536	012746 	000000 			        mov	#0	,-(sp)	; push it
	002542	010605 				  mov	sp	,r5		; set up the argument list pointer
	002544	004767 	000000G			  jsr	pc	,suspend		; and go to the routine
	002550	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	002552	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     91	002554	000656 				br	90$			; and do some more
     92
     93	002556	005716 			140$:	tst	(sp)			; was anything echo'd to TT?
     94	002560	001402 				beq	150$			; no, skip the newline
     95	002562					.newline			; ya, tag it
	002562	004767 	000000G			call	l$pcrlf
     96	002566				150$:	waitfor	wake.prompt(r4),#2,160$	; now wait 2 secs for a response
	002566	012746 	000002 			mov	#2	,-(sp)		; pass #2 to wait
	002572	016446 	000000G			mov	wake.prompt(r4)	,-(sp)		; and address of expected string
	002576	004767 	002054 			call	waitfor			; go look for it
	002602	005700 				tst	r0			; check to see if it worked..
	002604	001401 				beq	160$			; it did not
     97	002606	000407 				br	170$			; success
     98	002610	005767 	000000G		160$:	tst	cccnt			; abort?
     99	002614	001010 				bne	180$			; ya..
    100	002616	005303 				dec	r3			; decrement loop counter
    101	002620	001411 				beq	190$			; a complete failure, exit
    102	002622	000167 	177452 			jmp	80$			; next please
    103
    104	002626	010467 	000000G		170$:	mov	r4	,mready		; flag that modem is initialized
    105	002632	005000 				clr	r0			; return(success)
    106	002634	000407 				br	210$
    107
    108	002636	012700 	000000G		180$:	mov	#er$abk	,r0		; say it's a keyboard abort
    109	002642	000402 				br	200$
    110	002644	012700 	000000G		190$:	mov	#er$wke	,r0		; can't get wake$pmpt from modem
    111	002650	005067 	000000G		200$:	clr	mready			; modem is not now ready
    112	002654	004767 	002220 		210$:	call	eatjunk			; just to be sure..
    113	002660	005726 				tst	(sp)+			; pop "msg rec'd" flag buffer
    114	002662					unsave	<r4,r3,r2,r1>
	002662	012604 				 mov	(sp)+	,r4
	002664	012603 				 mov	(sp)+	,r3
	002666	012602 				 mov	(sp)+	,r2
	002670	012601 				 mov	(sp)+	,r1
    115	002672	000207 				return
    116
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 21
Wake up (init) modem	; /BBS/ almost 100% new..

      1
      2						.sbttl	Dial the number		; /BBS/ moderately modified..
      3
      4					;	Note that the waitfor routine,  called by macro of same name, will
      5					;	exit immediately if the string to compare against is NULL, thus it
      6					;	won't hurt anything to call it for modems that may not respond, as
      7					;	long dmod.* aren't defined for such a modem, that is..
      8
      9	002674				dodial:	save	<r2,r3,r4>
	002674	010246 				 mov	r2	,-(sp)
	002676	010346 				 mov	r3	,-(sp)
	002700	010446 				 mov	r4	,-(sp)
     10	002702	005046 				clr	-(sp)			; /62/ init "msg rec'd" flag
     11	002704	012703 	000000'			mov	#buffer	,r3		; pointer to a handy buffer
     12	002710	016704 	000000G			mov	modtype	,r4		; get address of modem descriptor
     13	002714	004767 	001414 			call	fmtstr			; format the dialing string
     14
     15	002720					ttputs	dmod.string(r4)		; dump the prompt for dialing out
	002720	010146 				mov	r1	,-(sp)		; a one word buffer
	002722	016401 	000000G			mov	dmod.string(r4)	,r1		; pass string location to do.put
	002726	004767 	002204 			call	do.put			; /63/ send it
	002732	012601 				mov	(sp)+	,r1		; pop buffer
     16	002734					waitfor	dmod.prompt(r4),#4,70$	; wait for a response
	002734	012746 	000004 			mov	#4	,-(sp)		; pass #4 to wait
	002740	016446 	000000G			mov	dmod.prompt(r4)	,-(sp)		; and address of expected string
	002744	004767 	001706 			call	waitfor			; go look for it
	002750	005700 				tst	r0			; check to see if it worked..
	002752	001512 				beq	70$			; it did not
     17	002754	004767 	002120 			call	eatjunk			; let things settle a bit
     18	002760	000420 				br	30$			; display format on abort kludge
     19
     20	002762	105723 			10$:	tstb	(r3)+			; next byte..
     21	002764	001510 				beq	80$			; that's all there is
     22
     23	002766	004767 	000000G			call	chkabo			; strike any key to abort
     24	002772	005700 				tst	r0			; get anything?
     25	002774	001412 				beq	30$			; nope
     26	002776	005267 	000000G			inc	cccnt			; fake abort so modem is stopped
     27	003002	004767 	000000G			call	clrcns			; eat LF after a CR, etc..
     28	003006	005716 				tst	(sp)			; /62/ was anything echo'd to TT?
     29	003010	001402 				beq	20$			; /62/ no, skip the newline
     30	003012					.newline			; /62/ ya, tag it
	003012	004767 	000000G			call	l$pcrlf
     31	003016	000167 	000402 		20$:	jmp	150$			; /62/ go clean up
     32
     33	003022				30$:	ttputc	(r3)			; send a char to the modem
	003022	005046 				clr	-(sp)			; create a one word buffer
	003024	151316 				bisb	(r3)	,(sp)		; stuff in byte sans sign extension
	003026	010600 				mov	sp	,r0		; point to buffer
	003030	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003032	012746 	000001 			        mov	#1	,-(sp)	; push it
	003036	010046 				        mov	r0	,-(sp)	; push it
	003040	010605 				  mov	sp	,r5		; set up the argument list pointer
	003042	004767 	000000G			  jsr	pc	,binwri		; and go to the routine
	003046	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	003050	012605 				  mov	(sp)+	,r5		; /63/ restore r5
	003052	005726 				tst	(sp)+			; pop buffer
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 21-1
Dial the number		; /BBS/ moderately modified..

     34	003054	005764 	000000G			tst	dial.echo(r4)		; does it echo?
     35	003060	001416 				beq	40$			; no
     36	003062					ttgetc	#-1			; ya, wait one tick for echo
	003062	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003064	012746 	177777 			  mov	#-1	,-(sp)		; doing it thusly generates less code
	003070	010605 				  mov	sp	,r5		; set pointer to argument list
	003072	004767 	000000G			  jsr	pc	,xbinread		; call the subroutine
	003076	005726 				  tst	(sp)+			; pop parameter list from stack
	003100	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     37	003102	005700 				tst	r0			; get anything?
     38	003104	001022 				bne	60$			; no
     39	003106	142701 	177600 			bicb	#^c<177>,r1		; remove parity always
     40	003112	110100 				movb	r1	,r0		; copy the char
     41	003114	000413 				br	50$			; and go dump same to the screen
     42	003116				40$:	calls	suspend	,<#0,#1>	; /62/ match above ttgetc 1 tick lag
	003116	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003120	012746 	000001 			        mov	#1	,-(sp)	; push it
	003124	012746 	000000 			        mov	#0	,-(sp)	; push it
	003130	010605 				  mov	sp	,r5		; set up the argument list pointer
	003132	004767 	000000G			  jsr	pc	,suspend		; and go to the routine
	003136	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	003140	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     43	003142	111300 				movb	(r3)	,r0		; cop char just sent
     44	003144	010016 			50$:	mov	r0	,@sp		; /62/ set "msg rec'd" flag
     45	003146	004767 	000000G			call	writ1char		; and echo it to TT
     46	003152				60$:	calls	suspend	,<#0,dial.rate(r4)> ; pace chars if dial.rate is not 0
	003152	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003154	016446 	000000G			        mov	dial.rate(r4)	,-(sp)	; push it
	003160	012746 	000000 			        mov	#0	,-(sp)	; push it
	003164	010605 				  mov	sp	,r5		; set up the argument list pointer
	003166	004767 	000000G			  jsr	pc	,suspend		; and go to the routine
	003172	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	003174	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     47	003176	000671 				br	10$			; loop
     48
     49	003200	012700 	000517'		70$:	mov	#nodprompt,r0		; no dial prompt
     50	003204	000477 				br	130$
     51
     52	003206	005716 			80$:	tst	(sp)			; /62/ ever type anything to TT?
     53	003210	001402 				beq	90$			; /62/ no, thus a newline isn't needed
     54	003212					.newline			; for dial string above
	003212	004767 	000000G			call	l$pcrlf
     55	003216	012703 	000000'		90$:	mov	#buffer	,r3		; restore buffer pointer
     56	003222					waitfor	dial.ack(r4),#4,110$	; wait for numb to echo perhaps
	003222	012746 	000004 			mov	#4	,-(sp)		; pass #4 to wait
	003226	016446 	000000G			mov	dial.ack(r4)	,-(sp)		; and address of expected string
	003232	004767 	001420 			call	waitfor			; go look for it
	003236	005700 				tst	r0			; check to see if it worked..
	003240	001454 				beq	110$			; it did not
     57	003242					ttputs	dial.conf(r4)		; stuff a confirm (ok if null)
	003242	010146 				mov	r1	,-(sp)		; a one word buffer
	003244	016401 	000000G			mov	dial.conf(r4)	,r1		; pass string location to do.put
	003250	004767 	001662 			call	do.put			; /63/ send it
	003254	012601 				mov	(sp)+	,r1		; pop buffer
     58	003256					waitfor	dial.go(r4),#5,120$	; maybe wait for any confirming string
	003256	012746 	000005 			mov	#5	,-(sp)		; pass #5 to wait
	003262	016446 	000000G			mov	dial.go(r4)	,-(sp)		; and address of expected string
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 21-2
Dial the number		; /BBS/ moderately modified..

	003266	004767 	001364 			call	waitfor			; go look for it
	003272	005700 				tst	r0			; check to see if it worked..
	003274	001441 				beq	120$			; it did not
     59	003276	004767 	000260 			call	getsts			; get final result of the call please
     60	003302	005767 	000000G			tst	cccnt			; did this die from a keyboard abort?
     61	003306	001041 				bne	140$			; ya
     62	003310	005200 				inc	r0			; success?
     63	003312	003110 				bgt	180$			; yes
     64	003314	001420 				beq	100$			; no, but modem stopped itself
     65	003316					ttputs	dial.xabort(r4)		; get the modem to stop
	003316	010146 				mov	r1	,-(sp)		; a one word buffer
	003320	016401 	000000G			mov	dial.xabort(r4)	,r1		; pass string location to do.put
	003324	004767 	001606 			call	do.put			; /63/ send it
	003330	012601 				mov	(sp)+	,r1		; pop buffer
     66	003332					calls	suspend	,<#0,settle>	; let modem recover from abort!
	003332	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003334	016746 	000000G			        mov	settle	,-(sp)	; push it
	003340	012746 	000000 			        mov	#0	,-(sp)	; push it
	003344	010605 				  mov	sp	,r5		; set up the argument list pointer
	003346	004767 	000000G			  jsr	pc	,suspend		; and go to the routine
	003352	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	003354	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     67	003356	105767 	000000'		100$:	tstb	buffer			; anything in the buffer?
     68	003362	001062 				bne	170$			; ya, message already displayed..
     69	003364	012700 	000033'			mov	#defmsg	,r0		; no, must have timed out, say so
     70	003370	000405 				br	130$			; go dump failure message
     71
     72	003372	012700 	000555'		110$:	mov	#nod.ack,r0		; no dial ack
     73	003376	000402 				br	130$
     74	003400	012700 	000540'		120$:	mov	#nod.go	,r0		; no dial.go confirmation
     75	003404	005767 	000000G		130$:	tst	cccnt			; was ^C typed?
     76	003410	001442 				beq	160$			; no
     77
     78	003412	105767 	000000'		140$:	tstb	buffer			; anything in the buffer?
     79	003416	001402 				beq	150$			; no, don't need a newline
     80	003420					.newline			; ya, goto a clean line
	003420	004767 	000000G			call	l$pcrlf
     81	003424				150$:	ttputs	dial.xabort(r4)		; get the modem to stop
	003424	010146 				mov	r1	,-(sp)		; a one word buffer
	003426	016401 	000000G			mov	dial.xabort(r4)	,r1		; pass string location to do.put
	003432	004767 	001500 			call	do.put			; /63/ send it
	003436	012601 				mov	(sp)+	,r1		; pop buffer
     82	003440					calls	suspend	,<#0,settle>	; let modem recover from abort!
	003440	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003442	016746 	000000G			        mov	settle	,-(sp)	; push it
	003446	012746 	000000 			        mov	#0	,-(sp)	; push it
	003452	010605 				  mov	sp	,r5		; set up the argument list pointer
	003454	004767 	000000G			  jsr	pc	,suspend		; and go to the routine
	003460	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	003462	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     83	003464	016746 	000000G			mov	cccnt	,-(sp)		; save number of times ^C typed
     84	003470	005067 	000000G			clr	cccnt			; do this so set.dtr can call getatn
     85	003474	004767 	174756 			call	set.dtr			; drop DTR and re-init modem
     86	003500					direrr	r0			; /62/ if set.dtr failed, say why
	003500	010046 				mov	r0	,-(sp)
	003502	004767 	000000G			call	direr$
     87	003506	012667 	000000G			mov	(sp)+	,cccnt		; restore ^C count
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 21-3
Dial the number		; /BBS/ moderately modified..

     88	003512	012700 	000000'			mov	#abort	,r0		; user interrupt message
     89
     90	003516				160$:	wrtall	r0			; say why we are here..
	003516	010046 				mov	r0	,-(sp)		; pass the address
	003520	004767 	000000G			call	wrtall			; do it
     91	003524					.newline
	003524	004767 	000000G			call	l$pcrlf
     92	003530	005000 			170$:	clr	r0			; failure
     93	003532	000406 				br	190$
     94
     95	003534				180$:	wrtall	#bells			; beep just before CONNECTing
	003534	012746 	000030'			mov	#bells	,-(sp)		; pass the address
	003540	004767 	000000G			call	wrtall			; do it
     96	003544	012700 	000001 			mov	#1	,r0		; success
     97	003550	005726 			190$:	tst	(sp)+			; /62/ pop "msg rec'd" flag buffer
     98	003552					unsave	<r4,r3,r2>
	003552	012604 				 mov	(sp)+	,r4
	003554	012603 				 mov	(sp)+	,r3
	003556	012602 				 mov	(sp)+	,r2
     99	003560	000207 				return
    100
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 22
Dial the number		; /BBS/ moderately modified..

      1
      2						.sbttl	Get final result of dialing	; /BBS/ somewhat modified
      3
      4		000007 				NOREPLY	=	7		; /62/ fail call after this many rings
      5
      6						; offsets to local data on stack
      7		000000 				STATUS	=	0		; current status
      8		000002 				NRINGS	=	2		; number of rings
      9		000004 				LOCSIZ	=	4		; size of the above
     10
     11					;	passed:	  r4	= pointer to modem's data structure
     12					;	return:	  r0	= if <>, the error code
     13
     14	003562				getsts:	save	<r5>
	003562	010546 				 mov	r5	,-(sp)
     15	003564	016703 	000000G			mov	diatmo	,r3		; /62/ # secs to wait for response
     16	003570					mul	clkflg	,r3		; convert to ticks per second
	003570	016746 	000000G			mov	clkflg	,-(sp)		; pass multiplier to p$mul
	003574	010346 				mov	r3	,-(sp)		; pass multiplicand too
	003576	004767 	000000G			call	p$mul			; multiply, returns a 16-bit product
	003602	012603 				.iif eq <$$-3>	mov	(sp)+	,r3	; ditto if r3
     17	003604	010302 				mov	r3	,r2		; save 16-bit product here
     18	003606	162706 	000004 			sub	#locsiz	,sp		; allocate a local data buffer
     19	003612	010605 				mov	sp	,r5		; and a pointer to it
     20	003614	005046 				clr	-(sp)			; init "msg rec'd" flag
     21	003616	012765 	000007 	000002 		mov	#noreply,nrings(r5)	; after this many rings, give up..
     22	003624	005015 				clr	(r5)			; status = 0
     23
     24	003626	005715 			10$:	tst	(r5)			; while (status == 0)
     25	003630	001076 				bne	90$			; exit with result
     26	003632	012703 	000000'			mov	#buffer	,r3		; a buffer pointer
     27	003636	105013 				clrb	(r3)			; init buffer
     28
     29	003640	004767 	000000G		20$:	call	chkabo			; strike any key to abort
     30	003644	005700 				tst	r0			; get anything?
     31	003646	001405 				beq	30$			; nope
     32	003650	005267 	000000G			inc	cccnt			; fake abort so modem is stopped
     33	003654	004767 	000000G			call	clrcns			; eat LF after a CR, etc..
     34	003660	000414 				br	40$			; and bail out
     35
     36	003662				30$:	calls	xbinrea	,<#-1>		; this actually waits one tick
	003662	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003664	012746 	177777 			  mov	#-1	,-(sp)		; doing it thusly generates less code
	003670	010605 				  mov	sp	,r5		; set pointer to argument list
	003672	004767 	000000G			  jsr	pc	,xbinrea		; call the subroutine
	003676	005726 				  tst	(sp)+			; pop parameter list from stack
	003700	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     37	003702	005700 				tst	r0			; did that work?
     38	003704	001405 				beq	50$			; ya
     39	003706					sob	r2	,20$		; no, try it all again
	003706	005302 				dec	r2
	003710	001353 				bne	20$
     40
     41	003712	012715 	000000G		40$:	mov	#aborted,(r5)		; flag modem needs to be killed
     42	003716	000443 				br	90$			; exit loop
     43
     44	003720	105701 			50$:	tstb	r1			; never suffer embedded nulls
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 22-1
Get final result of dialing	; /BBS/ somewhat modified

     45	003722	001746 				beq	20$			; a null, skip it
     46	003724	142701 	177600 			bicb	#^c<177>,r1		; ensure a real seven bit character
     47	003730	110123 				movb	r1	,(r3)+		; copy the byte over
     48	003732	105013 				clrb	(r3)			; ensure we stay .asciz
     49	003734	005764 	000000G			tst	res.bin(r4)		; exit loop on single character I/O?
     50	003740	001023 				bne	70$			; yes
     51	003742	120127 	000015 			cmpb	r1	,#cr		; carriage return finally found?
     52	003746	001410 				beq	60$			; yes
     53	003750	120127 	000012 			cmpb	r1	,#lf		; no, but
     54	003754	001405 				beq	60$			; a line feed will do nicely
     55	003756	010116 				mov	r1	,@sp		; it's neither, set "msg rec'd" flag
     56	003760	010100 				mov	r1	,r0		; pass char to writ1char
     57	003762	004767 	000000G			call	writ1char		; echo to TT
     58	003766	000724 				br	20$			; then go back for more input
     59
     60	003770	126727 	000000'	000015 	60$:	cmpb	buffer	,#cr		; leading return?
     61	003776	001713 				beq	10$			; can't be a valid response
     62	004000	126727 	000000'	000012 		cmpb	buffer	,#lf		; leading line feed?
     63	004006	001707 				beq	10$			; ditto..
     64
     65	004010	005716 			70$:	tst	(sp)			; was anything echo'd to TT?
     66	004012	001402 				beq	80$			; no, cursor is already on column one
     67	004014					.newline			; ya, tag it
	004014	004767 	000000G			call	l$pcrlf
     68	004020	004767 	000016 		80$:	jsr	pc,.default		; go check result message
     69	004024	000700 				br	10$			; next please
     70
     71	004026	011500 			90$:	mov	(r5)	,r0		; recover error
     72	004030	005726 				tst	(sp)+			; pop "msg rec'd" flag buffer
     73	004032	062706 	000004 			add	#locsiz	,sp		; pop temp buffer
     74	004036					unsave	<r5>
	004036	012605 				 mov	(sp)+	,r5
     75	004040	000207 				return
     76
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 23
Get final result of dialing	; /BBS/ somewhat modified

      1
      2						.sbttl	Check modem's response	; /39/ 4-DEC-1985, Brian Nelson
      3
      4					;	Read possible responses and their message classes from a linked
      5					;	list whose first address is in res.header(modem_address).  If a
      6					;	modem has no mod$res entries this routine will fail any call.
      7
      8	004042				.default:save	<r3>			; /BBS/ about 50% new..
	004042	010346 				 mov	r3	,-(sp)
      9	004044	016403 	000000G			mov	res.head(r4),r3		; get listhead of responses
     10	004050	001525 				beq	90$			; nothing defined..
     11	004052				10$:	save	<r1,r2,r3>
	004052	010146 				 mov	r1	,-(sp)
	004054	010246 				 mov	r2	,-(sp)
	004056	010346 				 mov	r3	,-(sp)
     12	004060	062703 	000004 			add	#4	,r3		; 4 byte offset for text
     13	004064	012702 	000000'			mov	#buffer	,r2		; address of response to find text in
     14	004070	121227 	000040 		20$:	cmpb	(r2)	,#space		; is this a space or below?
     15	004074	003002 				bgt	30$			; no, continue
     16	004076	005202 				inc	r2			; ya, skip past leading blanks and non
     17	004100	000773 				br	20$			; printing stuff before checking match
     18	004102				30$:	upcase	r3			; uppercase text
	004102	010300 				mov	r3	,r0
	004104	004767 	000000G			call	upcase			; /BBS/ upcase until null terminator
     19	004110					strlen	r3			; get its length
	004110	010300 				mov	r3	,r0
	004112	004767 	000000G			call	l$len
     20	004116	010001 				mov	r0	,r1		; save it
     21	004120					upcase	r2			; uppercase response from modem
	004120	010200 				mov	r2	,r0
	004122	004767 	000000G			call	upcase			; /BBS/ upcase until null terminator
     22	004126					strlen	r2			; get its length
	004126	010200 				mov	r2	,r0
	004130	004767 	000000G			call	l$len
     23	004134					calls	instr	,<r2,r0,r3,r1>	; see if desired text is in response
	004134	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	004136	010146 				        mov	r1	,-(sp)	; push it
	004140	010346 				        mov	r3	,-(sp)	; push it
	004142	010046 				        mov	r0	,-(sp)	; push it
	004144	010246 				        mov	r2	,-(sp)	; push it
	004146	010605 				  mov	sp	,r5		; set up the argument list pointer
	004150	004767 	000000G			  jsr	pc	,instr		; and go to the routine
	004154	062706 	000010 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	004160	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     24	004162					unsave	<r3,r2,r1>
	004162	012603 				 mov	(sp)+	,r3
	004164	012602 				 mov	(sp)+	,r2
	004166	012601 				 mov	(sp)+	,r1
     25	004170	005300 				dec	r0			; match must begin from the top of
     26	004172	001403 				beq	40$			; the response string, else ignore it
     27	004174	011303 				mov	(r3)	,r3		; get the next in the list
     28	004176	001325 				bne	10$			; something is left to try
     29	004200	000453 				br	100$			; tried 'em all..
     30	004202	016315 	000002 		40$:	mov	2(r3)	,(r5)		; response class
     31	004206	002402 				blt	50$			; /62/ < is 38.4kb or a failed call
     32	004210	003004 				bgt	60$			; 1 = ring, >1 = connect..
     33	004212	000446 				br	100$			; 0 = info only, display but no action
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 23-1
Check modem's response	; /39/ 4-DEC-1985, Brian Nelson

     34	004214	021527 	000000G		50$:	cmp	(r5)	,#con38400	; /62/ is it 38.4kb?
     35	004220	001041 				bne	90$			; /62/ no, it's a failed call..
     36
     37	004222	021527 	000002 		60$:	cmp	(r5)	,#2		; what to do ??
     38	004226	103423 				blo	80$			; it wuz ring /62/ fix for 38.4kb
     39	004230	001437 				beq	100$			; connect without speed check
     40	004232	004767 	000000G			call	ttspeed			; speed supplied, get handler's speed
     41	004236	005700 				tst	r0			; is it settable?
     42	004240	001413 				beq	70$			; /62/ nope..
     43	004242	020015 				cmp	r0	,(r5)		; does modem speed = handler speed?
     44	004244	001411 				beq	70$			; ya..
     45	004246	010067 	000000G			mov	r0	,b4speed	; no, save speed before fallback..
     46	004252					calls	setspd	,<@r5>		; set it now
	004252	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	004254	011546 				  mov	@r5	,-(sp)		; doing it thusly generates less code
	004256	010605 				  mov	sp	,r5		; set pointer to argument list
	004260	004767 	000000G			  jsr	pc	,setspd		; call the subroutine
	004264	005726 				  tst	(sp)+			; pop parameter list from stack
	004266	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     47	004270	012715 	000000G		70$:	mov	#connect,@r5		; say it's time to connect
     48	004274	000415 				br	100$
     49
     50	004276	005015 			80$:	clr	@r5			; turn ring into an info message
     51	004300	005365 	000002 			dec	nrings(r5)		; if more than number in nrings
     52	004304	001011 				bne	100$			; then give up
     53	004306					wrtall	#dia.07			; /63/ "% No answer"<cr><lf>
	004306	012746 	000205'			mov	#dia.07	,-(sp)		; pass the address
	004312	004767 	000000G			call	wrtall			; do it
     54	004316	012715 	000000G			mov	#aborted,(r5)		; flag need to make modem stop
     55	004322	000402 				br	100$
     56	004324	012715 	000000G		90$:	mov	#failed	,(r5)		; come here if modem stopped itself
     57	004330				100$:	unsave	<r3>
	004330	012603 				 mov	(sp)+	,r3
     58	004332	000207 				return
     59
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 24
Check modem's response	; /39/ 4-DEC-1985, Brian Nelson

      1
      2						.sbttl	Format dial string
      3
      4					;	passed:	  r3	= address of buffer to place result
      5					;		argbuf	= the phone number to insert via %S
      6
      7	004334				fmtstr:	save	<r3>
	004334	010346 				 mov	r3	,-(sp)
      8	004336	016402 	000000G			mov	dial.string(r4),r2	; point to the dial format string
      9	004342	105712 			10$:	tstb	(r2)			; done?
     10	004344	001541 				beq	140$			; yes
     11	004346	121227 	000045 			cmpb	(r2)	,#'%		; look for a format effector
     12	004352	001133 				bne	120$			; no
     13
     14	004354	016700 	000000G			mov	argbuf	,r0		; assume phone number insertion
     15	004360	126227 	000001 	000163 		cmpb	1(r2)	,#'s!40		; %S formatting?
     16	004366	001520 				beq	100$			; yes
     17	004370	126227 	000001 	000123 		cmpb	1(r2)	,#'S&137	; check both cases
     18	004376	001514 				beq	100$			; yes
     19
     20	004400	016400 	000000G			mov	dial.wait(r4),r0	; no, assume pause string formatting
     21	004404	126227 	000001 	000160 		cmpb	1(r2)	,#'p!40		; %P for pause string?
     22	004412	001506 				beq	100$			; yes
     23	004414	126227 	000001 	000120 		cmpb	1(r2)	,#'P&137	; check both cases
     24	004422	001502 				beq	100$			; yes
     25
     26	004424	126227 	000001 	000170 		cmpb	1(r2)	,#'x!40		; /BBS/ "%X" for Hayes extended mode?
     27	004432	001404 				beq	20$			; /BBS/ yes
     28	004434	126227 	000001 	000130 		cmpb	1(r2)	,#'X&137	; /BBS/ check both cases
     29	004442	001014 				bne	40$			; /BBS/ no
     30	004444	105767 	000000G		20$:	tstb	xresult			; /BBS/ is there an xmode set?
     31	004450	001407 				beq	30$			; /BBS/ no, kill leading space here
     32	004452	112723 	000130 			movb	#'X&137	,(r3)+		; /BBS/ ya, insert an "X"
     33	004456	116723 	000000G			movb	xresult	,(r3)+		; /BBS/ then the mode, ala "X4"
     34	004462	116723 	000001G			movb	xresult+1,(r3)+		; /BBS/ one char or two?
     35	004466	001063 				bne	110$			; /BBS/ it was two this time..
     36	004470	005303 			30$:	dec	r3			; /BBS/ it was one, fix pointer
     37	004472	000461 				br	110$			; /BBS/ and continue
     38
     39	004474	126227 	000001 	000115 	40$:	cmpb	1(r2)	,#'M&137	; /54/ mode (ie PULSE, TONE)?
     40	004502	001404 				beq	50$			; /54/ found it
     41	004504	126227 	000001 	000155 		cmpb	1(r2)	,#'m!40		; /54/ try lower case also..
     42	004512	001011 				bne	60$			; /54/ nope
     43	004514	016400 	000000G		50$:	mov	dial.pulse(r4),r0	; /54/ assume PULSE dialing
     44	004520	005767 	000000G			tst	pulse			; /54/ ever SET PHONE PULSE or TONE?
     45	004524	001444 				beq	110$			; /54/ no, ignore string
     46	004526	100440 				bmi	100$			; /54/ ya, it's PULSE
     47	004530	016400 	000000G			mov	dial.nopulse(r4),r0	; /54/ it's TONE
     48	004534	000435 				br	100$
     49
     50	004536	126227 	000001 	000102 	60$:	cmpb	1(r2)	,#'B&137	; /54/ SET PHONE BLIND?
     51	004544	001404 				beq	70$			; /54/ ya..
     52	004546	126227 	000001 	000142 		cmpb	1(r2)	,#'b!40		; /54/ no, perhaps lower case?
     53	004554	001006 				bne	80$			; /62/ nope
     54	004556	005767 	000000G		70$:	tst	blind			; /54/ ever do the SET PHONE BLIND?
     55	004562	001425 				beq	110$			; /54/ no, ignore string
     56	004564	016400 	000000G			mov	dial.blind(r4),r0	; /54/ yes, insert the data then
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 24-1
Format dial string

     57	004570	000417 				br	100$
     58
     59	004572	126227 	000001 	000101 	80$:	cmpb	1(r2)	,#'A&137	; /62/ auto-answer format effector?
     60	004600	001404 				beq	90$			; /62/ ya
     61	004602	126227 	000001 	000141 		cmpb	1(r2)	,#'a!40		; /62/ try lower case also..
     62	004610	001014 				bne	120$			; /62/ no, copy data then
     63	004612	016400 	000000G		90$:	mov	ph.noanswer(r4),r0	; /62/ default to not answering phone
     64	004616	005767 	000000G			tst	answer			; /62/ did user SET PHONE ANSWER?
     65	004622	001402 				beq	100$			; /62/ no
     66	004624	016400 	000000G			mov	ph.answer(r4),r0	; /62/ ya, insert answer command
     67
     68	004630	112023 			100$:	movb	(r0)+	,(r3)+		; copy a byte please
     69	004632	001376 				bne	100$			; not a null, next please
     70	004634	005303 				dec	r3			; fix current pointer up
     71	004636	005202 			110$:	inc	r2			; skip over the "%" please
     72	004640	000401 				br	130$			; next please
     73	004642	111223 			120$:	movb	(r2)	,(r3)+		; not formatting, copy character
     74	004644	005202 			130$:	inc	r2			; skip over current character now
     75	004646	000635 				br	10$			; next
     76
     77	004650	105013 			140$:	clrb	(r3)			; ensure dial string is .asciz
     78	004652					unsave	<r3>
	004652	012603 				 mov	(sp)+	,r3
     79	004654	000207 				return
     80
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 25
Format dial string

      1
      2						.sbttl	Wait for a response	; /BBS/ moderately revised..
      3
      4					;	passed:	 2(sp)	= string
      5					;		 4(sp)	= time-out
      6					;	return:	   r0	= <> for success, 0 for time out
      7
      8	004656				waitfor:save	<r2,r3,r4>		; this decrements stack pointer 6
	004656	010246 				 mov	r2	,-(sp)
	004660	010346 				 mov	r3	,-(sp)
	004662	010446 				 mov	r4	,-(sp)
      9	004664	016604 	000010 			mov	2+6(sp)	,r4		; string we are expecting
     10	004670	016603 	000012 			mov	4+6(sp)	,r3		; time-out in seconds
     11	004674					mul	clkflg	,r3		; make it ticks
	004674	016746 	000000G			mov	clkflg	,-(sp)		; pass multiplier to p$mul
	004700	010346 				mov	r3	,-(sp)		; pass multiplicand too
	004702	004767 	000000G			call	p$mul		mute			; allow strike any key abort?
     17	004722	001011 				bne	30$			; no
     18	004724	004767 	000000G			call	chkabo			; strike any key to abort
     19	004730	005700 				tst	r0			; get anything?
     20	004732	001405 				beq	30$			; nope
     21	004734	005267 	000000G			inc	cccnt			; fake abort so modem is stopped
     22	004740	004767 	000000G			call	clrcns			; eat LF after a CR, etc..
     23	004744	000441 				br	60$			; and bail out
     24
     25	004746	005303 			30$:	dec	r3			; one less tick to wait
     26	004750	001437 				beq	60$			; no more ticks left
     27	004752					calls	xbinrea	,<#-1>		; this actually waits one tick
	004752	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	004754	012746 	177777 			  mov	#-1	,-(sp)		; doing it thusly generates less code
	004760	010605 				  mov	sp	,r5		; set pointer to argument list
	004762	004767 	000000G			  jsr	pc	,xbinrea		; call the subroutine
	004766	005726 				  tst	(sp)+			; pop parameter list from stack
	004770	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     28	004772	005700 				tst	r0			; success?
     29	004774	001350 				bne	20$			; no
     30	004776	142701 	177600 			bicb	#^c<177>,r1		; remove parity always
     31	005002	120127 	000015 			cmpb	r1	,#cr		; is it a return?
     32	005006	001413 				beq	40$			; ya, don't echo it
     33	005010	120127 	000012 			cmpb	r1	,#lf		; is it a line feed?
     34	005014	001410 				beq	40$			; ya, don't echo it
     35	005016	110100 				movb	r1	,r0		; get a copy of it
     36	005020	001736 				beq	20$			; dump nulls
     37	005022	005767 	000124'			tst	mute			; echo to TT this time?
     38	005026	001003 				bne	40$			; no, don't echo modem I/O
     39	005030	010016 				mov	r0	,@sp		; set "msg rec'd" flag
     40	005032	004767 	000000G			call	writ1char		; keep user informed of what's up..
     41	005036	120102 			40$:	cmpb	r1	,r2		; did we get the correct character?
     42	005040	001326 				bne	20$			; no, keep waiting then
     43	005042	000723 				br	10$			; found it, check for next character
     44
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 25-1
Wait for a response	; /BBS/ moderately revised..

     45	005044	010600 			50$:	mov	sp	,r0		; success
     46	005046	000401 				br	70$
     47	005050	005000 			60$:	clr	r0			; failure
     48	005052	005726 			70$:	tst	(sp)+			; was anything dumped to TT?
     49	005054	001402 				beq	80$			; nope
     50	005056					.newline			; ya, tag it with a newline
	005056	004767 	000000G			call	l$pcrlf
     51	005062				80$:	unsave	<r4,r3,r2>
	005062	012604 				 mov	(sp)+	,r4
	005064	012603 				 mov	(sp)+	,r3
	005066	012602 				 mov	(sp)+	,r2
     52	005070	011666 	000004 			mov	(sp)	,4(sp)		; move return address up and fix stack
     53	005074	022626 				cmp	(sp)+	,(sp)+		; here instead of in calling macro
     54	005076	000207 				return
     55
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 26
Wait for a response	; /BBS/ moderately revised..

      1
      2						.sbttl	Eat junk from modem
      3
      4	005100				eatjunk:save	<r0,r1>
	005100	010046 				 mov	r0	,-(sp)
	005102	010146 				 mov	r1	,-(sp)
      5	005104				10$:	ttgetc	#-1			; /BBS/ speed up junk consumption
	005104	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	005106	012746 	177777 			  mov	#-1	,-(sp)		; doing it thusly generates less code
	005112	010605 				  mov	sp	,r5		; set pointer to argument list
	005114	004767 	000000G			  jsr	pc	,xbinread		; call the subroutine
	005120	005726 				  tst	(sp)+			; pop parameter list from stack
	005122	012605 				  mov	(sp)+	,r5		; /63/ restore r5
      6	005124	005700 				tst	r0			; /BBS/ and thus redial faster..
      7	005126	001766 				beq	10$			; loop until nothing remains
      8	005130					unsave	<r1,r0>
	005130	012601 				 mov	(sp)+	,r1
	005132	012600 				 mov	(sp)+	,r0
      9	005134	000207 				return
     10
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 27
Eat junk from modem

      1
      2						.sbttl	Send a string to the modem
      3
      4	005136				do.put:	strlen	r1			; /63/ get length
	005136	010100 				mov	r1	,r0
	005140	004767 	000000G			call	l$len
      5	005144	005700 				tst	r0			; anything to send?
      6	005146	001410 				beq	10$			; no
      7	005150					calls	binwri	,<r1,r0>	; ya, length is in r0
	005150	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	005152	010046 				        mov	r0	,-(sp)	; push it
	005154	010146 				        mov	r1	,-(sp)	; push it
	005156	010605 				  mov	sp	,r5		; set up the argument list pointer
	005160	004767 	000000G			  jsr	pc	,binwri		; and go to the routine
	005164	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	005166	012605 				  mov	(sp)+	,r5		; /63/ restore r5
      8	005170	000207 			10$:	return
      9
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 28
Send a string to the modem

      1
      2						.sbttl	SHOW MODEM, SHOW DIAL	; /BBS/ heavily hacked
      3
      4	005172	004767 	000000G		shodia::call	loamdm			; /63/ ensure correct overlay loaded
      5	005176	016704 	000000G			mov	modtype	,r4		; get address of descriptor
      6	005202	001005 				bne	10$			; got it
      7	005204					direrr	#er$mdm			; no modem type has been set
	005204	012746 	000000G			mov	#er$mdm	,-(sp)
	005210	004767 	000000G			call	direr$
      8	005214	000207 				return
      9
     10	005216	012703 	000606'		10$:	mov	#deslist,r3		; /63/ info list start
     11	005222	112301 			20$:	movb	(r3)+	,r1		; /62/ type 2=on/off,1=string,0=number
     12	005224	112302 				movb	(r3)+	,r2		; /62/ offset, zero implies end
     13	005226	001456 				beq	100$			; all done
     14	005230	060402 				add	r4	,r2		; move to the correct offset
     15	005232	010346 				mov	r3	,-(sp)		; /62/ save the header address
     16	005234	105723 			30$:	tstb	(r3)+			; now look for the end of it
     17	005236	001376 				bne	30$			; not yet
     18	005240	105301 				decb	r1			; /62/ determine data type
     19	005242	003027 				bgt	70$			; /62/ it's "2"  goto on/off displayer
     20	005244	001407 				beq	40$			; /62/ it's "1"  goto string handler
     21	005246					wrtall	(sp)+			; /62/ dump the header
	005246	012646 				mov	(sp)+	,-(sp)		; pass the address
	005250	004767 	000000G			call	wrtall			; do it
     22	005254	011200 				mov	@r2	,r0		; it is "0"  copy number to display
     23	005256	004767 	000000G			call	L10266			; write it to terminal
     24	005262	000435 				br	90$			; next please
     25
     26	005264	011200 			40$:	mov	(r2)	,r0		; get the string address
     27	005266	001402 				beq	50$			; /62/ nothing there
     28	005270	105710 				tstb	@r0			; again
     29	005272	001002 				bne	60$			; /62/ there is something to see
     30	005274	005726 			50$:	tst	(sp)+			; /62/ nothing, dump unused header
     31	005276	000751 				br	20$			; /62/ skip newline, try next one
     32	005300				60$:	wrtall	(sp)+			; /62/ dump the header
	005300	012646 				mov	(sp)+	,-(sp)		; pass the address
	005302	004767 	000000G			call	wrtall			; do it
     33	005306	004767 	000000G			call	unfmts			; convert and print it
     34	005312					wrtall	r0			; do it
	005312	010046 				mov	r0	,-(sp)		; pass the address
	005314	004767 	000000G			call	wrtall			; do it
     35	005320	000416 				br	90$			; next
     36
     37	005322				70$:	wrtall	(sp)+			; /62/ dump the header
	005322	012646 				mov	(sp)+	,-(sp)		; pass the address
	005324	004767 	000000G			call	wrtall			; do it
     38	005330	011200 				mov	(r2)	,r0		; /62/ get the data
     39	005332	001405 				beq	80$			; /62/ 0 = no
     40	005334					wrtall	#dia.08			; /63/ anything_else = "Yes"
	005334	012746 	000223'			mov	#dia.08	,-(sp)		; pass the address
	005340	004767 	000000G			call	wrtall			; do it
     41
     42	005344	000404 				br	90$			; /62/
     43	005346				80$:	wrtall	#dia.09			; /63/ "No"
	005346	012746 	000227'			mov	#dia.09	,-(sp)		; pass the address
	005352	004767 	000000G			call	wrtall			; do it
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 28-1
SHOW MODEM, SHOW DIAL	; /BBS/ heavily hacked

     44	005356				90$:	.newline
	005356	004767 	000000G			call	l$pcrlf
     45	005362	000717 				br	20$			; next
     46
     47	005364				100$:	wrtall	#dia.10			; /63/ "Dial time-out secs: "
	005364	012746 	000232'			mov	#dia.10	,-(sp)		; pass the address
	005370	004767 	000000G			call	wrtall			; do it
     48	005374	016700 	000000G			mov	diatmo	,r0		; /62/ get time-out time
     49	005400	004767 	000000G			call	L10266			; /62/ display it
     50	005404					.newline			; /62/
	005404	004767 	000000G			call	l$pcrlf
     51
     52	005410					wrtall	#dia.11			; /63/ "Settle-time ticks:  "
	005410	012746 	000257'			mov	#dia.11	,-(sp)		; pass the address
	005414	004767 	000000G			call	wrtall			; do it
     53	005420	016700 	000000G			mov	settle	,r0		; get settle time
     54	005424	004767 	000000G			call	L10266			; display it
     55	005430					.newline			; /62/
	005430	004767 	000000G			call	l$pcrlf
     56
     57	005434	005046 				clr	-(sp)			; a flag, if <> something found
     58
     59	005436	016401 	000000G			mov	ph.noanswer(r4),r1	; /62/ default to not answering phone
     60	005442	005767 	000000G			tst	answer			; /62/ did user SET PHONE ANSWER?
     61	005446	001402 				beq	110$			; /62/ no
     62	005450	016401 	000000G			mov	ph.answer(r4),r1	; /62/ ya, insert answer command
     63	005454	105711 			110$:	tstb	@r1			; /62/ if there is any..
     64	005456	001404 				beq	120$			; /62/ there isn't
     65	005460	112702 	000101 			movb	#'A&137	,r2		; /62/ there is, and it's this type
     66	005464	004767 	000422 			call	foreff			; /62/ go display it
     67
     68	005470	005767 	000000G		120$:	tst	blind			; ever SET PHONE BLIND?
     69	005474	001410 				beq	130$			; no, ignore string
     70	005476	016401 	000000G			mov	dial.blind(r4),r1	; yes, insert the data then
     71	005502	105711 				tstb	@r1			; if there is any..
     72	005504	001404 				beq	130$			; there isn't
     73	005506	112702 	000102 			movb	#'B&137	,r2		; /62/ there is, and it's this type
     74	005512	004767 	000374 			call	foreff			; go display it
     75
     76	005516	016401 	000000G		130$:	mov	dial.pulse(r4),r1	; assume PULSE dialing
     77	005522	005767 	000000G			tst	pulse			; ever SET PHONE PULSE or TONE?
     78	005526	001411 				beq	150$			; no, ignore string
     79	005530	100402 				bmi	140$			; ya, it's PULSE
     80	005532	016401 	000000G			mov	dial.nopulse(r4),r1	; it's TONE
     81	005536	105711 			140$:	tstb	@r1			; anything defined?
     82	005540	001404 				beq	150$			; nope
     83	005542	112702 	000115 			movb	#'M&137	,r2		; /62/ there is, and it's this type
     84	005546	004767 	000340 			call	foreff			; go display it
     85
     86	005552	105767 	000000G		150$:	tstb	xresult			; anything set here?
     87	005556	001423 				beq	170$			; nope..
     88	005560	005716 				tst	(sp)			; /62/ has this stuff been identified?
     89	005562	001005 				bne	160$			; /62 ya
     90	005564					wrtall	#msg$fmt		; /62/ no, do that now
	005564	012746 	000472'			mov	#msg$fmt	,-(sp)		; pass the address
	005570	004767 	000000G			call	wrtall			; do it
     91	005574	010616 				mov	sp	,(sp)		; /62/ and set flag it has been done
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 28-2
SHOW MODEM, SHOW DIAL	; /BBS/ heavily hacked

     92	005576				160$:	wrtall	#dia.12			; /63/ ya, dump a header: '%X = "X'
	005576	012746 	000304'			mov	#dia.12	,-(sp)		; pass the address
	005602	004767 	000000G			call	wrtall			; do it
     93	005606					wrtall	#xresult		; and the actual number
	005606	012746 	000000G			mov	#xresult	,-(sp)		; pass the address
	005612	004767 	000000G			call	wrtall			; do it
     94	005616	012700 	000042 			mov	#'"	,r0		; /62/
     95	005622	004767 	000000G			call	writ1char		; /62/
     96
     97	005626	005726 			170$:	tst	(sp)+			; /62/ dump formatter flag buffer
     98	005630	001402 				beq	180$			; /62/ no newline needed..
     99	005632					.newline			; done with format effectors
	005632	004767 	000000G			call	l$pcrlf
    100
    101	005636				180$:	wrtall	#dia.13			; /63/ "Binary-responses:   "
	005636	012746 	000314'			mov	#dia.13	,-(sp)		; pass the address
	005642	004767 	000000G			call	wrtall			; do it
    102	005646	005764 	000000G			tst	res.bin(r4)		; /62/ on or off?
    103	005652	001405 				beq	190$			; /62/ 0 = no
    104	005654					wrtall	#dia.08			; /63/ anything_else = "Yes"
	005654	012746 	000223'			mov	#dia.08	,-(sp)		; pass the address
	005660	004767 	000000G			call	wrtall			; do it
    105	005664	000404 				br	200$			; /62/
    106	005666				190$:	wrtall	#dia.09			; /63/ "No"
	005666	012746 	000227'			mov	#dia.09	,-(sp)		; pass the address
	005672	004767 	000000G			call	wrtall			; do it
    107	005676				200$:	.newline			; /62/
	005676	004767 	000000G			call	l$pcrlf
    108
    109	005702	016403 	000000G			mov	res.head(r4),r3		; response header
    110	005706	001477 				beq	290$			; nothing present
    111	005710					wrtall	#dia.14			; /63/ "Result strings:"<cr><lf>
	005710	012746 	000341'			mov	#dia.14	,-(sp)		; pass the address
	005714	004767 	000000G			call	wrtall			; do it
    112	005720	010300 			210$:	mov	r3	,r0		; /62/ get the response address
    113	005722	001471 				beq	290$			; all done
    114	005724	062700 	000004 			add	#4	,r0		; /62/ offset to text
    115	005730	004767 	000000G			call	unfmts			; /62/ convert it
    116	005734					wrtall	r0			; /62/ and print it
	005734	010046 				mov	r0	,-(sp)		; pass the address
	005736	004767 	000000G			call	wrtall			; do it
    117	005742					strlen	r0			; /62/ ..more efficient
	005742	010000 				mov	r0	,r0
	005744	004767 	000000G			call	l$len
    118	005750	162700 	000022 			sub	#col.act,r0		; number of blanks needed to pad
    119	005754	005400 				neg	r0			; make it positive
    120	005756	010005 				mov	r0	,r5		; save it in a safe place
    121	005760	003406 				ble	230$			; avoid this please
    122	005762	012700 	000040 			mov	#space	,r0		; load up a space
    123	005766	004767 	000000G		220$:	call	writ1ch			; this way is more efficient
    124	005772					sob	r5	,220$		; loop until done
	005772	005305 				dec	r5
	005774	001374 				bne	220$
    125
    126	005776	016300 	000002 		230$:	mov	2(r3)	,r0		; what is the message class?
    127	006002	100430 				bmi	270$			; if < it's failure to connect
    128	006004	005300 			240$:	dec	r0			; if = 1 it's ringing
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 28-3
SHOW MODEM, SHOW DIAL	; /BBS/ heavily hacked

    129	006006	001421 				beq	260$			; it was one, because now it's 0
    130	006010					wrtall	#dia.15			; /63/ "Success"
	006010	012746 	000363'			mov	#dia.15	,-(sp)		; pass the address
	006014	004767 	000000G			call	wrtall			; do it
    131	006020	005300 				dec	r0			; if = 2 connect w/o speed check
    132	006022	001410 				beq	250$			; it wuz 2
    133	006024	005200 				inc	r0			; restore
    134	006026	005200 				inc	r0			; r0
    135	006030					wrtall	#msg$dte		; "  DTE is forced to "
	006030	012746 	000445'			mov	#msg$dte	,-(sp)		; pass the address
	006034	004767 	000000G			call	wrtall			; do it
    136	006040	004767 	000000G			call	L10266			; tag above with speed
    137	006044				250$:	.newline
	006044	004767 	000000G			call	l$pcrlf
    138	006050	000414 				br	280$
    139	006052				260$:	wrtall	#dia.16			; /63/ "Rings+1"<cr><lf>
	006052	012746 	000373'			mov	#dia.16	,-(sp)		; pass the address
	006056	004767 	000000G			call	wrtall			; do it
    140	006062	000407 				br	280$
    141	006064	020027 	000000G		270$:	cmp	r0	,#con38400	; /62/ kludge to see if it's 38.4kb
    142	006070	001745 				beq	240$			; /62/ it is..
    143	006072					wrtall	#dia.17			; /63/ "Failure"<cr><lf>
	006072	012746 	000405'			mov	#dia.17	,-(sp)		; pass the address
	006076	004767 	000000G			call	wrtall			; do it
    144	006102	011303 			280$:	mov	(r3)	,r3		; pick up link to..
    145	006104	000705 				br	210$			; ..next please
    146
    147	006106	005000 			290$:	clr	r0			; /62/
    148	006110	000207 				return
    149
    150	006112	005766 	000002 		foreff:	tst	2(sp)			; /62/ need to print header?
    151	006116	001006 				bne	10$			; /62/ nope..
    152	006120					wrtall	#msg$fmt		; /62/ ya
	006120	012746 	000472'			mov	#msg$fmt	,-(sp)		; pass the address
	006124	004767 	000000G			call	wrtall			; do it
    153	006130	010666 	000002 			mov	sp	,2(sp)		; /62/ but not anymore
    154	006134	012700 	000045 		10$:	mov	#'%	,r0		; /62/ a percent sign char
    155	006140	004767 	000000G			call	writ1char		; /62/ dump it to the terminal
    156	006144	110200 				movb	r2	,r0		; /62/ the format effector character
    157	006146	004767 	000000G			call	writ1char		; /62/ now dump it to tt
    158	006152					wrtall	#prefix			; /62/ do some display formatting
	006152	012746 	000573'			mov	#prefix	,-(sp)		; pass the address
	006156	004767 	000000G			call	wrtall			; do it
    159	006162					wrtall	r1			; /62/ now display what is inserted
	006162	010146 				mov	r1	,-(sp)		; pass the address
	006164	004767 	000000G			call	wrtall			; do it
    160	006170					wrtall	#tripsp			; /62/ format display
	006170	012746 	000600'			mov	#tripsp	,-(sp)		; pass the address
	006174	004767 	000000G			call	wrtall			; do it
    161	006200	000207 				return
    162
    163	006202					des	1 ,mod.string	,<Modem name:         >
	000606	   001 	   000G			.byte	1	,mod.string		; 1_0=integer, 1_1=string
	000610	   115 	   157 	   144 		.asciz	@Modem name:         @			; /62/ 1_2=on/off
    164	006202					des	1 ,mod.comment	,<Modem type:         >
	000635	   001 	   000G			.byte	1	,mod.comment		; 1_0=integer, 1_1=string
	000637	   115 	   157 	   144 		.asciz	@Modem type:         @			; /62/ 1_2=on/off
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 28-4
SHOW MODEM, SHOW DIAL	; /BBS/ heavily hacked

    165	006202					des	1 ,wake.string	,<Wakeup string:      >
	000664	   001 	   000G			.byte	1	,wake.string		; 1_0=integer, 1_1=string
	000666	   127 	   141 	   153 		.asciz	@Wakeup string:      @			; /62/ 1_2=on/off
    166	006202					des	0 ,wake.rate	,<Wake-rate in ticks: >
	000713	   000 	   000G			.byte	0	,wake.rate		; 0_0=integer, 0_1=string
	000715	   127 	   141 	   153 		.asciz	@Wake-rate in ticks: @			; /62/ 0_2=on/off
    167	006202					des	1 ,wake.prompt	,<Response to wakeup: >
	000742	   001 	   000G			.byte	1	,wake.prompt		; 1_0=integer, 1_1=string
	000744	   122 	   145 	   163 		.asciz	@Response to wakeup: @			; /62/ 1_2=on/off
    168	006202					des	1 ,dial.string	,<Dial FORMAT string: >
	000771	   001 	   000G			.byte	1	,dial.string		; 1_0=integer, 1_1=string
	000773	   104 	   151 	   141 		.asciz	@Dial FORMAT string: @			; /62/ 1_2=on/off
    169	006202					des	0 ,dial.rate	,<Dial-rate in ticks: >
	001020	   000 	   000G			.byte	0	,dial.rate		; 0_0=integer, 0_1=string
	001022	   104 	   151 	   141 		.asciz	@Dial-rate in ticks: @			; /62/ 0_2=on/off
    170	006202					des	1 ,dial.wait	,<Pause character(s): >
	001047	   001 	   000G			.byte	1	,dial.wait		; 1_0=integer, 1_1=string
	001051	   120 	   141 	   165 		.asciz	@Pause character(s): @			; /62/ 1_2=on/off
    171	006202					des	1 ,dial.ack	,<Dial-acknowledge:   >
	001076	   001 	   000G			.byte	1	,dial.ack		; 1_0=integer, 1_1=string
	001100	   104 	   151 	   141 		.asciz	@Dial-acknowledge:   @			; /62/ 1_2=on/off
    172	006202					des	1 ,dmod.string	,<"Initiate" string:  >
	001125	   001 	   000G			.byte	1	,dmod.string		; 1_0=integer, 1_1=string
	001127	   042 	   111 	   156 		.asciz	@"Initiate" string:  @			; /62/ 1_2=on/off
    173	006202					des	1 ,dmod.prompt	,<"Initiate" prompt:  >
	001154	   001 	   000G			.byte	1	,dmod.prompt		; 1_0=integer, 1_1=string
	001156	   042 	   111 	   156 		.asciz	@"Initiate" prompt:  @			; /62/ 1_2=on/off
    174	006202					des	1 ,dial.confirm	,<"Confirm" string:   >
	001203	   001 	   000G			.byte	1	,dial.confirm		; 1_0=integer, 1_1=string
	001205	   042 	   103 	   157 		.asciz	@"Confirm" string:   @			; /62/ 1_2=on/off
    175	006202					des	1 ,dial.go	,<"Confirm" ack:      >
	001232	   001 	   000G			.byte	1	,dial.go		; 1_0=integer, 1_1=string
	001234	   042 	   103 	   157 		.asciz	@"Confirm" ack:      @			; /62/ 1_2=on/off
    176	006202					des	2 ,dial.echo	,<Echoes dial string: >
	001261	   002 	   000G			.byte	2	,dial.echo		; 2_0=integer, 2_1=string
	001263	   105 	   143 	   150 		.asciz	@Echoes dial string: @			; /62/ 2_2=on/off
    177	006202					des	2 ,init.once	,<Redial w/o reinit:  >
	001310	   002 	   000G			.byte	2	,init.once		; 2_0=integer, 2_1=string
	001312	   122 	   145 	   144 		.asciz	@Redial w/o reinit:  @			; /62/ 2_2=on/off
    178	006202					des	1 ,dial.blind	,<Blind dial string:  >
	001337	   001 	   000G			.byte	1	,dial.blind		; 1_0=integer, 1_1=string
	001341	   102 	   154 	   151 		.asciz	@Blind dial string:  @			; /62/ 1_2=on/off
    179	006202					des	1 ,dial.pulse	,<Pulse dial string:  >
	001366	   001 	   000G			.byte	1	,dial.pulse		; 1_0=integer, 1_1=string
	001370	   120 	   165 	   154 		.asciz	@Pulse dial string:  @			; /62/ 1_2=on/off
    180	006202					des	1 ,dial.nopulse	,<Tone dial string:   >
	001415	   001 	   000G			.byte	1	,dial.nopulse		; 1_0=integer, 1_1=string
	001417	   124 	   157 	   156 		.asciz	@Tone dial string:   @			; /62/ 1_2=on/off
    181	006202					des	1 ,dial.xabort	,<Dial abort string:  >
	001444	   001 	   000G			.byte	1	,dial.xabort		; 1_0=integer, 1_1=string
	001446	   104 	   151 	   141 		.asciz	@Dial abort string:  @			; /62/ 1_2=on/off
    182	006202					des	1 ,dial.idle	,<Reset/idle string:  >
	001473	   001 	   000G			.byte	1	,dial.idle		; 1_0=integer, 1_1=string
	001475	   122 	   145 	   163 		.asciz	@Reset/idle string:  @			; /62/ 1_2=on/off
    183	006202					des	1 ,ph.answer	,<Enable autoanswer:  >
	001522	   001 	   000G			.byte	1	,ph.answer		; 1_0=integer, 1_1=string
	001524	   105 	   156 	   141 		.asciz	@Enable autoanswer:  @			; /62/ 1_2=on/off
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 28-5
SHOW MODEM, SHOW DIAL	; /BBS/ heavily hacked

    184	006202					des	1 ,ph.noasnwer	,<Disable autoanswer: >
	001551	   001 	   000G			.byte	1	,ph.noasnwer		; 1_0=integer, 1_1=string
	001553	   104 	   151 	   163 		.asciz	@Disable autoanswer: @			; /62/ 1_2=on/off
    185	006202					des
	001600	   000 	   000 			.byte	0	,0
    186
    187		000001 				.end
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 28-6
Symbol table

ABORT   000000R     003	DESLIS  000606R     003	ER$NDF= ****** GX	MOD.NE= ****** GX	SET.DT  000456R     002
ABORTE= ****** GX	DIAL.A= ****** GX	ER$NNF= ****** GX	MOD.ST= ****** GX	SET.MO  000340R     002
ALSIZE= 001000   	DIAL.B= ****** GX	ER$NPN= ****** GX	MREADY= ****** GX	SEVER$= 000010
ANSWER= ****** GX	DIAL.C= ****** GX	ER$PLS= ****** GX	MSG$DT  000445R     003	SHODIA  005172RG    002
ARGBUF= ****** GX	DIAL.E= ****** GX	ER$UNM= ****** GX	MSG$FM  000472R     003	SHO$LI= ****** GX
AT.ALL  000177   	DIAL.G= ****** GX	ER$WKE= ****** GX	MUTE    000124R     004	SIGNON= ****** GX
AT.CDT  000001   	DIAL.I= ****** GX	ER$WKS= ****** GX	NODPRO  000517R     003	SOH   = 000001
AT.INF  000002   	DIAL.N= ****** GX	ESC   = 000033   	NOD.AC  000555R     003	SPACE = 000040
AT.LEN  000004   	DIAL.P= ****** GX	FAILED= ****** GX	NOD.GO  000540R     003	SPARE1= ****** GX
AT.ON   100000   	DIAL.R= ****** GX	FATAL$= 000020   	NONEIS= 000001   	STATUS= 000000
AT.PRO  000010   	DIAL.S= ****** GX	FF    = 000014   	NOREPL= 000007   	STRCPY= ****** GX
AT.SYS  000020   	DIAL.T= ****** GX	FINDMO  001432R     002	NOSCOP= 000000   	SUCCS$= 000001
AT.TYP  000040   	DIAL.W= ****** GX	FINDNU  001670R     002	NRINGS= 000002   	SUSPEN= ****** GX
AT.XLE  000100   	DIAL.X= ****** GX	FIXSPE  001376R     002	OPENTT= ****** GX	SY.INI= ****** GX
BELL  = 000007   	DIATMO= ****** GX	FMTSTR  004334R     002	PAR$EV  000002   	TAB   = 000011
BELLS   000030R     003	DIA.ER  000322R     002	FOREFF  006112R     002	PAR$MA  000003   	TERMIN  177777
BINARY  000001   	DIA.01  000047R     003	GETATN  002130R     002	PAR$NO  000000   	TEXT    000000
BINWRI= ****** GX	DIA.02  000066R     003	GETSTS  003562R     002	PAR$OD  000001   	TILDE = 000176
BLIND = ****** GX	DIA.03  000112R     003	INCSTS= ****** GX	PAR$SP  000004   	TIME.S= ****** GX
BS    = 000010   	DIA.04  000136R     003	INFOMS= ****** GX	PHNUM = ****** GX	TRIPSP  000600R     003
BUFFER  000000R     004	DIA.05  000144R     003	INIT.O= ****** GX	PH.ANS= ****** GX	TTNAME= ****** GX
B4SPEE= ****** GX	DIA.06  000150R     003	INQCD = ****** GX	PH.NOA= ****** GX	TTSPEE= ****** GX
CAPA.A= 000010   	DIA.07  000205R     003	INSTR = ****** GX	PNHEAD= ****** GX	TTY   = 000001
CAPA.L= 000002   	DIA.08  000223R     003	JSW   = 000044   	PREFIX  000573R     003	TTYFIN= ****** GX
CAPA.S= 000004   	DIA.09  000227R     003	KRTINC= 000001   	PULSE = ****** GX	TTYHAN= ****** GX
CCCNT = ****** GX	DIA.10  000232R     003	LF    = 000012   	P$MUL = ****** GX	UNFMTS= ****** GX
CHKABO= ****** GX	DIA.11  000257R     003	LINKST= ****** GX	P.CAPA= 000011   	UPCASE= ****** GX
CLKFLG= ****** GX	DIA.12  000304R     003	LN$CNT= 000003   	P.CHKT= 000007   	USERRB= 000053
CLRCNS= ****** GX	DIA.13  000314R     003	LN$MAX= 000120   	P.EOL = 000004   	VT100 = 000002
COL.AC= 000022   	DIA.14  000341R     003	LOAMDM= ****** GX	P.MXL1= 000013   	VT200 = 000003
COMMA = 000054   	DIA.15  000363R     003	LOCSIZ= 000004   	P.MXL2= 000014   	WAITFO  004656R     002
CONNEC= ****** GX	DIA.16  000373R     003	LOG$AL= 000003   	P.NPAD= 000002   	WAKE.P= ****** GX
CON$ES= 000034   	DIA.17  000405R     003	LOG$CO= 000002   	P.PADC= 000003   	WAKE.R= ****** GX
CON384= ****** GX	DIA.18  000417R     003	LOG$DE= 000020   	P.QBIN= 000006   	WAKE.S= ****** GX
COPYZ$= ****** GX	DIA.19  000425R     003	LOG$IO= 000010   	P.QCTL= 000005   	WARN$ = 000002
CR    = 000015   	DIRER$= ****** GX	LOG$ON= 040000   	P.REPT= 000010   	WRIT1C= ****** GX
CTRL$N= 000016   	DMOD.P= ****** GX	LOG$OP= 100000   	P.SPSI= 000000   	WRTALL= ****** GX
CTRL$O= 000017   	DMOD.S= ****** GX	LOG$PA= 000001   	P.TIME= 000001   	XBINRE= ****** GX
C$CONN= ****** GX	DODIAL  002674R     002	LOG$RP= 000004   	P.VEND= 000017   	XOFF  = 000023
C$DIAL  000730RG    002	DOT   = 000056   	L$LEN = ****** GX	P.WIND= 000012   	XON   = 000021
C$HANG  000260RG    002	DO.PUT  005136R     002	L$NOLF= ****** GX	REINIT  000540RG    002	XREDIA= ****** GX
C$IDLE  001252RG    002	EATJUN  005100R     002	L$PCRL= ****** GX	RES.BI= ****** GX	XRESUL= ****** GX
C$REDI  000576RG    002	ERBFSI= 000170   	L$VAL = ****** GX	RES.HE= ****** GX	X.RESU= ****** GX
C.CRLF= 000004   	ERRBYT= 000052   	L10012= ****** GX	RETRIE  000126R     004	$ALLSI= 001144
C.LCUC= 000040   	ERROR$= 000004   	L10266= ****** GX	R50DEV= ****** GX	$$    = 000002
C.LSPA= 000010   	ERRTXT= ****** GX	MAXLNG= 001130   	SCOLON= 000073   	$$TRIP= 000000
C.SSPA= 000020   	ER$ABK= ****** GX	MAXPAK  000136   	SETSPD= ****** GX	$$1   = 000001
C.TSPA= 000200   	ER$DCD= ****** GX	MODEM = ****** GX	SETTLE= ****** GX	$$2   = 000000
DECNAT  000002   	ER$IDL= ****** GX	MODTYP= ****** GX	SET$DT  000242RG    002	$$5   = 000001
DEFMSG  000033R     003	ER$INR= ****** GX	MOD.CO= ****** GX	SET$MO  000000RG    002	.DEFAU  004042R     002
DEL   = 000177   	ER$MDM= ****** GX

. ABS.	000000    000	(RW,I,GBL,ABS,OVR)
      	000000    001	(RW,I,LCL,REL,CON)
$CODE 	006202    002	(RO,I,LCL,REL,CON)
$PDATA	001602    003	(RO,D,LCL,REL,CON)
$RWDAT	000130    004	(RW,D,LCL,REL,CON)
KRTDIA	Dial command and relate	MACRO V05.03b  00:01  Page 28-7
Symbol table

Errors detected:  0

*** Assembler statistics


Work  file  reads: 43
Work  file writes: 45
Size of work file: 13168 Words  ( 52 Pages)
Size of core pool: 12544 Words  ( 49 Pages)
Operating  system: RT-11

Elapsed time: 00:00:00.41
KRTDIA,KRTDIA=KRTNHD,KRTDIA
