.MAIN.	MACRO V05.03b  00:01
Table of contents

    1-   1	KRTNHD	EIS macros for a non-EIS CPU
    5-   1	KRTMAC	Various handy constants and macros
    7-   2	Utility macros
    9-   1	KRTDEF	Packet types (edited from VMS Kermit)
    9-  11	Protocol V1.0 message types
    9-  22	Protocol V2.0 message types
    9-  29	Protocol V4.0 message types
    9-  35	Generic Kermit commands
    9-  57	Acknowledgment modifiers (V4.0)
    9-  63	End of file packet modifier
    9-  67	Send/receive states
   11-   2	Misc defaults
   12-   2	Local and global read-only data
   13-   3	Read incoming packet
   14-   2	RPACK$ wait for a start of packet char (SOH)
   15-   2	RPACK$ initialization
   16-   2	RPACK$ read with time-out
   17-   2	RPACK$ extended header type 0 for long packets
   18-   2	RPACK$ get and convert the checksum
   19-   2	RPACK$ end of packet housekeeping
   20-   2	RPACK$ statistics, logging, resonating packets fix
   21-   2	RPACK$ packet logging
   22-   2	RPACK$ raw I/O logging, chars to RPACK debug display
   23-   2	Send a packet
   24-   2	SPACK$ handshaking
   25-   2	SPACK$ logging, padding, packet type stats
   26-   2	SPACK$ compute checksum
   27-   2	SPACK$ pseudo random number generator for testing
   28-   2	SPACK$ log to disk
   29-   2	Compute checksum
   30-   2	CRC calculation
   31-   2	Buffer file being sent	; /63/ moved back here for speed..
   32-   2	Actually quote and stuff the char for BUFFIL
   33-   2	Get the next char
   34-   2	Error message handler
   35-   2	Print message if not remote, and copy to logfile
   36-   2	Logfile error handler	; /62/ all new
   37-   2	Process retry and sync errors
   38-   2	Compute parity for an outgoing 8-bit link
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 1
KRTNHD	EIS macros for a non-EIS CPU

      1						.sbttl	KRTNHD	EIS macros for a non-EIS CPU
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					; /62/	27-Jul-93  Billy Youdelman  V03.62
      6					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
      7					;
      8					;	Assemble Kermit-11 modules with this for use on a
      9					;	non-EIS CPU.  This calls p$mul and p$div, assembly
     10					;	of which into KRTSUB depends on defining "NONEIS".
     11					;	KRTASM.NON assembles everything for non-EIS use.
     12
     13					;	10-Apr-84  09:37:15  Brian Nelson
     14
     15		000001 				NONEIS	=	1		; force p$mul,p$div into KRTSUB.MAC
     16
     17						.macro	mul	src,reg		; single precision
     18						.ntype	$$	,reg		; save number of input register
     19						mov	src	,-(sp)		; pass multiplier to p$mul
     20						mov	reg	,-(sp)		; pass multiplicand too
     21						call	p$mul			; multiply, returns a 16-bit product
     22						.iif eq <$$-1>	mov	(sp)+	,r1	; ..if input register was r1
     23						.iif eq <$$-3>	mov	(sp)+	,r3	; ditto if r3
     24						.iif eq <$$-5>	mov	(sp)+	,r5	; ditto if r5
     25						.iif ne <<$$+1>&1> .error      <; bad dst reg for MUL macro>
     26						.endm	mul
     27
     28						.macro	div	src,reg		; /BBS/ made this double precision
     29						.ntype	$$	,reg		; # of register with dividend hi word
     30						mov	src	,-(sp)		; divisor
     31						.if eq $$			; hi word is in r0
     32						mov	r1	,-(sp)		; dividend low word
     33						mov	r0	,-(sp)		; dividend high word
     34						.endc
     35						.if eq $$-2			; hi word is in r2
     36						mov	r3	,-(sp)
     37						mov	r2	,-(sp)
     38						.endc
     39						.if eq $$-4			; hi word is in r4
     40						mov	r5	,-(sp)
     41						mov	r4	,-(sp)
     42						.endc
     43						call	p$div			; divide
     44						.if eq $$			; using r0..
     45						mov	(sp)+	,r1		; remainder
     46						mov	(sp)+	,r0		; this only returns a 16-bit quotient
     47						.endc
     48						.if eq $$-2			; using r2..
     49						mov	(sp)+	,r3
     50						mov	(sp)+	,r2
     51						.endc
     52						.if eq $$-4			; using r4..
     53						mov	(sp)+	,r5
     54						mov	(sp)+	,r4
     55						.endc
     56						.endm	div
     57
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 1-1
KRTNHD	EIS macros for a non-EIS CPU

     58						.macro	sob	reg,dst		; subtract one and branch if not zero
     59						dec	reg
     60						bne	dst
     61						.endm	sob
     62
     63						.macro	ash	amount,reg	; arithmetic shift
     64						.ntype	$$$0	,amount
     65						.iif ne <27-$$$0> .error       <; must be auto pc for ASH macro>
     66						$$type	= 1			; assume left shift
     67						$$size	= 0			; how many ASLs or ASRs to generate
     68						  .irpc	$a ,<amount>		; parse the first argument
     69						  $c	= ''$a			; get the character as a literal
     70						  .iif eq <$c - '-> $$type = -1	; if a minus sign then assume right
     71						  .iif eq <$c - '.> .error     <; only use octal in ASH macro please>
     72						  .iif eq <$c - '^> .error     <; only use octal in ASH macro please>
     73						  $c	= $c - '0		; check for a digit now
     74						    .if ge $c			; perhaps a digit
     75						      .if le $c-7		; got a digit
     76						      $$size = <$$size*10>+$c	; add into accumulator
     77						      .endc
     78						    .endc
     79						  .endr
     80						.rept	$$size
     81						.iif gt <$$type>  asl	reg
     82						.iif lt <$$type>  asr	reg
     83						.endr
     84						.endm
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 2
KRTNHD	EIS macros for a non-EIS CPU

      1						.title	KRTPAK	Packet driver
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	make .TOGO = 16, fixing a (harmless) typo (was 26)..
      7					;	dump ^A = restart a packet for SET CONTROL UNPREFIX 1 operation
      8					;	BUFFIL back to root (KRTPAK), for speed and room now available
      9					;	ERROR: now sends error packet when link is open and xfr in progress
     10					;	modify BUFFIL to do BUFPAK too, for repeated char encoding
     11
     12					; /62/	27-Jul-93  Billy Youdelman  V03.62
     13					;
     14					;	move erbfsiz to KRTMAC
     15					;	patch PRINTM to also write to a logfile, when same is in use
     16					;	add logfile error handler and provide for logfile errors
     17					;	write error messages to logfile
     18					;	include file spec in getnxt error messages
     19					;	add individual packet exchange duration timer, for debugging
     20					;	make BUFFIL limit test max-0 (was max-4), allows bigger packets
     21					;	don't log bogus data for timout
     22					;	make ERROR send an error packet, use PRINTM elsewhere
     23					;	don't modify SET time-out value
     24					;	add/enforce SET SEND PACKET-LEN limit
     25					;	move bufpak to KRTSER, no one else uses it
     26					;	move buffil to KRTSEN, ditto..
     27					;	move bufemp to KRTREC
     28					;	add passed buffer length to rpack$
     29
     30					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     31					;
     32					;	added lun.ld == 12 for TSX logical disk support
     33					;	added lun.at == 5 for file attributes support
     34					;	prefixing error messages with the prompt string moved to KRTERR
     35					;	waitsoh - ^Z abort changed to ^C abort, thus not killing the pgm
     36					;
     37					;	spack$ packet length test fixed to determine the true length of
     38					;	a packet near or equal to 94 bytes when long packets are used.
     39					;	it was possible to generate a "normal" packet with an out-of-
     40					;	range LENGTH character (using all eight bits) when reaching the
     41					;	the EOF produced a last packet in a long packet series close to
     42					;	94 bytes, as the routine filling the packet data input buffer
     43					;	is still looking for enough to make a long packet, with no
     44					;	consideration for the added SEQ and TYP bytes nor the checksum
     45					;	size (up to three more bytes with CRC block checking)..
     46					;
     47					;	rpakst patched to hose link device whenever the "T" (time-out)
     48					;	packet count is incremented, or when a NAK xxx NAK series
     49					;	(indicating resonating packets) occurs.  this is very helpful
     50					;	when telephone line noise crashes/hangs the handler..
     51					;
     52					;	space padding between elements of an error message moved from
     53					;	error: to the err msgs themselves as printm doesn't do it, and
     54					;	it's too confusing otherwise..
     55					;
     56					;	patched to compensate for crossing midnight, as long as
     57					;	there's less than 24 hours between calls to it, thus 32-bit
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 2-1
KRTNHD	EIS macros for a non-EIS CPU

     58					;	time data from incsta are thought to be sufficient here
     59					;	note: the display routine in krtsho limits max to 18.2 hours..
     60					;
     61					;	patched bufemp to not output the lead-in char to TT under TSX
     62					;
     63					;	moved RPACK debug stuff to rawio: as when it was in rpakrd: it
     64					;	missed the SOH, which is handled by waitsoh: (both call rawio)..
     65					;	also cleaned up display at the EOL and added display of TIMOUTs
     66					;
     67					;	fixed non-init'd repeat count reg bug in bufunpack
     68
     69					;	Brian Nelson	30-Nov-83  10:20:09
     70					;	13-Oct-84  14:01:32  BDN	moved SENDSW and RECSW out
     71					;
     72					;	Change Software, Toledo, Ohio
     73					;	University of Toledo, Toledo, Ohio
     74
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 3
KRTNHD	EIS macros for a non-EIS CPU

      1
      2					;				 PACKET FORMAT
      3					;
      4					; The KERMIT protocol is built around exchange of packets of this format:
      5					;
      6					;    +------+-----------+-----------+------+- ~ ---- ~ -+-------+-----+
      7					;    | MARK | char(LEN) | char(SEQ) | TYPE |    DATA    | CHECK | EOL |
      8					;    +------+-----------+-----------+------+- ~ ---- ~ -+-------+-----+
      9					;
     10					; where all fields consist of ASCII characters.  The fields are:
     11					;
     12					; MARK  The synchronization character that marks the beginning of the packet.
     13					;      This is normally ^A, but may be redefined.
     14					;
     15					; LEN  The  number  of  ASCII  characters  within  the packet that follow this
     16					;      field, in other words the packet length minus two.  Since  this  number
     17					;      is  transformed  to  a single character via the char() function, packet
     18					;      character  counts  of  0. to 94. are permitted, and  96. is the maximum
     19					;      total packet length.  The length doesn't include end-of-line or padding
     20					;      characters, which are outside  the  packet  and  are  strictly  for the
     21					;      benefit of the operating system,  but  it  does include the block check
     22					;      characters.
     23					;
     24					; SEQ  The packet sequence number modulo 64., ranging from 0. to 63.  Sequence
     25					;      numbers "wrap around" to 0. after each group of 64. packets.
     26					;
     27					; TYPE  The packet type, a single ASCII character.  The following packet types
     28					;       are used in the Kermit protocol -
     29					;
     30					;  A = Attributes                     K = Kermit (remote) command
     31					;  B = Break transmission (EOT)       N = Negative acknowledgment (NAK)
     32					;  C = Host (remote) command          R = Receive file init
     33					;  D = Data packet                    S = Send file init
     34					;  E = Error                          T = Time out (internal)
     35					;  F = File header (name)             X = Extended reply
     36					;  G = Generic (remote) command       Y = Acknowledgment (ACK)
     37					;  I = Server init                    Z = End of file (EOF)
     38					;
     39					; DATA  The contents of the packet,  if any contents are required in the given
     40					;      type of packet, interpreted according to  the  packet  type.    Control
     41					;      characters  are  preceded  by a special prefix character, normally "#",
     42					;      and "uncontrollified" via ctl().  A prefixed sequence may not be broken
     43					;      across packets.  Logical records in printable files are delimited  with
     44					;      CR/LFs, suitably prefixed (e.g. "#M#J").  Any prefix characters are in-
     45					;      cluded in the count.  Optional encoding for  8-bit  data  and  repeated
     46					;      characters is also available.
     47					;
     48					; CHECK  A block check on characters in the packet between,  but not including
     49					;      ing, the mark and the block check itself.  The check for each packet is
     50					;      computed by both hosts,  and  must agree if a packet is to be accepted.
     51					;      A single-character arithmetic checksum is the normal and required block
     52					;      check.   Only  six  bits  of the arithmetic sum are included.  In order
     53					;      that all the bits of each data character contribute to  this  quantity,
     54					;      bits  6  and  7  of the final value are added to the quantity formed by
     55					;      bits 0-5.  Thus if s is the arithmetic sum  of  the  ASCII  characters,
     56					;      then
     57					;
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 3-1
KRTNHD	EIS macros for a non-EIS CPU

     58					;	    check = char((s + ((s & 192.)/64.)) & 63.)
     59					;
     60					;      This  is  the  default  block check, and all Kermits must be capable of
     61					;      performing it.  Other optional block check types are also defined.  The
     62					;      block check  is  based  on  the  ASCII  values of the characters in the
     63					;      packet.    Non-ASCII  systems must translate to ASCII before performing
     64					;      the block check calculation.
     65					;
     66					; EOL  The End Of Line character, normally a carriage return, marks the end of
     67					;      the packet.  This particular implementation (Kermit-11) uses the packet
     68					;      length and ignores the EOL char other than displaying it when debugging
     69					;      to the terminal.
     70
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 4
KRTNHD	EIS macros for a non-EIS CPU

      1
      2						.include "IN:KRTMAC.MAC"
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 5
KRTMAC	Various handy constants and macros

      1						.sbttl	KRTMAC	Various handy constants and macros
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	add support for SET ATTRIBUTES
      7					;	add flag to suspend logging to a disk file
      8					;	make $LN$MAX 132. bytes for EIS assembly
      9					;	pulled message macro, no longer used..
     10
     11					; /62/	27-Jul-93  Billy Youdelman  V03.62
     12					;
     13					;	move dispatch macro to KRTSER
     14					;	move erbfsiz here from KRTPAK
     15					;	condense logging (debug) modes
     16					;	increase efficiency of incm64 macro
     17					;	increase MAXLNG (long-packet size) to 1920.
     18					;	reduce MAXLNG to 600. for NONEIS assembly, so pgm loads under FB..
     19					;	ditto for ALSIZE (phone # buffer) and LN$CNT (SL # of lines saved)
     20
     21					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     22					;
     23					;	modified message macro to call .newline instead of saving CR/LF
     24					;	and null for each new line, knocking 1042. bytes off the size
     25					;	of this version..  also changed ".print" emulation to wrtall,
     26					;	for a similar savings in compiled program size.
     27					;
     28					;	dump raw I/O logging from log$al (SET DEB ALL) - too confusing
     29					;	also pulled log$rp out and made it a completely separate item..
     30					;
     31					;	added a couple upper case macros
     32
     33					;	include file for Kermit-11
     34					;
     35					;	Brian Nelson  01-Dec-83  13:56:12
     36
     37						.NLIST	BEX
     38						.LIST	MEB			; /62/
     39
     40		000001 				KRTINC	=	1		; for .include error checking
     41
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 6
KRTMAC	Various handy constants and macros

      1
      2	000000					.psect	$code	,ro,i,lcl,rel,con ; psect ordering..
      3	000000					.psect	$pdata	,ro,d,lcl,rel,con
      4
      5					;	various ascii chars
      6		000001 				SOH	=   1		; default packet start of header
      7		000007 				BELL	=   7		; beep
      8		000010 				BS	=  10		; backspace
      9		000011 				TAB	=  11		; tab
     10		000012 				LF	=  12		; line feed
     11		000014 				FF	=  14		; form feed
     12		000015 				CR	=  15		; carriage return
     13		000016 				CTRL$N	=  16		; ^N VT-100 line drawing on
     14		000017 				CTRL$O	=  17		; ^O VT-100 line drawing off
     15		000021 				XON	=  'Q&37	; ^Q
     16		000023 				XOFF	=  'S&37	; ^S
     17		000033 				ESC	=  33		; escape
     18		000040 				SPACE	=  40
     19		000054 				COMMA	=  54
     20		000056 				DOT	=  56		; /63/
     21		000073 				SCOLON	=  73		; /63/
     22		000176 				TILDE	= 176		; /63/
     23		000177 				DEL	= 177		; delete
     24
     25					;	system data locations
     26		000044 				JSW	= 44		; job status word
     27		000052 				ERRBYT	= 52		; emt error byte
     28		000053 				USERRB	= 53		; /62/ user error byte
     29		000001 					SUCCS$	=  1	; no error
     30		000002 					WARN$	=  2	; warning
     31		000004 					ERROR$	=  4	; error
     32		000010 					SEVER$	= 10	; sever error
     33		000020 					FATAL$	= 20	; fatal error
     34
     35					;	byte offsets into SINIT parameter vector
     36		000000 				P.SPSIZ	= 0		; set packet length
     37		000001 				P.TIME	= 1		; time-out
     38		000002 				P.NPAD	= 2		; number of pad chars
     39		000003 				P.PADC	= 3		; the pad character
     40		000004 				P.EOL	= 4		; eol char
     41		000005 				P.QCTL	= 5		; control char quoting
     42		000006 				P.QBIN	= 6		; 8-bit quote
     43		000007 				P.CHKT	= 7		; checksum type
     44		000010 				P.REPT	= 10		; repeated character prefix
     45		000011 				P.CAPAS	= 11		; capability bitmask
     46		000010 					CAPA.A	= 10	; attribute handling
     47		000002 					CAPA.L	= 2	; /42/ long packets
     48		000004 					CAPA.S	= 4	; /42/ sliding windows
     49		000012 				P.WINDS	= 12		; /43/ window size, # of packets
     50		000013 				P.MXL1	= 13		; /43/ high order of long packet size
     51		000014 				P.MXL2	= 14		; /43/ low order of long packet size
     52		000017 				P.VEND	= 17		; end of parameter vector
     53
     54					; /62/	bits in doattr (file attribute processing)
     55		000001 				AT.CDT	=: 1		; create date
     56		000002 				AT.INF	=: 2		; /63/ system specific info
     57		000004 				AT.LEN	=: 4		; length
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 6-1
KRTMAC	Various handy constants and macros

     58		000010 				AT.PRO	=: 10		; file protection
     59		000020 				AT.SYS	=: 20		; system ID
     60		000040 				AT.TYP	=: 40		; file type
     61		000100 				AT.XLE	=: 100		; exact length in bytes
     62		100000 				AT.ON	=: 100000	; /63/ do attribute processing
     63		000177 				AT.ALL	=: AT.CDT!AT.INF!AT.LEN!AT.PRO!AT.SYS!AT.TYP!AT.XLE
     64
     65					;	bits in trace (debug status word)
     66		000001 				LOG$PA	= 1		; log all packets
     67		000002 				LOG$CO	= 2		; /62/ CONNECT logging to disk
     68		000004 				LOG$RP	= 4		; /62/ rpack chars to TT
     69		000010 				LOG$IO	= 10		; /62/ everything received or sent
     70		000020 				LOG$DE	= 20		; /62/ debugging to TT
     71		040000 				LOG$ON	= 40000		; /63/ set to write to disk, clear to suspend
     72		100000 				LOG$OP	= 100000	; logfile is open
     73		000003 				LOG$AL	= LOG$PA!LOG$CO	; /62/ ALL
     74
     75					;	parity options
     76		000000 				PAR$NO	=: 0		; none
     77		000001 				PAR$OD	=: 1		; odd
     78		000002 				PAR$EV	=: 2		; even
     79		000003 				PAR$MA	=: 3		; mark
     80		000004 				PAR$SP	=: 4		; space
     81
     82					;	file types
     83		177777 				TERMINAL=: -1		; file to term ala xreply, not to disk
     84		000000 				TEXT	=:  0		; normal ascii text files
     85		000001 				BINARY	=:  1		; image mode
     86		000002 				DECNAT	=:  2		; /52/ 8-bit text files
     87
     88					;	terminal types
     89		000000 				NOSCOPE	= 0		; /BBS/ hard copy terminal
     90		000001 				TTY	= 1		; a dumb tube terminal
     91		000002 				VT100	= 2		; itself
     92		000003 				VT200	= 3		; ditto..
     93
     94					;	supported CVT$$ cvt_bit_pattern bits
     95		000004 				C.CRLF	= 4		; discard CR LF FF ESC
     96		000010 				C.LSPA	= 10		; discard leading spaces and tabs
     97		000020 				C.SSPA	= 20		; reduce spaces and tabs to a single space
     98		000040 				C.LCUC	= 40		; lower case to upper case
     99		000200 				C.TSPA	= 200		; discard trailing spaces and tabs
    100
    101		000034 				CON$ESC	=  '\-100	; default CONNECT escape char
    102		000170 				ERBFSIZ	=  120.		; /62/ error msg text buff size
    103		000136 				MAXPAK	=:  94.		; /63/ max_packet_length - max_checksum_length
    104
    105						.if df	NONEIS		; /62/ using NONEIS for convenience..
    106		001000 				ALSIZE	=   1000	; /63/ bufsiz for SET DIAL/PHO NUM
    107		000003 				LN$CNT	=      3.	; /62/ save/recall 3. commands
    108		000120 				LN$MAX	=     80.	; /63/ max command line length
    109		001130 				MAXLNG	=    600.	; /63/ so image is small enuff to run
    110						.iff
    111						ALSIZE	=   2000	; /62/ bufsiz for SET DIAL/PHO NUM
    112						LN$CNT	=     10.	; /63/ save/recall 10. commands
    113						LN$MAX	=    132.	; /63/ max command line length
    114						MAXLNG	=   1920.	; /63/ use max long-packet buff size
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 6-2
KRTMAC	Various handy constants and macros

    115						.endc
    116		001144 				$ALLSIZ	= <MAXLNG+14>&177776 ; /62/ make it this for safety
    117
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 7
KRTMAC	Various handy constants and macros

      1
      2						.sbttl	Utility macros
      3
      4						.macro	.br to		; /63/ added
      5						.if df	to
      6						.if ne	to-.
      7						.error	<; not at location to;>
      8						.endc
      9						.endc
     10						.endm	.br
     11
     12						.macro	.chksp	arg
     13						.ntype	$$5	,arg
     14						.iif eq <<$$5&7>-6> .error arg <; Illegal use of SP (r6) in call>
     15						.endm	.chksp
     16
     17						.macro	calls	name	,arglst
     18					;	subroutine call with arguments passed in an area pointed to by r5
     19					;	(as with F4 and BP2).  all args are pushed onto the stack in the
     20					;	order specified.  r5 points to the sp before the call and is saved
     21					;	and restored.
     22						$$ = 0				; init # of args count
     23						  .irp x ,<arglst>		; count up # of args passed
     24						  $$ = $$+1			; one at a time
     25						  .endr				; got it
     26						.if eq $$			; no args present?
     27						jsr	pc	,name		; if so, substitute a simple call
     28						.iff				; at least one arg in <arglst>
     29						mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
     30						  .if eq $$-1			; is it one or more than one arg?
     31						  .chksp	arglst		; one arg, check for legal SP modes
     32						  mov	arglst	,-(sp)		; doing it thusly generates less code
     33						  mov	sp	,r5		; set pointer to argument list
     34						  jsr	pc	,name		; call the subroutine
     35						  tst	(sp)+			; pop parameter list from stack
     36						  mov	(sp)+	,r5		; /63/ restore r5
     37						  .iff				; arg_count > 1
     38						  $$2 = $$			; extract the args in
     39						    .rept	$$		; reverse order so that
     40						    $$1 = 0			; we might save a little
     41						      .irp x ,<arglst>		; core (four words)
     42						      $$1 = $$1+1		; scan the arg list until we come to
     43						        .if eq $$2-$$1		; the last one before one we just did
     44						        .chksp	x		; check for SP addressing mode
     45						        mov	x	,-(sp)	; push it
     46						        .mexit			; and exit the .irp
     47						        .endc
     48						      .endr
     49						    $$2 = $$2-1			; backwards to previous arg
     50						    .endr
     51						  mov	sp	,r5		; set up the argument list pointer
     52						  jsr	pc	,name		; and go to the routine
     53						  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
     54						  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
     55						  mov	(sp)+	,r5		; /63/ restore r5
     56						  .endc
     57						.endc
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 7-1
Utility macros

     58						.endm	calls
     59
     60						.macro	ctl	src ,dst
     61						clr	-(sp)
     62						bisb	src	,@sp
     63						call	l$xor
     64						movb	(sp)+	,dst
     65						.endm	ctl
     66
     67						.macro	copyz	from ,to ,maxlen
     68						.if  b	<maxlen>
     69						clr	-(sp)
     70						.iff
     71						mov	maxlen	,-(sp)
     72						.endc
     73						mov	from	,-(sp)
     74						mov	to	,-(sp)
     75						call	copyz$
     76						.endm	copyz
     77
     78						.macro	deccvt	val ,buf ,width
     79						mov	r5	,-(sp)
     80						.if  b	<width>
     81						clr	-(sp)
     82						.iff
     83						mov	width	,-(sp)
     84						.endc
     85						mov	val	,-(sp)
     86						mov	buf	,-(sp)
     87						mov	sp	,r5
     88						call	l$cvtnum
     89						add	#6	,sp
     90						mov	(sp)+	,r5
     91						.endm	deccvt
     92
     93						.macro	decout	val
     94						mov	r5	,-(sp)
     95						mov	val	,-(sp)		; /62/ l$wrdec pops this buffer
     96						mov	sp	,r5
     97						call	l$wrdec
     98						mov	(sp)+	,r5
     99						.endm	decout
    100
    101						.macro	direrr	val
    102						mov	val	,-(sp)
    103						call	direr$
    104						.endm	direrr
    105
    106						.macro	incm64	val
    107						inc	val
    108						bic	#^c<77>	,val		; /62/ faster
    109						.endm	incm64
    110
    111						.macro	indexm	reg		; check for auto increment/decrement
    112						.ntype	$$$0	,reg		; modes for macros that can't have..
    113						.if  ne	$$$0-27			; always allow pc autoincrement
    114						$$$0 =	<$$$0&177770>/10	; ..these modes in their arg list
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 7-2
Utility macros

    115						.ift				; get the mode into 0..7
    116						  .if  ge $$$0-2		; if mode >=2 and mode <=5 then error
    117						  .iif ge <5-$$$0> .error      <; Can't use auto inc/dec mode here>
    118						  .endc
    119						.endc
    120						.endm	indexm
    121
    122						.macro	ixor	reg ,dst
    123					;	get around the mode restrictions for the hardware XOR instruction
    124					;	and fix for RT-11 systems that don't have the EIS chip option
    125						.chksp	reg			; can't allow sp args
    126						.chksp	dst			; in either register
    127						indexm	reg			; check for allowed
    128						indexm	dst			; addressing mode
    129						mov	reg	,-(sp)		; it's much simpler to do this
    130						bic	dst	,@sp		; for all RT-11 systems rather
    131						bic	reg	,dst		; than to be selective
    132						bis	(sp)+	,dst		; done
    133						.endm	ixor
    134
    135						.macro	.newline		; print CR/LF on TT
    136						call	l$pcrlf
    137						.endm	.newline
    138
    139						.macro	octout	val
    140						calls	l$wroct	,<val>
    141						.endm	octout
    142
    143						.macro	prsbuf	dst
    144						mov	dst	,r0
    145						call	prsarg
    146						.endm	prsbuf
    147
    148						.macro	rpack	len.a ,pakn.a ,msg.a ,max.len	; /62/
    149						sub	#10	,sp
    150						mov	sp	,r1
    151						calls	rpack$	,<msg.a,r1,max.len>
    152						mov	(r1)+	,len.a
    153						mov	(r1)+	,pakn.a
    154						mov	@r1	,r1
    155						add	#10	,sp
    156						.endm	rpack
    157
    158						.macro	save	list
    159						.if  b	<list>
    160						 save	<r0,r1,r2,r3,r4,r5>
    161						.iff
    162						.irp	x ,<list>
    163						 mov	x	,-(sp)
    164						.endr
    165						.endc
    166						.endm	save
    167
    168						.macro	scan	ch ,str
    169						mov	str	,-(sp)
    170						clr	-(sp)
    171						bisb	ch	,@sp
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 7-3
Utility macros

    172						call	scanch
    173						.endm	scan
    174
    175						.macro	setpar	src ,dst
    176						movb	src	,-(sp)
    177						call	dopari
    178						movb	(sp)+	,dst
    179						.endm	setpar
    180
    181						.macro	spack	type ,pnum ,len ,msg
    182						.if  b	<len>
    183						.iif nb	<msg>	.error	<; bad call to SPACK macro>
    184						calls	spack$	,<type,pnum,#0,#null>
    185						.iff
    186						calls	spack$	,<type,pnum,len,msg>
    187						.endc
    188						.endm	spack
    189
    190						.macro	strcat	dst ,src
    191						mov	src	,-(sp)
    192						mov	dst	,-(sp)
    193						jsr	pc	,strcat
    194						.endm	strcat
    195
    196						.macro	strcpy	dst ,src
    197						mov	src	,-(sp)
    198						mov	dst	,-(sp)
    199						jsr	pc	,strcpy
    200						.endm	strcpy
    201
    202						.macro	strlen	string
    203						mov	string	,r0
    204						call	l$len
    205						.endm	strlen
    206
    207						.macro	textsrc	text
    208						.if  b	<text>
    209						clr	getcroutine		; /62/ reset to file I/O
    210						clr	tgetaddr
    211						.iff
    212						mov	#tgetcr0,getcroutine
    213						mov	text	,tgetaddr
    214						.endc
    215						.endm	textsrc
    216
    217						.macro	tochar	src ,dst
    218						clr	-(sp)
    219						bisb	src	,@sp
    220						add	#40	,@sp
    221						movb	(sp)+	,dst
    222						.endm	tochar
    223
    224						.macro	unchar	src ,dst
    225						clr	-(sp)
    226						bisb	src	,@sp
    227						sub	#40	,@sp
    228						movb	(sp)+	,dst
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 7-4
Utility macros

    229						.endm	unchar
    230
    231						.macro	unsave	list
    232						.if b <list>
    233						unsave	<r5,r4,r3,r2,r1,r0>
    234						.iff
    235						.irp	x ,<list>
    236						 mov	(sp)+	,x
    237						.endr
    238						.endc
    239						.endm	unsave
    240
    241						.macro	upcase	s		; /BBS/ added ..
    242						mov	s	,r0
    243						call	upcase			; /BBS/ upcase until null terminator
    244						.endm	upcase
    245
    246						.macro	upone	s		; /BBS/ added ..
    247						mov	s	,r0
    248						call	upone			; /BBS/ upcase only to next delimiter
    249						.endm	upone
    250
    251						.macro	wrtall	arg		; IO.WAL for an .asciz string
    252						mov	arg	,-(sp)		; pass the address
    253						call	wrtall			; do it
    254						.endm	wrtall
    255
    256						.macro	xor	reg ,dst
    257						ixor	reg	,dst
    258						.endm	xor
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 8
Utility macros

      1						.iif ndf  KRTINC  .error	<; .include for IN:KRTMAC.MAC failed>
      2						.include "IN:KRTDEF.MAC"
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 9
KRTDEF	Packet types (edited from VMS Kermit)

      1						.sbttl	KRTDEF	Packet types (edited from VMS Kermit)
      2					;	.ident	"V03.63"	; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					; /62/	27-Jul-93  Billy Youdelman  V03.62
      6					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
      7
      8					;	Note the use of the "=:" direct assignment ensures these
      9					;	rather long names are unique in the first 6 characters.
     10
     11						.sbttl	Protocol V1.0 message types
     12
     13		000131 			MSG$ACK		=: 'Y&137	; acknowledgment (ACK)
     14		000102 			MSG$BREAK	=: 'B&137	; break transmission (EOT)
     15		000104 			MSG$DATA	=: 'D&137	; data packet
     16		000132 			MSG$EOF		=: 'Z&137	; end of file (EOF)
     17		000105 			MSG$ERROR	=: 'E&137	; error
     18		000106 			MSG$FILE	=: 'F&137	; file header
     19		000116 			MSG$NAK		=: 'N&137	; negative acknowledgment (NAK)
     20		000123 			MSG$SND		=: 'S&137	; send initiate
     21
     22						.sbttl	Protocol V2.0 message types
     23
     24		000103 			MSG$COMMAND	=: 'C&137	; host command
     25		000107 			MSG$GENERIC	=: 'G&137	; generic Kermit command
     26		000113 			MSG$KERMIT	=: 'K&137	; perform Kermit command (text)
     27		000122 			MSG$RCV		=: 'R&137	; receive initiate
     28
     29						.sbttl	Protocol V4.0 message types
     30
     31		000101 			MSG$ATR		=: 'A&137	; attribute packet
     32		000111 			MSG$SER		=: 'I&137	; server initialization
     33		000130 			MSG$TEXT	=: 'X&137	; text header message
     34
     35						.sbttl	Generic Kermit commands
     36
     37		000114 			GN$BYE		=: 'L&137	; logout
     38		000103 			GN$CONNECT	=: 'C&137	; connect to a directory
     39		000113 			GN$COPY		=: 'K&137	; copy file
     40		000105 			GN$DELETE	=: 'E&137	; delete a file
     41		000104 			GN$DIRECTORY	=: 'D&137	; directory
     42		000125 			GN$DISK		=: 'U&137	; disk usage
     43		000106 			GN$EXIT		=: 'F&137	; finish (stop the server)
     44		000110 			GN$HELP		=: 'H&137	; help
     45		000112 			GN$JOURNAL	=: 'J&137	; perform journal functions
     46		000111 			GN$LOGIN	=: 'I&137	; login
     47		000120 			GN$PRINT	=: 'P&137	; print
     48		000120 			GN$PROGRAM	=: 'P&137	; run program and pass data
     49		000121 			GN$QUERY	=: 'Q&137	; query status
     50		000122 			GN$RENAME	=: 'R&137	; rename file
     51		000115 			GN$SEND		=: 'M&137	; send a message to a user
     52		000123 			GN$SUBMIT	=: 'S&137	; submit
     53		000124 			GN$TYPE		=: 'T&137	; type a file specification
     54		000126 			GN$VARIABLE	=: 'V&137	; return/set variable state
     55		000127 			GN$WHO		=: 'W&137	; who's logged in?
     56
     57						.sbttl	Acknowledgment modifiers (V4.0)
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 9-1
Acknowledgment modifiers (V4.0)

     58
     59		000132 			ABT$ALL		=: 'Z&137	; abort entire stream of files
     60		000130 			ABT$CUR		=: 'X&137	; abort current file
     61		000105 			ABT$ERROR	=: 'E&137	; abort because an error occured
     62
     63						.sbttl	End of file packet modifier
     64
     65		000104 			EOF$DISCARD	=: 'D&137	; discard data from previous file
     66
     67						.sbttl	Send/receive states
     68
     69		000100 			STA.CCA		=:  100		; ^C from keyboard abort
     70		000101 			STA.ABO		=: 'A&137	; abort
     71		000110 			STA.ATR		=: 'H&137	; send attributes
     72		000102 			STA.BRK		=: 'B&137	; break link
     73		000103 			STA.COM		=: 'C&137	; transaction complete
     74		000104 			STA.DAT		=: 'D&137	; data
     75		000132 			STA.EOF		=: 'Z&137	; end of file or reply
     76		000106 			STA.FIL		=: 'F&137	; file name header
     77		000111 			STA.INI		=: 'I&137	; init
     78		000122 			STA.RIN		=: 'R&137	; receive init
     79		000123 			STA.SIN		=: 'S&137	; send init
     80		000130 			STA.TYP		=: 'X&137	; extended reply
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 10
Send/receive states

      1						.iif ndf  MSG$DA  .error	<; .include for IN:KRTDEF.MAC failed>
      2
      3						.mcall	.CLOSE			; /63/ drop .GTIM, ,.PURGE
      4
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 11
Send/receive states

      1
      2						.sbttl	Misc defaults
      3
      4		000377 				BADCHK	==	377		; pseudo packet type for bad checksum
      5		000061 				DEFCHK	==	 '1		; default block-check-type
      6		000124 				TIMOUT	==   'T&137		; pseudo packet type for time-out
      7
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 12
Misc defaults

      1
      2						.sbttl	Local and global read-only data
      3
      4	000000					.psect	$pdata	; /62/ MUST be non-swapping, in root (SJ) or APR1 (XM)
      5	000000	   040 	   000 		aspace::.byte	40 ,0	; /62/ consolidated all this here..
      6	000002	   000 	   000 		null::	.byte	 0 ,0
      7	000004	   054 	   040 	   160 	e$pari:	.asciz	", parity is possibly being introduced"
      8	000052	   122 	   145 	   164 	e$retr:	.asciz	"Retry limit reached"
      9	000076	   120 	   141 	   143 	e$sync:	.asciz	"Packet serial numbers are out of sync"
     10	000144	   113 	   145 	   162 	pak.01:	.asciz	"Kermit: "
     11	000155	   074 	   074 	   074 	pak.02:	.asciz	"<<< RPACK - "
     12	000172	   074 	   124 	   111 	pak.03:	.asciz	"<TIMOUT>"
     13	000203	   102 	   101 	   104 	pak.04:	.asciz	"BAD Checksum: RCV,CALC = "
     14	000235	   074 	   123 	   117 	pak.05:	.asciz	"<SOH>"
     15	000243	   074 	   105 	   117 	pak.06:	.ascii	"<EOL>"
     16	000250	   015 	   012 	   000 	pak.07:	.asciz	<cr><lf>
     17	000253	   076 	   076 	   076 	pak.08:	.asciz	">>> SPACK - "
     18						.even
     19
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 13
Local and global read-only data

      1
      2	000000					.psect	$code
      3						.sbttl	Read incoming packet
      4
      5					;	R P A C K $
      6					;
      7					;	input:	  (r5)	= packet buffer address
      8					;		 4(r5)	= packet buffer length
      9					;	output:	 2(r5)	= 3 word data structure returns length, number, type
     10
     11		000000 				O$LEN	=  0		; offset for returned packet length
     12		000002 				O$SEQ	=  2		; packet number
     13		000004 				O$TYP	=  4		; packet type
     14
     15						; /62/	local data allocated on the stack, offsets from r4
     16		000000 				.TYP	=  0		; packet type
     17		000002 				.CCHECK	=  2		; computed checksum
     18		000004 				.RCHECK	=  4		; received checksum
     19		000006 				.LEN	=  6		; received packet length
     20		000010 				.TIMEO	= 10		; read time-out
     21		000012 				.SEQ	= 12		; received packet number
     22		000014 				.SIZE	= 14		; current size of data portion
     23		000016 				.TOGO	= 16		; /63/ loop count control for data portion
     24		000020 				.HDTYPE	= 20		; /62/ header type
     25		000022 				.CBUFF	= 22		; /62/ checksum buffer address
     26		000024 				.LSIZE	= 24		; total size of the above local data
     27
     28					;	internal register usage:
     29					;	r0	= scratch register
     30					;	r1	= current character just read from remote
     31					;	r2	= pointer to packet buffer
     32					;	r3	= pointer to temp buffer on the stack containing the packet
     33					;		  less the SOH and the checksum, for computing checksum after
     34					;		  the packet has been read
     35					;	r4	= pointer to local data on stack, as defined above
     36					;	r5	= pointer to argument list
     37
     38	000000	004767 	000000G		rpack$::call	dcdtst			; /62/ check DCD, report any change..
     39	000004					save	<r1,r2,r3,r4>
	000004	010146 				 mov	r1	,-(sp)
	000006	010246 				 mov	r2	,-(sp)
	000010	010346 				 mov	r3	,-(sp)
	000012	010446 				 mov	r4	,-(sp)
     40	000014	005067 	000000G			clr	recbit			; /43/ clear bit sum out
     41	000020	162706 	000024 			sub	#.lsize	,sp		; allocate space for local data
     42	000024	010604 				mov	sp	,r4		; and point to it please
     43	000026	162706 	001144 			sub	#$allsiz,sp		; /42/ allocate a HUGE buffer
     44	000032	004767 	000414 			call	waitsoh			; wait for a packet to start
     45	000036	005700 				tst	r0			; did it work or did we time out?
     46	000040	001402 				beq	10$			; yes it worked
     47	000042	000167 	000326 			jmp	100$			; we must have timed out then
     48
     49	000046	010603 			10$:	mov	sp	,r3		; the packet less SOH and checksum
     50	000050	010664 	000022 			mov	sp	,.cbuff(r4)	; /42/ save start address
     51	000054	004767 	000556 			call	rpakin			; initialize things
     52	000060	004767 	000610 			call	rpakrd			; read the next character from
     53	000064	103543 				bcs	100$			; packet reader's buffer
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 13-1
Read incoming packet

     54	000066	150167 	000000G			bisb	r1	,recbit		; /43/ so we can determine parity set
     55	000072	042701 	177600 			bic	#^c<177>,r1		; ensure parity is cleared out
     56	000076	110123 				movb	r1	,(r3)+		; *checkpacket++ = ch
     57	000100					unchar	r1	,r0		; get the length packet next please
	000100	005046 				clr	-(sp)
	000102	150116 				bisb	r1	,@sp
	000104	162716 	000040 			sub	#40	,@sp
	000110	112600 				movb	(sp)+	,r0
     58	000112	010064 	000020 			mov	r0	,.hdtype(r4)	; /42/ save header type
     59	000116	020027 	000002 			cmp	r0	,#2		; /42/ if the length is 0,1 or 2 then
     60	000122	003406 				ble	20$			; /42/ an extended header instead
     61	000124	162700 	000002 			sub	#2	,r0		; this is NOT an extended header so we
     62	000130	166700 	000000G			sub	chksiz	,r0		; will check to see if the packet can
     63	000134	002001 				bge	20$			; hold at least SEQ+TYPE+CHECK
     64	000136	005000 				clr	r0			; /44/ couldn't, "fix" bad length
     65	000140	010064 	000006 		20$:	mov	r0	,.len(r4)	; stuff the packet length
     66
     67	000144	004767 	000524 			call	rpakrd			; as before, ask for the next char
     68	000150	103511 				bcs	100$			; and take an error exit if need be
     69	000152	150167 	000000G			bisb	r1	,recbit		; /43/ so we can determine parity set
     70	000156	042701 	177600 			bic	#^c<177>,r1		; ensure parity is cleared out
     71	000162	110123 				movb	r1	,(r3)+		; insert the sequence number into the
     72	000164					unchar	r1	,.seq(r4)	; checksum packet and save the SEQ
	000164	005046 				clr	-(sp)
	000166	150116 				bisb	r1	,@sp
	000170	162716 	000040 			sub	#40	,@sp
	000174	112664 	000012 			movb	(sp)+	,.seq(r4)
     73
     74	000200	004767 	000470 			call	rpakrd			; read the TYPE field next, exiting
     75	000204	103473 				bcs	100$			; on a read error, of course
     76	000206	150167 	000000G			bisb	r1	,recbit		; /43/ so we can determine parity set
     77	000212	042701 	177600 			bic	#^c<177>,r1		; ensure parity is cleared out
     78	000216	110123 				movb	r1	,(r3)+		; save TYPE field into the checksum
     79	000220	010164 	000000 			mov	r1	,.typ(r4)	; and also into the field for return
     80
     81	000224	005764 	000020 			tst	.hdtype(r4)		; /42/ NOW check for extended header
     82	000230	001004 				bne	30$			; /42/ not extended header
     83	000232	004767 	000476 			call	rdexhd			; /42/ ReaD EXtended HeaDer
     84	000236	005700 				tst	r0			; /42/ did this work ok?
     85	000240	001073 				bne	110$			; /63/ no, time-out or checksum error
     86
     87	000242	016464 	000006 	000016 	30$:	mov	.len(r4),.togo(r4)	; loop for the data, if any
     88	000250	026465 	000016 	000004 		cmp	.togo(r4),4(r5)		; /62/ ensure we don't overwrite buff
     89	000256	101403 				blos	40$			; /62/ received length is ok
     90	000260	016564 	000004 	000016 		mov	4(r5)	,.togo(r4)	; /62/ bad length, do max possible..
     91	000266	011502 			40$:	mov	@r5	,r2		; point to the buffer now
     92
     93	000270	005764 	000016 		50$:	tst	.togo(r4)		;   for i := 1 to len do
     94	000274	001426 				beq	90$			;    begin
     95	000276	004767 	000372 			call	rpakrd			;     read(input,ch)
     96	000302	103434 				bcs	100$			;     exit if error
     97	000304	005767 	000000G			tst	parity			; /62/ parity set to none?
     98	000310	001003 				bne	60$			; /62/ no, must be some other type
     99	000312	005767 	000000G			tst	image			; /62/ no parity, image mode today?
    100	000316	001002 				bne	70$			; /62/ yes, leave things alone please
    101	000320	042701 	177600 		60$:	bic	#^c<177>,r1		; /62/ ch := ch and chr(177b)
    102	000324	026427 	000014 	001130 	70$:	cmp	.size(r4),#maxlng	;     if currentsize < maxpaksize
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 13-2
Read incoming packet

    103	000332	103002 				bhis	80$			;       then
    104	000334	110122 				movb	r1	,(r2)+		;         data[i]  := ch
    105	000336	110123 				movb	r1	,(r3)+		;         checkpacket++ := ch
    106										;	end
    107	000340	005264 	000014 		80$:	inc	.size(r4)		;     currentsize:=succ(currentsize)
    108	000344	005364 	000016 			dec	.togo(r4)		;    nchar_left := nchar_left-1
    109	000350	000747 				br	50$			;    end
    110
    111	000352	105012 			90$:	clrb	@r2			;   data[len] := null
    112	000354	105013 				clrb	@r3			;   checkpacket++ := null
    113	000356	010603 				mov	sp	,r3		;   reset base address of checkpacket
    114	000360	004767 	000644 			call	rpakck			;   read the checksum now
    115	000364	103403 				bcs	100$			;   exit on error or time-out
    116	000366	004767 	001030 			call	rpakfi			; /62/ finish the checksum
    117	000372	000420 				br	120$
    118
    119	000374	016501 	000002 		100$:	mov	2(r5)	,r1		; time-out error, flag no packet
    120	000400	012761 	000124 	000004 		mov	#timout	,o$typ(r1)	; return as pseudo packet type
    121	000406	012764 	000124 	000000 		mov	#timout	,.typ(r4)	; ditto for rpakst
    122	000414	005061 	000000 			clr	o$len(r1)		; /62/ time-out has no length
    123	000420	005064 	000006 			clr	.len(r4)		; /62/ don't log bogus data either
    124	000424	005064 	000012 			clr	.seq(r4)		; /62/ time-out has no packet number
    125	000430	004767 	001046 		110$:	call	rpakst			; do stats and disk dumping now
    126
    127	000434	062706 	001170 		120$:	add	#.lsize+$allsiz,sp	; /42/ pop local buffers
    128	000440					unsave	<r4,r3,r2,r1>
	000440	012604 				 mov	(sp)+	,r4
	000442	012603 				 mov	(sp)+	,r3
	000444	012602 				 mov	(sp)+	,r2
	000446	012601 				 mov	(sp)+	,r1
    129	000450	000207 				return
    130
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 14
Read incoming packet

      1
      2						.sbttl	RPACK$ wait for a start of packet char (SOH)
      3
      4					;	W A I T S O H
      5					;
      6					;	output:	  r0	= if <>, error code
      7					;		  r1	= the SOH or a null if we timed out
      8
      9					; /BBS/	^Z exit changed to ^C abort (requires two successive ^Cs)
     10
     11	000452	005001 			waitsoh:clr	r1			; start with nothing
     12	000454	005046 				clr	-(sp)			; /56/ hold virgin copy of data
     13	000456	012746 	000002 			mov	#2	,-(sp)		; /BBS/ counter for ^C's
     14	000462	120167 	000000G		10$:	cmpb	r1	,recsop		; wait for a packet header please
     15	000466	001446 				beq	60$			; got one, exit
     16	000470	016700 	000000G			mov	sertim	,r0		; /62/ if waiting for server command
     17	000474	001002 				bne	20$			; /62/ then use that time-out
     18	000476	116700 	000001G			movb	senpar+p.time,r0	; /62/ else use "normal" time-out
     19	000502				20$:	calls	binrea	,<r0>		; read with time-out
	000502	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000504	010046 				  mov	r0	,-(sp)		; doing it thusly generates less code
	000506	010605 				  mov	sp	,r5		; set pointer to argument list
	000510	004767 	000000G			  jsr	pc	,binrea		; call the subroutine
	000514	005726 				  tst	(sp)+			; pop parameter list from stack
	000516	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     20	000520	005700 				tst	r0			; did the read work?
     21	000522	001026 				bne	50$			; oops, just exit then
     22	000524	010166 	000002 			mov	r1	,2(sp)		; /56/ save it
     23	000530	042701 	177600 			bic	#^c<177>,r1		; /44/ never want parity here
     24	000534	120127 	000003 			cmpb	r1	,#'C&37		; /BBS/ ^C returned?
     25	000540	001012 				bne	30$			; /41/ no
     26	000542	005316 				dec	(sp)			; /44/ should we really exit now?
     27	000544	001012 				bne	40$			; /44/ no, in case we got some noise
     28	000546	016767 	000000G	000000G		mov	cc$max	,cccnt		; /BBS/ force abort thru cptln routine
     29	000554	010667 	000000G			mov	sp	,ccflag		; /BBS/ else .spcps will bomb..
     30	000560	012700 	000000G			mov	#er$nin	,r0		; /BBS/ a fake time-out until
     31	000564	000405 				br	50$			; /BBS/ the ccast hits (15. ticks max)
     32	000566	012716 	000002 		30$:	mov	#2	,(sp)		; /BBS/ need TWO ^C's in a row to exit
     33	000572	004767 	001444 		40$:	call	rawio			; all's not well, perhaps dump packets
     34	000576	000731 				br	10$			; loop back for finding a packet start
     35	000600	005001 			50$:	clr	r1			; time-out, return a null
     36	000602	000413 				br	70$			; /56/
     37	000604	105766 	000002 		60$:	tstb	2(sp)			; /62/ parity perhaps?
     38	000610	100010 				bpl	70$			; /62/ no
     39	000612	005767 	000000G			tst	parity			; /BBS/ 8-bit channel?
     40	000616	001005 				bne	70$			; /56/ no
     41	000620	005767 	000000G			tst	incpar			; /62/ warning already done?
     42	000624	001002 				bne	70$			; /62/ ya, avoid rollover to zero..
     43	000626	005267 	000000G			inc	incpar			; /56/ ya, also want message only once
     44	000632	022626 			70$:	cmp	(sp)+	,(sp)+		; /BBS/ pop ^C counter, data buffer
     45	000634	000207 				return
     46
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 15
RPACK$ wait for a start of packet char (SOH)

      1
      2						.sbttl	RPACK$ initialization
      3
      4	000636	010400 			rpakin:	mov	r4	,r0		; /62/ copy local buffer pointer
      5	000640	012701 	000011 			mov	#11	,r1		; /62/ need to clear this many words
      6	000644	005020 			10$:	clr	(r0)+			; /62/ do it
      7	000646					sob	r1	,10$		; /62/ one word at a time
	000646	005301 				dec	r1
	000650	001375 				bne	10$
      8	000652	156764 	000001G	000010 		bisb	senpar+p.time,.timeo(r4) ; /62/ time-out := SET TIME-OUT value
      9	000660	016500 	000002 			mov	2(r5)	,r0
     10	000664	005020 				clr	(r0)+			; packet.length := 0
     11	000666	005020 				clr	(r0)+			; packet.number := 0
     12	000670	005020 				clr	(r0)+			; packet.type   := 0
     13	000672	000207 				return
     14
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 16
RPACK$ initialization

      1
      2						.sbttl	RPACK$ read with time-out
      3
      4	000674				rpakrd:	calls	binrea	,<.timeo(r4)>	; read input char
	000674	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	000676	016446 	000010 			  mov	.timeo(r4)	,-(sp)		; doing it thusly generates less code
	000702	010605 				  mov	sp	,r5		; set pointer to argument list
	000704	004767 	000000G			  jsr	pc	,binrea		; call the subroutine
	000710	005726 				  tst	(sp)+			; pop parameter list from stack
	000712	012605 				  mov	(sp)+	,r5		; /63/ restore r5
      5	000714	005700 				tst	r0			; did it work?
      6	000716	001004 				bne	10$			; no
      7	000720	004767 	001316 			call	rawio			; perhaps raw I/O logging
      8	000724	005000 				clr	r0			; no errors, also clears carry
      9	000726	000207 				return
     10	000730	000261 			10$:	sec				; flag the time-out
     11	000732	000207 				return
     12
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 17
RPACK$ read with time-out

      1
      2						.sbttl	RPACK$ extended header type 0 for long packets
      3
      4	000734	010246 			rdexhd:	mov	r2	,-(sp)		; /42/ added 08-Jan-86 Brian Nelson
      5	000736	010546 				mov	r5	,-(sp)		; need an odd register for mul
      6	000740	004767 	177730 			call	rpakrd			; extended header, read the lenx1
      7	000744	103506 				bcs	20$			; field, exiting on read errors
      8	000746	042701 	177600 			bic	#^c<177>,r1		; ensure parity is cleared out
      9	000752	110123 				movb	r1	,(r3)+		; save into checksum buffer
     10	000754					unchar	r1	,r5		; get the high order of length
	000754	005046 				clr	-(sp)
	000756	150116 				bisb	r1	,@sp
	000760	162716 	000040 			sub	#40	,@sp
	000764	112605 				movb	(sp)+	,r5
     11	000766					mul	#95.	,r5		; shift over please
	000766	012746 	000137 			mov	#95.	,-(sp)		; pass multiplier to p$mul
	000772	010546 				mov	r5	,-(sp)		; pass multiplicand too
	000774	004767 	000000G			call	p$mul			; multiply, returns a 16-bit product
	001000	012605 				.iif eq <$$-5>	mov	(sp)+	,r5	; ditto if r5
     12	001002	004767 	177666 			call	rpakrd			; extended header, read the lenx2
     13	001006	103465 				bcs	20$			; field, exiting on read errors
     14	001010	042701 	177600 			bic	#^c<177>,r1		; ensure parity is cleared out
     15	001014	110123 				movb	r1	,(r3)+		; save into checksum buffer
     16	001016					unchar	r1	,r1		; get the next one
	001016	005046 				clr	-(sp)
	001020	150116 				bisb	r1	,@sp
	001022	162716 	000040 			sub	#40	,@sp
	001026	112601 				movb	(sp)+	,r1
     17	001030	060105 				add	r1	,r5		; now we have the extended length
     18	001032	166705 	000000G			sub	chksiz	,r5		; drop it by checksum size
     19	001036	010564 	000006 			mov	r5	,.len(r4)	; save it here, of course
     20
     21	001042	016405 	000022 			mov	.cbuff(r4),r5		; now, at last, get the extended
     22	001046	012701 	000005 			mov	#5	,r1		; header checksum data
     23	001052	005046 				clr	-(sp)			; accumulate in stack
     24	001054	005000 			10$:	clr	r0			; use the normal safe way to add
     25	001056	152500 				bisb	(r5)+	,r0		; bytes even though we know that
     26	001060	060016 				add	r0	,(sp)		; no sign extends will happen
     27	001062					sob	r1	,10$		; next please
	001062	005301 				dec	r1
	001064	001373 				bne	10$
     28	001066	012600 				mov	(sp)+	,r0		; pop the checksum please
     29	001070	010002 				mov	r0	,r2		; save it
     30	001072	042702 	177477 			bic	#^c<300>,r2		; compute it as in:
     31	001076					ash	#-6	,r2		; chk=char((s+((s&0300)/0100))&77)
	001076	006202 				.iif lt <$$type>  asr	r2
	001100	006202 				.iif lt <$$type>  asr	r2
	001102	006202 				.iif lt <$$type>  asr	r2
	001104	006202 				.iif lt <$$type>  asr	r2
	001106	006202 				.iif lt <$$type>  asr	r2
	001110	006202 				.iif lt <$$type>  asr	r2
     32	001112	060002 				add	r0	,r2
     33	001114	042702 	177700 			bic	#^c<77>	,r2		; got it now
     34
     35	001120	004767 	177550 			call	rpakrd			; extended header - read the hcheck
     36	001124	103416 				bcs	20$			; field, exiting on read errors
     37	001126	005000 				clr	r0			; /63/ preset no error
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 17-1
RPACK$ extended header type 0 for long packets

     38	001130	042701 	177600 			bic	#^c<177>,r1		; ensure parity is cleared out
     39	001134	110123 				movb	r1	,(r3)+		; save into checksum buffer
     40	001136					unchar	r1	,r1		; convert to actual checksum now
	001136	005046 				clr	-(sp)
	001140	150116 				bisb	r1	,@sp
	001142	162716 	000040 			sub	#40	,@sp
	001146	112601 				movb	(sp)+	,r1
     41	001150	120102 				cmpb	r1	,r2		; do the checksums match?
     42	001152	001423 				beq	40$			; /63/ yes
     43	001154	012700 	000377 			mov	#badchk	,r0		; header checksum error
     44	001160	000404 				br	30$			; stuff the error
     45	001162	012700 	000124 		20$:	mov	#timout	,r0		; return time-out error
     46	001166	005064 	000006 			clr	.len(r4)		; /62/ don't log bogus data on timout
     47	001172	016605 	000002 		30$:	mov	2(sp)	,r5		; /BBS/ restore r5 to as entering
     48	001176	016501 	000002 			mov	2(r5)	,r1		; get address of result block
     49	001202	005061 	000000 			clr	o$len(r1)		; clear packet length
     50	001206	010061 	000004 			mov	r0	,o$typ(r1)	; return the error
     51	001212	010064 	000000 			mov	r0	,.typ(r4)	; here also please
     52	001216	012700 	177777 			mov	#-1	,r0		; fatal error
     53	001222	012605 			40$:	mov	(sp)+	,r5
     54	001224	012602 				mov	(sp)+	,r2
     55	001226	000207 				return
     56
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 18
RPACK$ extended header type 0 for long packets

      1
      2						.sbttl	RPACK$ get and convert the checksum
      3
      4	001230				rpakck:	save	<r3>			; use r3 for accumulating check
	001230	010346 				 mov	r3	,-(sp)
      5	001232	005003 				clr	r3			; assume zero for now
      6	001234	004767 	177434 			call	rpakrd			; read(input,ch)
      7	001240	103464 				bcs	20$			; exit if timed out
      8	001242	150167 	000000G			bisb	r1	,recbit		; recbit |= ch
      9	001246	042701 	177600 			bic	#^c<177>,r1		; ch := ch and 177b
     10	001252					unchar	r1	,r3		; received_check := ch
	001252	005046 				clr	-(sp)
	001254	150116 				bisb	r1	,@sp
	001256	162716 	000040 			sub	#40	,@sp
	001262	112603 				movb	(sp)+	,r3
     11	001264	126727 	000000G	000061 		cmpb	chktyp	,#defchk	; if len(checksum) > 8 bits
     12	001272	101446 				blos	10$			;  then begin
     13	001274					 ash	#6	,r3		;   check := check * 64
	001274	006303 				.iif gt <$$type>  asl	r3
	001276	006303 				.iif gt <$$type>  asl	r3
	001300	006303 				.iif gt <$$type>  asl	r3
	001302	006303 				.iif gt <$$type>  asl	r3
	001304	006303 				.iif gt <$$type>  asl	r3
	001306	006303 				.iif gt <$$type>  asl	r3
     14	001310	004767 	177360 			 call	rpakrd			;   read(input,ch)
     15	001314	103436 				 bcs	20$			;   exit if timed out
     16	001316	042701 	177600 			 bic	#^c<177>,r1		;   ch := ch and 177b
     17	001322					 unchar	r1	,r1		;   ch := unchar(ch)
	001322	005046 				clr	-(sp)
	001324	150116 				bisb	r1	,@sp
	001326	162716 	000040 			sub	#40	,@sp
	001332	112601 				movb	(sp)+	,r1
     18	001334	150103 				 bisb	r1	,r3		;   rcheck := rcheck + ch
     19	001336	126727 	000000G	000063 		 cmpb	chktyp	,#'3		;   if checktype = crc16
     20	001344	001021 				 bne	10$			;    then
     21	001346					 ash	#6	,r3		;     begin
	001346	006303 				.iif gt <$$type>  asl	r3
	001350	006303 				.iif gt <$$type>  asl	r3
	001352	006303 				.iif gt <$$type>  asl	r3
	001354	006303 				.iif gt <$$type>  asl	r3
	001356	006303 				.iif gt <$$type>  asl	r3
	001360	006303 				.iif gt <$$type>  asl	r3
     22	001362	004767 	177306 			 call	rpakrd			;      check := check * 64
     23	001366	103411 				 bcs	20$			;      check := check + ch
     24	001370	042701 	177600 			 bic	#^c<177>,r1		;      ch := ch and 177b
     25	001374					 unchar	r1	,r1
	001374	005046 				clr	-(sp)
	001376	150116 				bisb	r1	,@sp
	001400	162716 	000040 			sub	#40	,@sp
	001404	112601 				movb	(sp)+	,r1
     26	001406	150103 				 bisb	r1	,r3		;      end
     27	001410	000241 			10$:	clc
     28	001412	010364 	000004 		20$:	mov	r3	,.rcheck(r4)	; return the checksum
     29	001416					unsave	<r3>
	001416	012603 				 mov	(sp)+	,r3
     30	001420	000207 				return
     31
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 19
RPACK$ get and convert the checksum

      1
      2						.sbttl	RPACK$ end of packet housekeeping
      3
      4	001422	010346 			rpakfi:	mov	r3	,-(sp)		; compute correct checksum type
      5	001424	004767 	002654 			call	checks			; simple
      6	001430	012664 	000002 			mov	(sp)+	,.ccheck(r4)	; and stuff it in please
      7	001434	126464 	000002 	000004 		cmpb	.ccheck(r4),.rcheck(r4)	; compare computed, actual checksums
      8	001442	001403 				beq	10$			; they are the same
      9	001444	012764 	000377 	000000 		mov	#badchk	,.typ(r4)	; they're different, flag the error
     10	001452	016501 	000002 		10$:	mov	2(r5)	,r1		; where to return some things
     11	001456	016421 	000006 			mov	.len(r4),(r1)+		; /62/ O$LEN packet length
     12	001462	016421 	000012 			mov	.seq(r4),(r1)+		; /62/ O$SEQ packet number
     13	001466	016411 	000000 			mov	.typ(r4),(r1)		; /62/ O$TYP packet type
     14	001472	004767 	000004 			call	rpakst			; do stats and logging now
     15	001476	000167 	000250 			jmp	rpaklo			; /62/ possibly log checksum errors?
     16
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 20
RPACK$ end of packet housekeeping

      1
      2						.sbttl	RPACK$ statistics, logging, resonating packets fix
      3
      4	001502	126427 	000000 	000101 	rpakst:	cmpb	.typ(r4),#'A&137	; count the packet types for stats
      5	001510	103461 				blo	40$			; bad packet type
      6	001512	126427 	000000 	000132 		cmpb	.typ(r4),#'Z&137	; must in the range A..Z
      7	001520	101055 				bhi	40$			; definitely a bad packet
      8
      9						; /BBS/ check for resonating packets or hung driver
     10	001522	006267 	000000G			asr	nakrec			; shift prior tests down the line
     11	001526	126427 	000000 	000116 		cmpb	.typ(r4),#'N&137	; a NAK?
     12	001534	001003 				bne	10$			; nope..
     13	001536	052767 	000004 	000000G		bis	#4	,nakrec		; ya, mark shift reg at 1st position
     14	001544	026727 	000000G	000005 	10$:	cmp	nakrec	,#4+1		; looking for NAK xxx NAK series as
     15	001552	002004 				bge	20$			; when resonating, go clear it
     16	001554	126427 	000000 	000124 		cmpb	.typ(r4),#timout	; timed out?
     17	001562	001014 				bne	30$			; nope..
     18	001564	004767 	000000G		20$:	call	hose			; ya, try harder to make it go
     19	001570	005067 	000000G			clr	nakrec			; start over after hose
     20	001574	032767 	000004 	000000G		bit	#log$rp	,trace		; /BBS/ RPACK to TT?
     21	001602	001404 				beq	30$			; /BBS/ no
     22	001604					wrtall	#pak.03			; /62/ ya, display time out
	001604	012746 	000172'			mov	#pak.03	,-(sp)		; pass the address
	001610	004767 	000000G			call	wrtall			; do it
     23
     24	001614	116401 	000000 		30$:	 movb	.typ(r4),r1		; packet is ok, add it to the stats
     25	001620	162701 	000100 			 sub	#100	,r1		; convert to 1..26
     26	001624	006301 				 asl	r1			; to word offsets
     27	001626	006301 				 asl	r1			; /43/ double word offsets
     28	001630	062761 	000001 	000002G		 add	#1	,pcnt.r+2(r1)	; /43/ 32-bit addition today
     29	001636	005561 	000000G			 adc	pcnt.r+0(r1)		; /43/ the high order part of it
     30	001642	062767 	000001 	000002G		 add	#1	,pcnt.r+2	; /43/ add it in here also
     31	001650	005567 	000000G			 adc	pcnt.r+0		; /43/ high order part
     32
     33	001654	032767 	000004 	000000G	40$:	bit	#log$rp	,trace		; /BBS/ RPACK to TT?
     34	001662	001402 				beq	50$			; /BBS/ no
     35	001664					.newline			; /BBS/ ya, format display
	001664	004767 	000000G			call	l$pcrlf
     36	001670	032767 	000001 	000000G	50$:	bit	#log$pa	,trace		; tracing today?
     37	001676	001004 				bne	60$			; /BBS/ ya
     38	001700	032767 	000020 	000000G		bit	#log$de	,trace		; /62/ TT debugging?
     39	001706	001420 				beq	70$			; /BBS/ no
     40	001710				60$:	calls	dskdmp	,<#pak.02,.seq(r4),.typ(r4),.len(r4),@r5> ; /62/
	001710	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	001712	011546 				        mov	@r5	,-(sp)	; push it
	001714	016446 	000006 			        mov	.len(r4)	,-(sp)	; push it
	001720	016446 	000000 			        mov	.typ(r4)	,-(sp)	; push it
	001724	016446 	000012 			        mov	.seq(r4)	,-(sp)	; push it
	001730	012746 	000155'			        mov	#pak.02	,-(sp)	; push it
	001734	010605 				  mov	sp	,r5		; set up the argument list pointer
	001736	004767 	000000G			  jsr	pc	,dskdmp		; and go to the routine
	001742	062706 	000012 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	001746	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     41	001750	000207 			70$:	return
     42
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 21
RPACK$ statistics, logging, resonating packets fix

      1
      2						.sbttl	RPACK$ packet logging
      3
      4	001752	026464 	000004 	000002 	rpaklo:	cmp	.rcheck(r4),.ccheck(r4)	; checksums match?
      5	001760	001527 				beq	40$			; /62/ yes, do nothing then
      6	001762					save	<r0,r1>			; /62/
	001762	010046 				 mov	r0	,-(sp)
	001764	010146 				 mov	r1	,-(sp)
      7	001766	016700 	000000G			mov	trace	,r0		; /62/ copy of debug status word
      8	001772	042700 	177756 			bic	#^c<log$pa!log$de>,r0	; /62/ need to do this?
      9	001776	001516 				beq	30$			; /62/ nope
     10	002000	162706 	000144 			sub	#100.	,sp		; /63/ ya, make buffer for err message
     11	002004	010601 				mov	sp	,r1		; point to the buffer
     12	002006					strcpy	r1	,#pak.04	; /62/ a header
	002006	012746 	000203'			mov	#pak.04	,-(sp)
	002012	010146 				mov	r1	,-(sp)
	002014	004767 	000000G			jsr	pc	,strcpy
     13	002020					strlen	r1			; length so far
	002020	010100 				mov	r1	,r0
	002022	004767 	000000G			call	l$len
     14	002026	060001 				add	r0	,r1		; point to the end of it
     15	002030					deccvt	.rcheck(r4),r1		; convert to decimal
	002030	010546 				mov	r5	,-(sp)
	002032	005046 				clr	-(sp)
	002034	016446 	000004 			mov	.rcheck(r4)	,-(sp)
	002040	010146 				mov	r1	,-(sp)
	002042	010605 				mov	sp	,r5
	002044	004767 	000000G			call	l$cvtnum
	002050	062706 	000006 			add	#6	,sp
	002054	012605 				mov	(sp)+	,r5
     16	002056	062701 	000006 			add	#6	,r1		; move along please
     17	002062	112721 	000054 			movb	#comma	,(r1)+		; /62/ insert delimiter
     18	002066					deccvt	.ccheck(r4),r1		; the calculated checksum
	002066	010546 				mov	r5	,-(sp)
	002070	005046 				clr	-(sp)
	002072	016446 	000002 			mov	.ccheck(r4)	,-(sp)
	002076	010146 				mov	r1	,-(sp)
	002100	010605 				mov	sp	,r5
	002102	004767 	000000G			call	l$cvtnum
	002106	062706 	000006 			add	#6	,sp
	002112	012605 				mov	(sp)+	,r5
     19	002114	062701 	000006 			add	#6	,r1		; make it .asciz
     20	002120	105011 				clrb	@r1			; simple
     21	002122	010601 				mov	sp	,r1		; point back to the buffer
     22	002124	032767 	000001 	000000G		bit	#log$pa	,trace		; /62/ is packet debugging on?
     23	002132	001422 				beq	10$			; /62/ no
     24	002134					strlen	r1			; ya, get the length
	002134	010100 				mov	r1	,r0
	002136	004767 	000000G			call	l$len
     25	002142					calls	putrec	,<r1,r0,#lun.lo> ; dump buffer to disk
	002142	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	002144	012746 	000000G			        mov	#lun.lo	,-(sp)	; push it
	002150	010046 				        mov	r0	,-(sp)	; push it
	002152	010146 				        mov	r1	,-(sp)	; push it
	002154	010605 				  mov	sp	,r5		; set up the argument list pointer
	002156	004767 	000000G			  jsr	pc	,putrec		; and go to the routine
	002162	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 21-1
RPACK$ packet logging

	002166	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     26	002170	005700 				tst	r0			; /62/ did it work?
     27	002172	001402 				beq	10$			; /62/ ya
     28	002174	004767 	004054 			call	logerr			; /62/ no, handle the error
     29	002200	005767 	000000G		10$:	tst	remote			; /62/ running locally?
     30	002204	001011 				bne	20$			; /62/ no
     31	002206	032767 	000020 	000000G		bit	#log$de	,trace		; /62/ ya, is terminal debugging on?
     32	002214	001405 				beq	20$			; /62/ no
     33	002216					wrtall	r1			; /62/ ya, print it
	002216	010146 				mov	r1	,-(sp)		; pass the address
	002220	004767 	000000G			call	wrtall			; do it
     34	002224					.newline			; /62/
	002224	004767 	000000G			call	l$pcrlf
     35	002230	062706 	000144 		20$:	add	#100.	,sp		; /63/ pop buffer
     36	002234				30$:	unsave	<r1,r0>			; /62/
	002234	012601 				 mov	(sp)+	,r1
	002236	012600 				 mov	(sp)+	,r0
     37	002240	000207 			40$:	return
     38
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 22
RPACK$ packet logging

      1
      2						.sbttl	RPACK$ raw I/O logging, chars to RPACK debug display
      3
      4	002242				rawio:	save	<r0,r1>
	002242	010046 				 mov	r0	,-(sp)
	002244	010146 				 mov	r1	,-(sp)
      5	002246	032767 	000010 	000000G		bit	#log$io	,trace		; dumping all I/O today?
      6	002254	001414 				beq	20$			; /BBS/ no
      7	002256					save	<r1>
	002256	010146 				 mov	r1	,-(sp)
      8	002260	005000 				clr	r0			; avoid sxt
      9	002262	150100 				bisb	r1	,r0		; and setup call to putcr0
     10	002264	012701 	000000G			mov	#lun.lo	,r1		; write to this channel
     11	002270	004767 	000000G			call	putcr0			; simple
     12	002274	005700 				tst	r0			; /62/ did it work?
     13	002276	001402 				beq	10$			; /62/ ya
     14	002300	004767 	003750 			call	logerr			; /62/ no, handle the error
     15	002304				10$:	unsave	<r1>			; /62/
	002304	012601 				 mov	(sp)+	,r1
     16
     17	002306	032767 	000004 	000000G	20$:	bit	#log$rp	,trace		; /BBS/ dump to a local terminal?
     18	002314	001431 				beq	60$			; no
     19	002316	120167 	000000G			cmpb	r1	,recsop		; start of a packet?
     20	002322	001422 				beq	50$			; yes
     21	002324	120167 	000004G			cmpb	r1	,conpar+p.eol	; /BBS/ no, is this the end of line?
     22	002330	001005 				bne	30$			; /BBS/ no
     23	002332					wrtall	#pak.06			; /62/ yes, finish up the display
	002332	012746 	000243'			mov	#pak.06	,-(sp)		; pass the address
	002336	004767 	000000G			call	wrtall			; do it
     24	002342	000416 				br	60$
     25
     26	002344	005767 	000000G		30$:	tst	tsxsav			; /BBS/ running under TSX?
     27	002350	001403 				beq	40$			; /BBS/ nope
     28	002352	120167 	000000G			cmpb	r1	,m.tsxr		; /62/ ya, is this the TSLICH?
     29	002356	001410 				beq	60$			; /BBS/ ya, don't type it to TT
     30	002360	110100 			40$:	movb	r1	,r0		; /BBS/ get a byte
     31	002362	004767 	000000G			call	writ1char		; /BBS/ send it to TT
     32	002366	000404 				br	60$
     33
     34	002370				50$:	wrtall	#pak.05			; /62/ start of a packet
	002370	012746 	000235'			mov	#pak.05	,-(sp)		; pass the address
	002374	004767 	000000G			call	wrtall			; do it
     35	002400				60$:	unsave	<r1,r0>
	002400	012601 				 mov	(sp)+	,r1
	002402	012600 				 mov	(sp)+	,r0
     36	002404	000207 				return
     37
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 23
RPACK$ raw I/O logging, chars to RPACK debug display

      1
      2						.sbttl	Send a packet
      3
      4					;	S P A C K $
      5					;
      6					;	input:	  (r5)	= type of packet
      7					;		 2(r5)	= packet number
      8					;		 4(r5)	= length of the data to send
      9					;		 6(r5)	= location of the data to send
     10					;	output:	   r0	= error status
     11
     12	002406				spack$::save	<r1,r2,r3,r4>
	002406	010146 				 mov	r1	,-(sp)
	002410	010246 				 mov	r2	,-(sp)
	002412	010346 				 mov	r3	,-(sp)
	002414	010446 				 mov	r4	,-(sp)
     13	002416	004767 	000000G			call	dcdtst			; /62/ check DCD, report any change..
     14	002422	105767 	000000G			tstb	handch			; /62/ any particular handshake today?
     15	002426	001402 				beq	10$			; no
     16	002430	004767 	000626 			call	spakwa			; ya, do handshaking
     17	002434	004767 	000724 		10$:	call	spakin			; logging, padding, packet type stats
     18	002440	162706 	001144 			sub	#$allsiz,sp		; /42/ allocate a LONG buffer
     19	002444	010604 				mov	sp	,r4		; point to the buffer
     20	002446	005046 				clr	-(sp)			; count the total length
     21	002450	005767 	000000G			tst	prexon			; /53/ prefix all packets with an XON?
     22	002454	001403 				beq	20$			; /53/ no
     23	002456	112724 	000021 			movb	#xon	,(r4)+		; /53/ yes, insert one
     24	002462	005216 				inc	@sp			; /53/ write_length++
     25	002464				20$:	setpar	sensop	,(r4)+		; start all packets with the SOH
	002464	116746 	000000G			movb	sensop	,-(sp)
	002470	004767 	004164 			call	dopari
	002474	112624 				movb	(sp)+	,(r4)+
     26	002476	010402 				mov	r4	,r2		; get address for checksum compute
     27	002500	005216 				inc	@sp			; packetlength := succ(packetlength)
     28	002502	016500 	000004 			mov	4(r5)	,r0		; the length of the packet
     29	002506	012701 	000136 			mov	#maxpak	,r1		; /BBS/ preset for compare
     30	002512	026701 	000000G			cmp	senlng	,r1		; /BBS/ long packets this time?
     31	002516	101404 				blos	30$			; /BBS/ nope..
     32	002520	166701 	000000G			sub	chksiz	,r1		; /BBS/ ya, be sure checksum will fit
     33	002524	162701 	000002 			sub	#2	,r1		; /BBS/ SEQ + TYP have to fit too..
     34	002530	020001 			30$:	cmp	r0	,r1		; /BBS/ packet too large?
     35	002532	101532 				blos	50$			; no
     36	002534	005767 	000000G			tst	senlng			; /42/ receiver said it can do long
     37	002540	001525 				beq	40$			; /42/ packets?  if eq, no
     38										; /42/ otherwise build extended header
     39	002542	010246 				mov	r2	,-(sp)		; /42/ save address of start of packet
     40	002544	012746 	000040 			mov	#space	,-(sp)		; /42/ accumulate header checksum
     41	002550					setpar	#space	,(r4)+		; /42/ length is a space, of course
	002550	112746 	000040 			movb	#space	,-(sp)
	002554	004767 	004100 			call	dopari
	002560	112624 				movb	(sp)+	,(r4)+
     42	002562					tochar	2(r5)	,r1		; /42/ packet sequence please
	002562	005046 				clr	-(sp)
	002564	156516 	000002 			bisb	2(r5)	,@sp
	002570	062716 	000040 			add	#40	,@sp
	002574	112601 				movb	(sp)+	,r1
     43	002576	060116 				add	r1	,(sp)		; /42/ add into header checksum now
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 23-1
Send a packet

     44	002600					setpar	r1	,(r4)+		; /42/ insert it
	002600	110146 				movb	r1	,-(sp)
	002602	004767 	004052 			call	dopari
	002606	112624 				movb	(sp)+	,(r4)+
     45	002610	111501 				movb	(r5)	,r1		; /42/ the packet type is next
     46	002612	142701 	000040 			bicb	#40	,r1		; /42/ ensure always upper case
     47	002616	060116 				add	r1	,(sp)		; /42/ add in the checksum
     48	002620					setpar	r1	,(r4)+		; /42/ and insert that also
	002620	110146 				movb	r1	,-(sp)
	002622	004767 	004032 			call	dopari
	002626	112624 				movb	(sp)+	,(r4)+
     49	002630	010003 				mov	r0	,r3		; /42/ insert the total packet size
     50	002632	005002 				clr	r2			; /42/ first byte is size/95
     51	002634	066703 	000000G			add	chksiz	,r3		; /42/ must include checksum size
     52	002640					div	#95.	,r2		; /42/ second byte is size mod 95
	002640	012746 	000137 			mov	#95.	,-(sp)		; divisor
	002644	010346 				mov	r3	,-(sp)
	002646	010246 				mov	r2	,-(sp)
	002650	004767 	000000G			call	p$div			; divide
	002654	012603 				mov	(sp)+	,r3
	002656	012602 				mov	(sp)+	,r2
     53	002660					tochar	r2	,r2		; /42/ convert to character rep
	002660	005046 				clr	-(sp)
	002662	150216 				bisb	r2	,@sp
	002664	062716 	000040 			add	#40	,@sp
	002670	112602 				movb	(sp)+	,r2
     54	002672					tochar	r3	,r3		; /42/ convert to character rep
	002672	005046 				clr	-(sp)
	002674	150316 				bisb	r3	,@sp
	002676	062716 	000040 			add	#40	,@sp
	002702	112603 				movb	(sp)+	,r3
     55	002704					setpar	r2	,(r4)+		; /42/ insert high bits into packet
	002704	110246 				movb	r2	,-(sp)
	002706	004767 	003746 			call	dopari
	002712	112624 				movb	(sp)+	,(r4)+
     56	002714	060216 				add	r2	,(sp)		; /42/ add into checksum
     57	002716					setpar	r3	,(r4)+		; /42/ insert low bits into packet
	002716	110346 				movb	r3	,-(sp)
	002720	004767 	003734 			call	dopari
	002724	112624 				movb	(sp)+	,(r4)+
     58	002726	060316 				add	r3	,(sp)		; /42/ add into checksum
     59	002730	012600 				mov	(sp)+	,r0		; /42/ pop the checksum please
     60	002732	010002 				mov	r0	,r2		; /42/ save it
     61	002734	042702 	177477 			bic	#^c<300>,r2		; /42/ compute it as in:
     62	002740					ash	#-6	,r2		; /42/ checksum=
	002740	006202 				.iif lt <$$type>  asr	r2
	002742	006202 				.iif lt <$$type>  asr	r2
	002744	006202 				.iif lt <$$type>  asr	r2
	002746	006202 				.iif lt <$$type>  asr	r2
	002750	006202 				.iif lt <$$type>  asr	r2
	002752	006202 				.iif lt <$$type>  asr	r2
     63	002754	060002 				add	r0	,r2		; /42/ char((s+((s&300)/100))&77)
     64	002756	042702 	177700 			bic	#^c<77>	,r2		; /42/ got it now
     65	002762					tochar	r2	,r2		; /42/ convert checksum to character
	002762	005046 				clr	-(sp)
	002764	150216 				bisb	r2	,@sp
	002766	062716 	000040 			add	#40	,@sp
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 23-2
Send a packet

	002772	112602 				movb	(sp)+	,r2
     66	002774					setpar	r2	,(r4)+		; /42/ and insert into packet
	002774	110246 				movb	r2	,-(sp)
	002776	004767 	003656 			call	dopari
	003002	112624 				movb	(sp)+	,(r4)+
     67	003004	012602 				mov	(sp)+	,r2		; /42/ start checksum for rest here
     68	003006	062716 	000007 			add	#7	,(sp)		; /BBS/ add, in case of prexon, above
     69	003012	000444 				br	60$			; /42/ add off we go
     70
     71	003014	012700 	000133 		40$:	mov	#maxpak-3,r0		; yes, reset packet size please
     72	003020	062700 	000002 		50$:	add	#2	,r0		; + two for number and type
     73	003024	066700 	000000G			add	chksiz	,r0		; + the length of the checksum please
     74	003030	005001 				clr	r1			; accumulated checksum
     75	003032					tochar	r0	,r1		; start the checksum out right
	003032	005046 				clr	-(sp)
	003034	150016 				bisb	r0	,@sp
	003036	062716 	000040 			add	#40	,@sp
	003042	112601 				movb	(sp)+	,r1
     76	003044					setpar	r1	,(r4)+		; and stuff length into the packet
	003044	110146 				movb	r1	,-(sp)
	003046	004767 	003606 			call	dopari
	003052	112624 				movb	(sp)+	,(r4)+
     77	003054	005216 				inc	@sp			; packetlength := succ(packetlength)
     78	003056					tochar	2(r5)	,r0		; convert the packet number now
	003056	005046 				clr	-(sp)
	003060	156516 	000002 			bisb	2(r5)	,@sp
	003064	062716 	000040 			add	#40	,@sp
	003070	112600 				movb	(sp)+	,r0
     79	003072					setpar	r0	,(r4)+		; and stuff it into the packet
	003072	110046 				movb	r0	,-(sp)
	003074	004767 	003560 			call	dopari
	003100	112624 				movb	(sp)+	,(r4)+
     80	003102	005216 				inc	@sp			; packetlength := succ(packetlength)
     81	003104	111500 				movb	@r5	,r0		; get the packet type now
     82	003106	142700 	000040 			bicb	#40	,r0		; ensure UPPER CASE packet type
     83	003112					setpar	r0	,(r4)+		; insert the packet type into buffer
	003112	110046 				movb	r0	,-(sp)
	003114	004767 	003540 			call	dopari
	003120	112624 				movb	(sp)+	,(r4)+
     84	003122	005216 				inc	@sp			; packetlength := succ(packetlength)
     85
     86	003124	016501 	000004 		60$:	mov	4(r5)	,r1		; get the data length
     87	003130	001413 				beq	80$			; nothing to do
     88	003132	016503 	000006 			mov	6(r5)	,r3		; address of the data to send
     89
     90	003136	005000 			70$:	clr	r0			; get the next character
     91	003140	152300 				bisb	(r3)+	,r0		; next char
     92	003142					setpar	r0	,(r4)+		; now move the data byte into the buff
	003142	110046 				movb	r0	,-(sp)
	003144	004767 	003510 			call	dopari
	003150	112624 				movb	(sp)+	,(r4)+
     93	003152	005216 				inc	@sp			; packetlength := succ(packetlength)
     94	003154					sob	r1	,70$		; next please
	003154	005301 				dec	r1
	003156	001367 				bne	70$
     95
     96	003160	105014 			80$:	clrb	@r4			; set .asciz for call to checks
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 23-3
Send a packet

     97	003162	010246 				mov	r2	,-(sp)		; starting address for checksum field
     98	003164	004767 	001114 			call	checks			; simple
     99	003170	012602 				mov	(sp)+	,r2		; get the computed checksum now
    100	003172	004767 	000412 			call	spakck			; stuff checksum into buffer now
    101	003176	060016 				add	r0	,@sp		; and the length of the checksum
    102	003200					setpar	conpar+p.eol,(r4)+	; end of line
	003200	116746 	000004G			movb	conpar+p.eol	,-(sp)
	003204	004767 	003450 			call	dopari
	003210	112624 				movb	(sp)+	,(r4)+
    103	003212	005216 				inc	@sp			; packetlength := succ(packetlength)
    104	003214	012601 				mov	(sp)+	,r1		; packet length
    105	003216	010604 				mov	sp	,r4		; address(buffer)
    106	003220					calls	binwri	,<r4,r1>	; and dump the buffer out now
	003220	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003222	010146 				        mov	r1	,-(sp)	; push it
	003224	010446 				        mov	r4	,-(sp)	; push it
	003226	010605 				  mov	sp	,r5		; set up the argument list pointer
	003230	004767 	000000G			  jsr	pc	,binwri		; and go to the routine
	003234	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	003236	012605 				  mov	(sp)+	,r5		; /63/ restore r5
    107	003240	004767 	000750 			call	spakfi			; log to disk
    108	003244	062706 	001144 			add	#$allsiz,sp		; pop the buffer
    109	003250					unsave	<r4,r3,r2,r1>
	003250	012604 				 mov	(sp)+	,r4
	003252	012603 				 mov	(sp)+	,r3
	003254	012602 				 mov	(sp)+	,r2
	003256	012601 				 mov	(sp)+	,r1
    110	003260	000207 				return
    111
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 24
Send a packet

      1
      2						.sbttl	SPACK$ handshaking
      3
      4	003262				spakwa:	scan	@r5	,#han.no	; if packet type is in this list..
	003262	012746 	000270'			mov	#han.no	,-(sp)
	003266	005046 				clr	-(sp)
	003270	151516 				bisb	@r5	,@sp
	003272	004767 	000000G			call	scanch
      5	003276	005700 				tst	r0
      6	003300	001030 				bne	30$			; ..then skip the handshaking stuff
      7	003302					save	<r2>
	003302	010246 				 mov	r2	,-(sp)
      8	003304	016502 	000004 			mov	4(r5)	,r2		; /62/ limit looping to packet length
      9	003310	062702 	000014 			add	#14	,r2		; /62/ plus header, trailer, etc..
     10	003314	116700 	000001G			movb	senpar+p.time,r0	; /62/ use "normal" time-out
     11	003320				10$:	calls	binrea	,<r0>		; /62/ wait for handshake char
	003320	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003322	010046 				  mov	r0	,-(sp)		; doing it thusly generates less code
	003324	010605 				  mov	sp	,r5		; set pointer to argument list
	003326	004767 	000000G			  jsr	pc	,binrea		; call the subroutine
	003332	005726 				  tst	(sp)+			; pop parameter list from stack
	003334	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     12	003336	005700 				tst	r0			; did the read time out?
     13	003340	001007 				bne	20$			; /62/ if so, exit
     14	003342	142701 	000200 			bicb	#200	,r1		; ensure no parity is set
     15	003346	120167 	000000G			cmpb	r1	,handch		; is this the handshake character?
     16	003352	001402 				beq	20$			; /62/ ya
     17	003354					sob	r2	,10$		; no, try again but not forever please
	003354	005302 				dec	r2
	003356	001360 				bne	10$
     18	003360				20$:	unsave	<r2>
	003360	012602 				 mov	(sp)+	,r2
     19	003362	000207 			30$:	return
     20
     21						.save				; these packet types must NOT
     22	000270					.psect	$pdata			; be processed with handshaking
     23	000270	   123 	   111 	   122 	han.no:	.byte	msg$snd	,msg$ser ,msg$rcv ,msg$command ,msg$generic
     24	000275	   000 				.byte	0
     25						.even
     26	003364					.restore
     27
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 25
SPACK$ handshaking

      1
      2						.sbttl	SPACK$ logging, padding, packet type stats
      3
      4	003364	032767 	000001 	000000G	spakin:	bit	#log$pa	,trace		; packet debugging today?
      5	003372	001004 				bne	10$			; /BBS/ ya
      6	003374	032767 	000020 	000000G		bit	#log$de	,trace		; /62/ no, maybe TT debugging?
      7	003402	001420 				beq	20$			; /BBS/ no
      8	003404				10$:	calls	dskdmp	,<#pak.08,2(r5),@r5,4(r5),6(r5)> ; /62/ ya
	003404	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003406	016546 	000006 			        mov	6(r5)	,-(sp)	; push it
	003412	016546 	000004 			        mov	4(r5)	,-(sp)	; push it
	003416	011546 				        mov	@r5	,-(sp)	; push it
	003420	016546 	000002 			        mov	2(r5)	,-(sp)	; push it
	003424	012746 	000253'			        mov	#pak.08	,-(sp)	; push it
	003430	010605 				  mov	sp	,r5		; set up the argument list pointer
	003432	004767 	000000G			  jsr	pc	,dskdmp		; and go to the routine
	003436	062706 	000012 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	003442	012605 				  mov	(sp)+	,r5		; /63/ restore r5
      9
     10	003444	005767 	000000G		20$:	tst	pauset			; wait a moment?
     11	003450	001410 				beq	30$			; no
     12	003452					calls	suspend	,<pauset>	; yes
	003452	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003454	016746 	000000G			  mov	pauset	,-(sp)		; doing it thusly generates less code
	003460	010605 				  mov	sp	,r5		; set pointer to argument list
	003462	004767 	000000G			  jsr	pc	,suspend		; call the subroutine
	003466	005726 				  tst	(sp)+			; pop parameter list from stack
	003470	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     13	003472	005001 			30$:	clr	r1			; avoid sign extension
     14	003474	156701 	000002G			bisb	conpar+p.npad,r1	; send some pad characters?
     15	003500	001415 				beq	50$			; no padding
     16	003502	012702 	000003G			mov	#conpar+p.padc,r2	; /62/ address of the pad character
     17	003506				40$:	calls	binwri	,<r2,#1>	; send some padding
	003506	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	003510	012746 	000001 			        mov	#1	,-(sp)	; push it
	003514	010246 				        mov	r2	,-(sp)	; push it
	003516	010605 				  mov	sp	,r5		; set up the argument list pointer
	003520	004767 	000000G			  jsr	pc	,binwri		; and go to the routine
	003524	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	003526	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     18	003530					sob	r1	,40$		; next please
	003530	005301 				dec	r1
	003532	001365 				bne	40$
     19
     20	003534	111501 			50$:	movb	@r5	,r1		; the packet type next
     21	003536	120127 	000101 			cmpb	r1	,#'A&137	; a legitimate packet type?
     22	003542	103421 				blo	60$			; no
     23	003544	120127 	000132 			cmpb	r1	,#'Z&137	; must be in the range A..Z
     24	003550	101016 				bhi	60$			; no good
     25	003552	162701 	000100 			 sub	#100	,r1		; convert into range 1..26
     26	003556	006301 				 asl	r1			; and count the packet type
     27	003560	006301 				 asl	r1			; /43/ 32. bits
     28	003562	062761 	000001 	000002G		 add	#1	,pcnt.s+2(r1)	; /43/ 32. bits, pakcnt(type)++
     29	003570	005561 	000000G			 adc	pcnt.s+0(r1)		; /43/ 32. bits, the high part
     30	003574	062767 	000001 	000002G		 add	#1	,pcnt.s+2	; /43/ 32. bits now
     31	003602	005567 	000000G			 adc	pcnt.s+0		; /43/ the high order part
     32	003606	000207 			60$:	return
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 25-1
SPACK$ logging, padding, packet type stats

     33
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 26
SPACK$ logging, padding, packet type stats

      1
      2						.sbttl	SPACK$ compute checksum
      3
      4	003610	005000 			spakck:	clr	r0		; checksum.len := 0
      5	003612	126727 	000000G	000061 		cmpb	chktyp	,#defchk ; if checklength > 6 bits
      6	003620	101462 				blos	20$		;  then begin
      7	003622	126727 	000000G	000063 		cmpb	chktyp	,#'3	;   if checktype = crc16
      8	003630	001031 				bne	10$		;    then begin
      9	003632	010201 				mov	r2	,r1	;     checkchar1:=tochar(check[12..15])
     10	003634					 ash	#-14	,r1	;     shift over 12 bits
	003634	006201 				.iif lt <$$type>  asr	r1
	003636	006201 				.iif lt <$$type>  asr	r1
	003640	006201 				.iif lt <$$type>  asr	r1
	003642	006201 				.iif lt <$$type>  asr	r1
	003644	006201 				.iif lt <$$type>  asr	r1
	003646	006201 				.iif lt <$$type>  asr	r1
	003650	006201 				.iif lt <$$type>  asr	r1
	003652	006201 				.iif lt <$$type>  asr	r1
	003654	006201 				.iif lt <$$type>  asr	r1
	003656	006201 				.iif lt <$$type>  asr	r1
	003660	006201 				.iif lt <$$type>  asr	r1
	003662	006201 				.iif lt <$$type>  asr	r1
     11	003664	042701 	177760 			 bic	#^c<17>	,r1	;     mask off the high 12  bits
     12	003670					 tochar	r1	,@r4
	003670	005046 				clr	-(sp)
	003672	150116 				bisb	r1	,@sp
	003674	062716 	000040 			add	#40	,@sp
	003700	112614 				movb	(sp)+	,@r4
     13	003702					 setpar	@r4	,(r4)+
	003702	111446 				movb	@r4	,-(sp)
	003704	004767 	002750 			call	dopari
	003710	112624 				movb	(sp)+	,(r4)+
     14	003712	005200 				 inc	r0		;     packetlength := succ(packetlength)
     15									;    end
     16	003714	010201 			10$:	 mov	r2	,r1	;   checkchar1 := tochar(check[6..11])
     17	003716					 ash	#-6	,r1	;   shift over 6 bits
	003716	006201 				.iif lt <$$type>  asr	r1
	003720	006201 				.iif lt <$$type>  asr	r1
	003722	006201 				.iif lt <$$type>  asr	r1
	003724	006201 				.iif lt <$$type>  asr	r1
	003726	006201 				.iif lt <$$type>  asr	r1
	003730	006201 				.iif lt <$$type>  asr	r1
     18	003732	042701 	177700 			 bic	#^c<77>	,r1	;   mask off the higher order bits
     19	003736					 tochar	r1	,@r4
	003736	005046 				clr	-(sp)
	003740	150116 				bisb	r1	,@sp
	003742	062716 	000040 			add	#40	,@sp
	003746	112614 				movb	(sp)+	,@r4
     20	003750					 setpar	@r4	,(r4)+
	003750	111446 				movb	@r4	,-(sp)
	003752	004767 	002702 			call	dopari
	003756	112624 				movb	(sp)+	,(r4)+
     21	003760	005200 				 inc	r0		;   packetlength := succ(packetlength)
     22	003762	042702 	177700 			 bic	#^c<77>	,r2	;   now drop the high bits from checks
     23
     24	003766				20$:	tochar	r2	,@r4	; convert char
	003766	005046 				clr	-(sp)
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 26-1
SPACK$ compute checksum

	003770	150216 				bisb	r2	,@sp
	003772	062716 	000040 			add	#40	,@sp
	003776	112614 				movb	(sp)+	,@r4
     25	004000	005767 	000000G			tst	ranerr		; insert random checksum errors?
     26	004004	001407 				beq	40$		; no, please don't
     27	004006	010046 				mov	r0	,-(sp)	;+ test mode  irand uses r0
     28	004010	004767 	000024 			call	irand		;+ test mode  get a random number
     29	004014	005700 				tst	r0		;+ test mode  is it zero?
     30	004016	001001 				bne	30$		;+ test mode  no, leave things alone
     31	004020	105214 				incb	@r4		;+ test mode  ya, create an error
     32	004022	012600 			30$:	mov	(sp)+	,r0	;+ test mode  restore r0
     33	004024				40$:	setpar	@r4	,(r4)+	; set parity, if in use..
	004024	111446 				movb	@r4	,-(sp)
	004026	004767 	002626 			call	dopari
	004032	112624 				movb	(sp)+	,(r4)+
     34	004034	005200 				inc	r0		; packetlength := succ(packetlength)
     35	004036	000207 				return
     36
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 27
SPACK$ compute checksum

      1
      2						.sbttl	SPACK$ pseudo random number generator for testing
      3
      4	004040	005767 	000000G		irand:	tst	seed			; has a seed been set?
      5	004044	001003 				bne	10$			; ya, use that value
      6	004046	012767 	002322 	000000G		mov	#1234.	,seed		; no, use this default seed
      7	004054	016700 	000000G		10$:	mov	seed	,r0		; make a copy of it
      8	004060	010146 				mov	r1	,-(sp)		; preserve r1
      9	004062	010001 				mov	r0	,r1		; copy of seed number to
     10	004064					ash	#-4	,r1		; multiply it * 16. and
	004064	006201 				.iif lt <$$type>  asr	r1
	004066	006201 				.iif lt <$$type>  asr	r1
	004070	006201 				.iif lt <$$type>  asr	r1
	004072	006201 				.iif lt <$$type>  asr	r1
     11	004074	042701 	170000 			bic	#170000	,r1		; clear its bits 15. - 12. then
     12	004100					xor	r1	,r0		; toggle whatever's left in orig seed
	004100	010146 				mov	r1	,-(sp)		; it's much simpler to do this
	004102	040016 				bic	r0	,@sp		; for all RT-11 systems rather
	004104	040100 				bic	r1	,r0		; than to be selective
	004106	052600 				bis	(sp)+	,r0		; done
     13	004110					ash	#13	,r1		; dump bits 11. thru 0.
	004110	006301 				.iif gt <$$type>  asl	r1
	004112	006301 				.iif gt <$$type>  asl	r1
	004114	006301 				.iif gt <$$type>  asl	r1
	004116	006301 				.iif gt <$$type>  asl	r1
	004120	006301 				.iif gt <$$type>  asl	r1
	004122	006301 				.iif gt <$$type>  asl	r1
	004124	006301 				.iif gt <$$type>  asl	r1
	004126	006301 				.iif gt <$$type>  asl	r1
	004130	006301 				.iif gt <$$type>  asl	r1
	004132	006301 				.iif gt <$$type>  asl	r1
	004134	006301 				.iif gt <$$type>  asl	r1
     14	004136	042701 	100000 			bic	#100000	,r1		; ensure what's left is a positive num
     15	004142					xor	r1	,r0		; again, toggle the orig seed with it
	004142	010146 				mov	r1	,-(sp)		; it's much simpler to do this
	004144	040016 				bic	r0	,@sp		; for all RT-11 systems rather
	004146	040100 				bic	r1	,r0		; than to be selective
	004150	052600 				bis	(sp)+	,r0		; done
     16	004152	042700 	100000 			bic	#100000	,r0		; make sure result remains positive
     17	004156	010067 	000000G			mov	r0	,seed		; save it for the next time around..
     18	004162					ash	#-13	,r0		; shift so only 4 hi bits are output
	004162	006200 				.iif lt <$$type>  asr	r0
	004164	006200 				.iif lt <$$type>  asr	r0
	004166	006200 				.iif lt <$$type>  asr	r0
	004170	006200 				.iif lt <$$type>  asr	r0
	004172	006200 				.iif lt <$$type>  asr	r0
	004174	006200 				.iif lt <$$type>  asr	r0
	004176	006200 				.iif lt <$$type>  asr	r0
	004200	006200 				.iif lt <$$type>  asr	r0
	004202	006200 				.iif lt <$$type>  asr	r0
	004204	006200 				.iif lt <$$type>  asr	r0
	004206	006200 				.iif lt <$$type>  asr	r0
     19	004210	012601 				mov	(sp)+	,r1		; restore r1
     20	004212	000207 				return
     21
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 28
SPACK$ pseudo random number generator for testing

      1
      2						.sbttl	SPACK$ log to disk
      3
      4	004214	032767 	000010 	000000G	spakfi:	bit	#log$io	,trace		; dumping all I/O out?
      5	004222	001427 				beq	40$			; no
      6	004224					save	<r0,r1,r2,r4>
	004224	010046 				 mov	r0	,-(sp)
	004226	010146 				 mov	r1	,-(sp)
	004230	010246 				 mov	r2	,-(sp)
	004232	010446 				 mov	r4	,-(sp)
      7	004234	010102 				mov	r1	,r2		; anything to do?
      8	004236	001415 				beq	30$			; no
      9	004240	005000 			10$:	clr	r0			; yes, avoid sign extension
     10	004242	152400 				bisb	(r4)+	,r0		; get the next ch to dump
     11	004244	012701 	000000G			mov	#lun.lo	,r1		; the lun to write to
     12	004250	004767 	000000G			call	putcr0			; simple
     13	004254	005700 				tst	r0			; /62/ did it work?
     14	004256	001403 				beq	20$			; /62/ ya
     15	004260	004767 	001770 			call	logerr			; /62/ no, handle the error
     16	004264	000402 				br	30$			; /62/ then bail out
     17	004266				20$:	sob	r2	,10$		; next please
	004266	005302 				dec	r2
	004270	001363 				bne	10$
     18	004272				30$:	unsave	<r4,r2,r1,r0>
	004272	012604 				 mov	(sp)+	,r4
	004274	012602 				 mov	(sp)+	,r2
	004276	012601 				 mov	(sp)+	,r1
	004300	012600 				 mov	(sp)+	,r0
     19	004302	000207 			40$:	return
     20
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 29
SPACK$ log to disk

      1
      2						.sbttl	Compute checksum
      3
      4					;	C H E C K S
      5					;
      6					;	input:	  (sp)	= address of .asciz string to checksum
      7					;	output:	  (sp)	= the computed checksum
      8
      9	004304				checks:	save	<r0,r1,r2,r3>
	004304	010046 				 mov	r0	,-(sp)
	004306	010146 				 mov	r1	,-(sp)
	004310	010246 				 mov	r2	,-(sp)
	004312	010346 				 mov	r3	,-(sp)
     10	004314	016602 	000012 			mov	10+2(sp),r2		; pointer to the string to check
     11	004320	126727 	000000G	000063 		cmpb	chktyp	,#'3		; CRC-CCITT type today?
     12	004326	001015 				bne	10$			; no
     13	004330					strlen	r2			; yes, get the .asciz string length
	004330	010200 				mov	r2	,r0
	004332	004767 	000000G			call	l$len
     14	004336					calls	crcclc	,<r2,r0>	; compute the crc16
	004336	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	004340	010046 				        mov	r0	,-(sp)	; push it
	004342	010246 				        mov	r2	,-(sp)	; push it
	004344	010605 				  mov	sp	,r5		; set up the argument list pointer
	004346	004767 	000126 			  jsr	pc	,crcclc		; and go to the routine
	004352	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	004354	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     15	004356	010002 				mov	r0	,r2		; stuff the result into r2 for later
     16	004360	000440 				br	60$			; and exit
     17
     18	004362	005001 			10$:	clr	r1			; init the checksum accumulator
     19	004364	005003 			20$:	clr	r3			; get the next ch please
     20	004366	152203 				bisb	(r2)+	,r3		; got the next ch now
     21	004370	001411 				beq	40$			; hit the end of the string
     22	004372	005767 	000000G			tst	parity			; /BBS/ did the packet contain parity?
     23	004376	001402 				beq	30$			; no, leave bit 7 alone
     24	004400	042703 	177600 			bic	#^c<177>,r3		; yes, please clear bit seven
     25	004404	042701 	170000 		30$:	bic	#170000	,r1		; /42/ ensure long packet not overflow
     26	004410	060301 				add	r3	,r1		; check := check + ch
     27	004412	000764 				br	20$
     28
     29	004414	010102 			40$:	mov	r1	,r2		; checksum := ((checksum and 300B)/64)
     30	004416	126727 	000000G	000062 		cmpb	chktyp	,#'2		; 12 bit sum type checksum?
     31	004424	001414 				beq	50$			; yes, just exit
     32	004426	042702 	177477 			bic	#^c<300>,r2		; ((..+checksum) and 77b)
     33	004432					ash	#-6	,r2
	004432	006202 				.iif lt <$$type>  asr	r2
	004434	006202 				.iif lt <$$type>  asr	r2
	004436	006202 				.iif lt <$$type>  asr	r2
	004440	006202 				.iif lt <$$type>  asr	r2
	004442	006202 				.iif lt <$$type>  asr	r2
	004444	006202 				.iif lt <$$type>  asr	r2
     34	004446	060102 				add	r1	,r2
     35	004450	042702 	177700 			bic	#^c<77>	,r2
     36	004454	000402 				br	60$
     37
     38	004456	042702 	170000 		50$:	bic	#170000	,r2		; type 2 checksum
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 29-1
Compute checksum

     39	004462	010266 	000012 		60$:	mov	r2	,10+2(sp)	; return the checksum
     40	004466					unsave	<r3,r2,r1,r0>
	004466	012603 				 mov	(sp)+	,r3
	004470	012602 				 mov	(sp)+	,r2
	004472	012601 				 mov	(sp)+	,r1
	004474	012600 				 mov	(sp)+	,r0
     41	004476	000207 				return
     42
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 30
Compute checksum

      1
      2						.sbttl	CRC calculation
      3
      4					;	This routine will calculate the CRC for a string using the
      5					;	CRC-CCIT polynomial.
      6					;
      7					;	The string should be the fields of the packet between  but
      8					;	not including the  <mark>  and  the  block check, which is
      9					;	treated as a string of bits with the low order bit of  the
     10					;	first  character  first and the high order bit of the last
     11					;	character last --  this  is  how  the  bits  arrive on the
     12					;	transmission  line.  The  bit  string  is  divided by  the
     13					;	polynomial
     14					;
     15					;	x^16+x^12+x^5+1
     16					;
     17					;	The initial value of the  CRC  is  0.  The  result  is the
     18					;	remainder  of  this   division,   used   as-is  (i.e.  not
     19					;	complemented).
     20					;
     21					;	From 20KERMIT.MAC, rewritten for  PDP-11  by  Brian Nelson
     22					;	13-Jan-84 08:50:43
     23					;
     24					;	input:	  (r5)	= string address
     25					;		 2(r5)	= string length
     26					;	output:	   r0	= CRC
     27
     28	004500				crcclc:	save	<r1,r2,r3,r4,r5>
	004500	010146 				 mov	r1	,-(sp)
	004502	010246 				 mov	r2	,-(sp)
	004504	010346 				 mov	r3	,-(sp)
	004506	010446 				 mov	r4	,-(sp)
	004510	010546 				 mov	r5	,-(sp)
     29	004512	005000 				clr	r0			; initializease avoid PDP-11 sign extend
     36	004530	005767 	000000G			tst	parity			; /BBS/ did the packet have parity?
     37	004534	001402 				beq	20$			; no, leave bit seven alone
     38	004536	042701 	177600 			bic	#^c<177>,r1		; yes, clear bit seven please
     39	004542				20$:	ixor	r0	,r1		; add in with the current CRC
	004542	010046 				mov	r0	,-(sp)		; it's much simpler to do this
	004544	040116 				bic	r1	,@sp		; for all RT-11 systems rather
	004546	040001 				bic	r0	,r1		; than to be selective
	004550	052601 				bis	(sp)+	,r1		; done
     40	004552	010102 				mov	r1	,r2		; get the high four bits
     41	004554					ash	#-4	,r2		; and move them over to 3..0
	004554	006202 				.iif lt <$$type>  asr	r2
	004556	006202 				.iif lt <$$type>  asr	r2
	004560	006202 				.iif lt <$$type>  asr	r2
	004562	006202 				.iif lt <$$type>  asr	r2
     42	004564	042702 	177760 			bic	#^c<17>	,r2		; drop any bits left over
     43	004570	042701 	177760 			bic	#^c<17>	,r1		; and the low four bits
     44	004574	006301 				asl	r1			; times 2 for
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 30-1
CRC calculation

     45	004576	006302 				asl	r2			; word addressing
     46	004600	016101 	000336'			mov	crctb2(r1),r1		; get low portion of CRC factor
     47	004604					ixor	crctab(r2),r1		; ixor avoids hardware xor mode limits
	004604	016246 	000276'			mov	crctab(r2)	,-(sp)		; it's much simpler to do this
	004610	040116 				bic	r1	,@sp		; for all RT-11 systems rather
	004612	046201 	000276'			bic	crctab(r2)	,r1		; than to be selective
	004616	052601 				bis	(sp)+	,r1		; done
     48	004620	000300 				swab	r0			; shift off a byte from previous CRC
     49	004622	042700 	177400 			bic	#^c<377>,r0		; clear new high byte
     50	004626					ixor	r1	,r0		; add in the new value
	004626	010146 				mov	r1	,-(sp)		; it's much simpler to do this
	004630	040016 				bic	r0	,@sp		; for all RT-11 systems rather
	004632	040100 				bic	r1	,r0		; than to be selective
	004634	052600 				bis	(sp)+	,r0		; done
     51	004636					sob	r4	,10$		; next please
	004636	005304 				dec	r4
	004640	001331 				bne	10$
     52
     53	004642				30$:	unsave	<r5,r4,r3,r2,r1>
	004642	012605 				 mov	(sp)+	,r5
	004644	012604 				 mov	(sp)+	,r4
	004646	012603 				 mov	(sp)+	,r3
	004650	012602 				 mov	(sp)+	,r2
	004652	012601 				 mov	(sp)+	,r1
     54	004654	000207 				return
     55
     56						.save
     57	000276					.psect	$pdata
     58	000276	000000 	010201 	020402 	crctab:	.word	     0 ,010201 ,020402 ,030603 ,041004 ,051205 ,061406 ,071607
     59	000316	102010 	112211 	122412 		.word	102010 ,112211 ,122412 ,132613 ,143014 ,153215 ,163416 ,173617
     60	000336	000000 	010611 	021422 	crctb2:	.word	     0 ,010611 ,021422 ,031233 ,043044 ,053655 ,062466 ,072277
     61	000356	106110 	116701 	127532 		.word	106110 ,116701 ,127532 ,137323 ,145154 ,155745 ,164576 ,174367
     62	004656					.restore
     63
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 31
CRC calculation

      1
      2						.sbttl	Buffer file being sent	; /63/ moved back here for speed..
      3
      4					;	B U F F I L			  /63/ patched to include BUFPAK
      5					;
      6					;	input:	 (r5)	= #0 for file or null terminated source buffer address
      7					;		2(25)	= destination buffer, will be null terminated
      8					;	output:	  r0	= if <>, RMS error code
      9					;		  r1	= returned string length, excluding null terminator
     10					;
     11					;	Control and 8-bit char prefixing and repeat count encoding done here.
     12
     13	004656				buffil::save	<r2,r3,r4>		; /63/
	004656	010246 				 mov	r2	,-(sp)
	004660	010346 				 mov	r3	,-(sp)
	004662	010446 				 mov	r4	,-(sp)
     14	004664	016504 	000002 			mov	2(r5)	,r4		; destination buffer address
     15	004670	011505 				mov	 (r5)	,r5		; /63/ source buff addr or 0 if a file
     16	004672	005003 				clr	r3			; init a string length counter
     17	004674	016702 	000000G			mov	senlng	,r2		; /63/ long_packets on?   or clears r2
     18	004700	001002 				bne	10$			; /62/ ya..  to avoid sxt on next inst
     19	004702	156702 	000000G			bisb	conpar+p.spsiz,r2	; /63/ get receiver's max size
     20	004706	020267 	000000G		10$:	cmp	r2	,senlen		; /63/ rec'd packet_len > SET SEN PAC?
     21	004712	003402 				ble	20$			; /62/ no
     22	004714	016702 	000000G			mov	senlen	,r2		; /63/ ya, let SET SEN PAC prevail
     23	004720	162702 	000010 		20$:	sub	#10	,r2		; /63/ allow for rpt quoting, etc, etc
     24
     25	004724	005767 	000000G		30$:	tst	dorpt			; are we doing repeat counts?
     26	004730	001501 				beq	100$			; no
     27
     28	004732	004767 	000446 		40$:	call	gnc			; get next character
     29	004736	103423 				bcs	60$			; hit the end of the file
     30	004740	005767 	000000G			tst	rptinit			; if first time through this loop
     31	004744	001406 				beq	50$			; then
     32	004746	005067 	000000G			clr	rptinit			; flag we've been here now
     33	004752	005067 	000000G			clr	rptcount		; init the repeatt count
     34	004756	110167 	000000G			movb	r1	,rptlast	; save copy of char in rptlast buffer
     35	004762	120167 	000000G		50$:	cmpb	r1	,rptlast	; if the current char = rptlast char
     36	004766	001007 				bne	60$			; then
     37	004770	026727 	000000G	000136 		cmp	rptcount,#maxpak	; reached the mex repeat count yet?
     38	004776	002003 				bge	60$			; ya..
     39	005000	005267 	000000G			inc	rptcount		; no, bump the repeat count
     40	005004	000752 				br	40$			; and loop
     41
     42	005006	010167 	000000G		60$:	mov	r1	,rptsave	; save the failed character please
     43	005012	005767 	000000G			tst	rptcount		; this may be EOF on first character
     44	005016	001455 				beq	120$			; if so, we simply do nothing at all
     45	005020	026727 	000000G	000002 		cmp	rptcount,#2		; please don't bother with ONE char
     46	005026	003011 				bgt	80$			; don't waste the overhead for two
     47	005030	005001 			70$:	clr	r1			; avoid sign extension please
     48	005032	156701 	000000G			bisb	rptlast	,r1		; get the character to write
     49	005036	004767 	000130 			call	140$			; and stuff it into the buffer
     50	005042	005367 	000000G			dec	rptcount		; more to insert?
     51	005046	001370 				bne	70$			; yes
     52	005050	000417 				br	90$			; no, exit
     53
     54	005052	116724 	000000G		80$:	movb	rptquo	,(r4)+		; insert the repeat count quote
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 31-1
Buffer file being sent	; /63/ moved back here for speed..

     55	005056	005203 				inc	r3			; count it in the packet size
     56	005060					tochar	rptcount,(r4)+		; convert the repeat count to a char
	005060	005046 				clr	-(sp)
	005062	156716 	000000G			bisb	rptcount	,@sp
	005066	062716 	000040 			add	#40	,@sp
	005072	112624 				movb	(sp)+	,(r4)+
     57	005074	005203 				inc	r3			; and count in the packet size
     58	005076	005001 				clr	r1			; avoid sxt
     59	005100	156701 	000000G			bisb	rptlast	,r1		; recover the repeated character
     60	005104	004767 	000062 			call	140$			; and insert it into the buffer
     61	005110	116767 	000000G	000000G	90$:	movb	rptsave	,rptlast	; make the failing character the one
     62	005116	005067 	000000G			clr	rptcount		; in case of EOF, set this please
     63	005122	005700 				tst	r0			; was this the end of file?
     64	005124	001012 				bne	120$			; yes, we had better leave then
     65	005126	005267 	000000G			inc	rptcount		; no, initialize the count please
     66	005132	000405 				br	110$			; and check for overflow in the buffer
     67
     68	005134	004767 	000244 		100$:	call	gnc			; get next char
     69	005140	103404 				bcs	120$			; if (EOF) then break
     70	005142	004767 	000024 			call	140$			; stuff the character w/o repeats
     71	005146	020302 			110$:	cmp	r3	,r2		; /63/ room for more data?
     72	005150	103665 				blo	30$			; ya
     73
     74	005152	010301 			120$:	mov	r3	,r1		; return the length please
     75	005154	001401 				beq	130$			; nothing there
     76	005156	005000 				clr	r0			; say read was successful
     77	005160	105014 			130$:	clrb	(r4)			; /63/ null term for non-file usage
     78	005162					unsave	<r4,r3,r2>		; /63/ is harmless for file packets
	005162	012604 				 mov	(sp)+	,r4
	005164	012603 				 mov	(sp)+	,r3
	005166	012602 				 mov	(sp)+	,r2
     79	005170	000207 				return
     80
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 32
Buffer file being sent	; /63/ moved back here for speed..

      1
      2						.sbttl	Actually quote and stuff the char for BUFFIL
      3
      4	005172				140$:	save	<r0,r2>			; /63/ save regs used by caller
	005172	010046 				 mov	r0	,-(sp)
	005174	010246 				 mov	r2	,-(sp)
      5	005176	005767 	000000G			tst	do8bit			; if doing 8-bit prefixing
      6	005202	001407 				beq	150$			; and
      7	005204	105701 				tstb	r1			; bit_test(ch,200) is true
      8	005206	100005 				bpl	150$			; then
      9	005210	116724 	000000G			movb	ebquot	,(r4)+		; buffer[i] := eight_bit_quote
     10	005214	005203 				inc	r3			; i := succ(i)
     11	005216	142701 	000200 			bicb	#200	,r1		; ch := bit_clear(ch,200)
     12	005222	010102 			150$:	mov	r1	,r2		; /63/ ch0_7 := ch
     13	005224	042702 	177600 			bic	#^c<177>,r2		; ch0_6 := ch0_7 and 177
     14	005230	120267 	000005G			cmpb	r2	,senpar+p.qctl	; if ch0_6 = quote (ignoring hi bit)
     15	005234	001446 				beq	190$			; /63/ then quote it
     16	005236	005767 	000000G			tst	do8bit			; if doing 8-bit prefixing
     17	005242	001403 				beq	160$			; and
     18	005244	120267 	000000G			cmpb	r2	,ebquot		; if ch0_6 == binary_quote
     19	005250	001440 				beq	190$			; /63/ then quote it
     20	005252	005767 	000000G		160$:	tst	dorpt			; if doing repeat compression
     21	005256	001403 				beq	170$			; /63/ and
     22	005260	120267 	000000G			cmpb	r2	,rptquo		; if ch0_6 == repeat_quote
     23	005264	001432 				beq	190$			; /63/ then quote it
     24	005266	010100 			170$:	mov	r1	,r0		; /63/ copy to map char into ctlflgs
     25	005270	105200 				incb	r0			; /63/ wrap 377 to 0, others ch=ch+1
     26	005272	020027 	000041 			cmp	r0	,#41		; /63/ was char 37..0,377 (now 40..0)?
     27	005276	103410 				blo	180$			; /63/ yes, check for quoting enabled
     28	005300	162700 	000137 			sub	#137	,r0		; /63/ no, bump 240..200 to 101..41
     29	005304	020027 	000041 			cmp	r0	,#41		; /63/ if now < 41 then it's
     30	005310	103423 				blo	200$			; /63/ not a control char
     31	005312	020027 	000101 			cmp	r0	,#101		; /63/ if now > 101 then it's
     32	005316	101020 				bhi	200$			; /63/ not a control char
     33	005320	105760 	000000G		180$:	tstb	ctlflgs(r0)		; /63/ quote this control char?
     34	005324	001415 				beq	200$			; /63/ no, pass it as it is..
     35	005326					ctl	r1	,r1		; /63/ ch0_7 := ctl(ch0_7)
	005326	005046 				clr	-(sp)
	005330	150116 				bisb	r1	,@sp
	005332	004767 	000000G			call	l$xor
	005336	112601 				movb	(sp)+	,r1
     36	005340					ctl	r2	,r2		; /63/ ch0_6 := ctl(ch0_6)
	005340	005046 				clr	-(sp)
	005342	150216 				bisb	r2	,@sp
	005344	004767 	000000G			call	l$xor
	005350	112602 				movb	(sp)+	,r2
     37	005352	116724 	000005G		190$:	movb	senpar+p.qctl,(r4)+	; /63/ buffer[i] := quote
     38	005356	005203 				inc	r3			; /63/ length := succ(length)
     39	005360	005767 	000000G		200$:	tst	image			; if image_mode
     40	005364	001402 				beq	210$			; then
     41	005366	110124 				movb	r1	,(r4)+		; buffer[i] := ch0_7
     42	005370	000401 				br	220$			; else
     43	005372	110224 			210$:	movb	r2	,(r4)+		; buffer[i] := ch0_6
     44	005374	005203 			220$:	inc	r3			; length := succ(length)
     45	005376					unsave	<r2,r0>			; /63/ restore caller's registers
	005376	012602 				 mov	(sp)+	,r2
	005400	012600 				 mov	(sp)+	,r0
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 32-1
Actually quote and stuff the char for BUFFIL

     46	005402	000207 				return
     47
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 33
Actually quote and stuff the char for BUFFIL

      1
      2						.sbttl	Get the next char
      3
      4	005404	005705 			gnc:	tst	r5			; /63/ where is the next char?
      5	005406	001407 				beq	10$			; /63/ get it from a file
      6	005410	005000 				clr	r0			; /63/ preset to return success
      7	005412	005001 				clr	r1			; /63/ avoid sxt
      8	005414	152501 				bisb	(r5)+	,r1		; /63/ get next char from input buff
      9	005416	001013 				bne	30$			; /63/ go add it to stats
     10	005420	012700 	000000G			mov	#er$eof	,r0		; /63/ hit a null, flag end of data
     11	005424	000406 				br	20$			; /63/ and exit
     12
     13	005426	012700 	000000G		10$:	mov	#lun.in	,r0		; copy of file channel number
     14	005432	004767 	000000G			call	getcr0			; get next char
     15	005436	005700 				tst	r0			; did it work?
     16	005440	001402 				beq	30$			; ya
     17	005442	000261 			20$:	sec				; no, flag an error
     18	005444	000207 				return
     19
     20	005446	062767 	000001 	000002G	30$:	add	#1	,fileout+2	; /62/ stats on file data
     21	005454	005567 	000000G			adc	fileout+0		; /43/ 32. bits
     22	005460	000241 				clc				; success  clc here just in case..!
     23	005462	000207 				return
     24
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 34
Get the next char

      1
      2						.sbttl	Error message handler
      3
      4					;	E R R O R
      5					;
      6					;	input:	  (r5)	= arg count
      7					;		 2(r5)	= text for message #1
      8					;		 4(r5)	= and so on, total length not to exceed erbfsiz
      9
     10	005464				error::	save	<r1,r2,r3,r4,r5>
	005464	010146 				 mov	r1	,-(sp)
	005466	010246 				 mov	r2	,-(sp)
	005470	010346 				 mov	r3	,-(sp)
	005472	010446 				 mov	r4	,-(sp)
	005474	010546 				 mov	r5	,-(sp)
     11	005476	005767 	000000G			tst	remote			; if not remote then printm(..)
     12	005502	001010 				bne	10$			; we are the remote, send errors
     13	005504	004767 	000220 			call	printm			; simple
     14	005510	005767 	000000G			tst	linksts			; /63/ was link running?
     15	005514	001477 				beq	70$			; /63/ nope..
     16	005516	005767 	000000G			tst	inprogress		; /63/ packet exchange in progress?
     17	005522	001474 				beq	70$			; /63/ nope..  else send error packet
     18
     19	005524	012501 			10$:	mov	(r5)+	,r1		; message count
     20	005526	001472 				beq	70$			; nothing to do
     21
     22	005530	162706 	000172 			sub	#erbfsiz+2,sp		; remote, allocate a text buffer
     23	005534	010604 				mov	sp	,r4		; and point to it please
     24	005536	012702 	000170 			mov	#erbfsiz,r2		; /BBS/ init erbfsiz byte counter
     25
     26	005542	012503 			20$:	mov	(r5)+	,r3		; get the next message please
     27	005544	112314 			30$:	movb	(r3)+	,@r4		; now copy it to the buffer until
     28	005546	001404 				beq	40$			; we get a null
     29	005550	005204 				inc	r4			; bump buffer pointer to next pos
     30	005552					sob	r2	,30$		; or until we run
	005552	005302 				dec	r2
	005554	001373 				bne	30$
     31	005556	000404 				br	50$			; out of space to put it
     32	005560	005302 			40$:	dec	r2			; ensure sufficient space
     33	005562	001402 				beq	50$			; don't overwrite stack!!
     34	005564					sob	r1	,20$		; and get the next message
	005564	005301 				dec	r1
	005566	001365 				bne	20$
     35	005570	105014 			50$:	clrb	@r4			; ensure .asciz
     36
     37	005572	010604 				mov	sp	,r4		; all done, send the error packet
     38	005574					strlen	r4			; get the length
	005574	010400 				mov	r4	,r0
	005576	004767 	000000G			call	l$len
     39	005602					spack	#msg$error,paknum,r0,r4	; and send it
	005602	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	005604	010446 				        mov	r4	,-(sp)	; push it
	005606	010046 				        mov	r0	,-(sp)	; push it
	005610	016746 	000000G			        mov	paknum	,-(sp)	; push it
	005614	012746 	000105 			        mov	#msg$error	,-(sp)	; push it
	005620	010605 				  mov	sp	,r5		; set up the argument list pointer
	005622	004767 	174560 			  jsr	pc	,spack$		; and go to the routine
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 34-1
Error message handler

	005626	062706 	000010 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	005632	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     40	005634	032767 	000001 	000000G		bit	#log$pa	,trace		; /62/ logging packets?
     41	005642	001422 				beq	60$			; /62/ nope
     42	005644					strlen	r4			; /62/ ya, get length of it all
	005644	010400 				mov	r4	,r0
	005646	004767 	000000G			call	l$len
     43	005652					calls	putrec	,<r4,r0,#lun.lo> ; /62/ and dump buffer to disk
	005652	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	005654	012746 	000000G			        mov	#lun.lo	,-(sp)	; push it
	005660	010046 				        mov	r0	,-(sp)	; push it
	005662	010446 				        mov	r4	,-(sp)	; push it
	005664	010605 				  mov	sp	,r5		; set up the argument list pointer
	005666	004767 	000000G			  jsr	pc	,putrec		; and go to the routine
	005672	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	005676	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     44	005700	005700 				tst	r0			; /62/ did it work?
     45	005702	001402 				beq	60$			; /62/ ya
     46	005704	004767 	000344 			call	logerr			; /62/ no, go say why not
     47	005710	062706 	000172 		60$:	add	#erbfsiz+2,sp		; /62/ deallocate the text buffer
     48	005714				70$:	unsave	<r5,r4,r3,r2,r1>
	005714	012605 				 mov	(sp)+	,r5
	005716	012604 				 mov	(sp)+	,r4
	005720	012603 				 mov	(sp)+	,r3
	005722	012602 				 mov	(sp)+	,r2
	005724	012601 				 mov	(sp)+	,r1
     49	005726	000207 				return
     50
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 35
Error message handler

      1
      2						.sbttl	Print message if not remote, and copy to logfile
      3
      4					;	P R I N T M			; /62/ major revision
      5					;
      6					;	input:	  (r5)	= arg count
      7					;		 2(r5)	= text for message #1
      8					;		 4(r5)	= and so on, total length not to exceed erbfsiz
      9
     10	005730				printm::save				; save r0 - r5, inclusive
	005730	010046 				 mov	r0	,-(sp)
	005732	010146 				 mov	r1	,-(sp)
	005734	010246 				 mov	r2	,-(sp)
	005736	010346 				 mov	r3	,-(sp)
	005740	010446 				 mov	r4	,-(sp)
	005742	010546 				 mov	r5	,-(sp)
     11	005744	012501 				mov	(r5)+	,r1		; get the message count
     12	005746	001533 				beq	100$			; nothing to do
     13
     14	005750	162706 	000172 			sub	#erbfsiz+2,sp		; allocate a local text buffer
     15	005754	010604 				mov	sp	,r4		; and a pointer to it
     16	005756	012702 	000170 			mov	#erbfsiz,r2		; init byte overflow counter
     17
     18	005762	127527 	000000 	000077 		cmpb	@(r5)	,#'?		; is this an error message?
     19	005770	001420 				beq	10$			; ya, skip "Kermit:" prefix
     20	005772	127527 	000000 	000045 		cmpb	@(r5)	,#'%		; /62/ is this an error message?
     21	006000	001414 				beq	10$			; /62/ ya, skip "Kermit:" prefix
     22	006002					scan	#':	,@r5		; look for a colon indicating a
	006002	011546 				mov	@r5	,-(sp)
	006004	005046 				clr	-(sp)
	006006	152716 	000072 			bisb	#':	,@sp
	006012	004767 	000000G			call	scanch
     23	006016	005700 				tst	r0			; prefix string ala "Xyz: "
     24	006020	001004 				bne	10$			; found one, don't do 2 headers
     25	006022	012703 	000144'			mov	#pak.01	,r3		; stuff in "Kermit: " prefix
     26	006026	005201 				inc	r1			; by adding it to the arg count
     27	006030	000411 				br	20$			; and jumping in here..
     28
     29	006032	012503 			10$:	mov	(r5)+	,r3		; get the next message please
     30	006034	005767 	000000G			tst	tsxsav			; TSX?
     31	006040	001405 				beq	20$			; no
     32	006042	121367 	000000G			cmpb	(r3)	,m.tsxr		; is it the TSX lead-in char?
     33	006046	001002 				bne	20$			; no
     34	006050	005203 				inc	r3			; ya, skip past it and
     35	006052	000402 				br	30$			; don't type this to TT
     36	006054	112314 			20$:	movb	(r3)+	,@r4		; now copy it to the buffer until
     37	006056	001404 				beq	40$			; we get an ascii null
     38	006060	005204 			30$:	inc	r4			; bump buffer pointer to next position
     39	006062					sob	r2	,20$		; or until we run
	006062	005302 				dec	r2
	006064	001373 				bne	20$
     40	006066	000404 				br	50$			; out of space to put it
     41	006070	005302 			40$:	dec	r2			; ensure sufficient space
     42	006072	001402 				beq	50$			; don't overwrite stack!!
     43	006074					sob	r1	,10$		; and get the next message
	006074	005301 				dec	r1
	006076	001355 				bne	10$
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 35-1
Print message if not remote, and copy to logfile

     44
     45	006100	105014 			50$:	clrb	(r4)			; ensure .asciz
     46	006102	010604 				mov	sp	,r4		; all done, restore pointer
     47
     48	006104	005767 	000000G			tst	inserv			; skip TT stuff if a server
     49	006110	001022 				bne	80$			; go check for disk logging
     50	006112	005767 	000000G			tst	remote			; skip if we are the remote
     51	006116	001017 				bne	80$			; go check for disk logging
     52	006120	005767 	000000G			tst	xmode			; if amidst an extended reply
     53	006124	001003 				bne	60$			; do a newline for sure..
     54	006126	005767 	000000G			tst	logini			; need a .newline if this is set
     55	006132	001402 				beq	70$			; no, this line is clean
     56	006134				60$:	.newline
	006134	004767 	000000G			call	l$pcrlf
     57	006140				70$:	wrtall	r4			; dump local buffer to terminal
	006140	010446 				mov	r4	,-(sp)		; pass the address
	006142	004767 	000000G			call	wrtall			; do it
     58	006146					.newline
	006146	004767 	000000G			call	l$pcrlf
     59	006152	005067 	000000G			clr	logini			; may need a logging header
     60
     61	006156	032767 	000001 	000000G	80$:	bit	#log$pa	,trace		; logging packets?
     62	006164	001422 				beq	90$			; nope
     63	006166					strlen	r4			; ya, get length of it all
	006166	010400 				mov	r4	,r0
	006170	004767 	000000G			call	l$len
     64	006174					calls	putrec	,<r4,r0,#lun.lo> ; and dump buffer to disk
	006174	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	006176	012746 	000000G			        mov	#lun.lo	,-(sp)	; push it
	006202	010046 				        mov	r0	,-(sp)	; push it
	006204	010446 				        mov	r4	,-(sp)	; push it
	006206	010605 				  mov	sp	,r5		; set up the argument list pointer
	006210	004767 	000000G			  jsr	pc	,putrec		; and go to the routine
	006214	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	006220	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     65	006222	005700 				tst	r0			; did it work?
     66	006224	001402 				beq	90$			; ya
     67	006226	004767 	000022 			call	logerr			; no, go say why not
     68	006232	062706 	000172 		90$:	add	#erbfsiz+2,sp		; pop local buffer
     69	006236				100$:	unsave
	006236	012605 				 mov	(sp)+	,r5
	006240	012604 				 mov	(sp)+	,r4
	006242	012603 				 mov	(sp)+	,r3
	006244	012602 				 mov	(sp)+	,r2
	006246	012601 				 mov	(sp)+	,r1
	006250	012600 				 mov	(sp)+	,r0
     70	006252	000207 				return
     71
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 36
Print message if not remote, and copy to logfile

      1
      2						.sbttl	Logfile error handler	; /62/ all new
      3
      4	006254				logerr::calls	syserr	,<r0,#errtxt>	; enter with r0=whatever_the_error_was
	006254	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	006256	012746 	000000G			        mov	#errtxt	,-(sp)	; push it
	006262	010046 				        mov	r0	,-(sp)	; push it
	006264	010605 				  mov	sp	,r5		; set up the argument list pointer
	006266	004767 	000000G			  jsr	pc	,syserr		; and go to the routine
	006272	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	006274	012605 				  mov	(sp)+	,r5		; /63/ restore r5
      5	006276					.close	#lun.lo			; save what did make it to logfile..
	006276	012700 	003000G			MOV	#lun.lo+<6.*^O400>,R0
	006302	104374 				EMT	^O374
      6	006304	042767 	100013 	000000G		bic	#<log$op!log$al!log$io>,trace ; kill all disk-based debugging
      7	006312	012700 	000000G			mov	#er$lwe	,r0		; this is some logfile write error..
      8	006316					calls	syserr	,<r0,#spare1>	; generate an error message saying so
	006316	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	006320	012746 	000000G			        mov	#spare1	,-(sp)	; push it
	006324	010046 				        mov	r0	,-(sp)	; push it
	006326	010605 				  mov	sp	,r5		; set up the argument list pointer
	006330	004767 	000000G			  jsr	pc	,syserr		; and go to the routine
	006334	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	006336	012605 				  mov	(sp)+	,r5		; /63/ restore r5
      9	006340					strcat	#spare1	,#pak.07	; /62/ now insert a <cr><lf> after it
	006340	012746 	000250'			mov	#pak.07	,-(sp)
	006344	012746 	000000G			mov	#spare1	,-(sp)
	006350	004767 	000000G			jsr	pc	,strcat
     10	006354					strcat	#spare1	,#errtxt	; then include the reported error too
	006354	012746 	000000G			mov	#errtxt	,-(sp)
	006360	012746 	000000G			mov	#spare1	,-(sp)
	006364	004767 	000000G			jsr	pc	,strcat
     11	006370	005767 	000000G			tst	inserv			; skip TT stuff
     12	006374	001021 				bne	30$			; if a server
     13	006376	005767 	000000G			tst	remote			; skip if we
     14	006402	001016 				bne	30$			; are the remote
     15	006404	005767 	000000G		10$:	tst	logini			; need a .newline if this is set
     16	006410	001402 				beq	20$			; no, this line is clean
     17	006412					.newline
	006412	004767 	000000G			call	l$pcrlf
     18	006416				20$:	wrtall	#spare1			; dump local buffer to terminal
	006416	012746 	000000G			mov	#spare1	,-(sp)		; pass the address
	006422	004767 	000000G			call	wrtall			; do it
     19	006426					.newline
	006426	004767 	000000G			call	l$pcrlf
     20	006432	005067 	000000G			clr	logini			; may need a packet cnt logging header
     21	006436	000207 				return
     22
     23	006440	005767 	000000G		30$:	tst	linksts			; got a path for an error packet?
     24	006444	001757 				beq	10$			; nope, dump it to TT regardless then
     25	006446					strlen	#spare1			; ya, get the length of and
	006446	012700 	000000G			mov	#spare1	,r0
	006452	004767 	000000G			call	l$len
     26	006456					spack	#msg$error,paknum,r0,#spare1 ; then send the error message
	006456	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	006460	012746 	000000G			        mov	#spare1	,-(sp)	; push it
	006464	010046 				        mov	r0	,-(sp)	; push it
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 36-1
Logfile error handler	; /62/ all new

	006466	016746 	000000G			        mov	paknum	,-(sp)	; push it
	006472	012746 	000105 			        mov	#msg$error	,-(sp)	; push it
	006476	010605 				  mov	sp	,r5		; set up the argument list pointer
	006500	004767 	173702 			  jsr	pc	,spack$		; and go to the routine
	006504	062706 	000010 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	006510	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     27	006512	112767 	000101 	000000G		movb	#sta.abo,state		; /62/ and force the trasnfer to abort
     28	006520	000207 				return
     29
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 37
Logfile error handler	; /62/ all new

      1
      2						.sbttl	Process retry and sync errors
      3
      4	006522				m$retr::save	<r0>			; retry abort
	006522	010046 				 mov	r0	,-(sp)
      5	006524	132767 	000200 	000000G		bitb	#200	,recbit		; /44/ perhaps parity was going?
      6	006532	001421 				beq	10$			; /44/ no
      7	006534	005767 	000000G			tst	parity			; /BBS/ do we know about parity?
      8	006540	001016 				bne	10$			; /44/ yes we do, normal abort
      9	006542					calls	error	,<#2,#e$retr,#e$pari> ; /62/ no, mention it now!
	006542	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	006544	012746 	000004'			        mov	#e$pari	,-(sp)	; push it
	006550	012746 	000052'			        mov	#e$retr	,-(sp)	; push it
	006554	012746 	000002 			        mov	#2	,-(sp)	; push it
	006560	010605 				  mov	sp	,r5		; set up the argument list pointer
	006562	004767 	176676 			  jsr	pc	,error		; and go to the routine
	006566	062706 	000006 			  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
	006572	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     10	006574	000412 				br	20$			; /44/ exit
     11	006576				10$:	calls	error	,<#1,#e$retr>	; send/print the error message
	006576	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	006600	012746 	000052'			        mov	#e$retr	,-(sp)	; push it
	006604	012746 	000001 			        mov	#1	,-(sp)	; push it
	006610	010605 				  mov	sp	,r5		; set up the argument list pointer
	006612	004767 	176646 			  jsr	pc	,error		; and go to the routine
	006616	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	006620	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     12	006622				20$:	unsave	<r0>
	006622	012600 				 mov	(sp)+	,r0
     13	006624	000207 				return
     14
     15	006626				m$sync::save	<r0>			; out of sync
	006626	010046 				 mov	r0	,-(sp)
     16	006630					calls	error	,<#1,#e$sync>	; send/print the error message
	006630	010546 				mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
	006632	012746 	000076'			        mov	#e$sync	,-(sp)	; push it
	006636	012746 	000001 			        mov	#1	,-(sp)	; push it
	006642	010605 				  mov	sp	,r5		; set up the argument list pointer
	006644	004767 	176614 			  jsr	pc	,error		; and go to the routine
	006650	022626 				  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
	006652	012605 				  mov	(sp)+	,r5		; /63/ restore r5
     17	006654					unsave	<r0>
	006654	012600 				 mov	(sp)+	,r0
     18	006656	000207 				return
     19
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 38
Process retry and sync errors

      1
      2						.sbttl	Compute parity for an outgoing 8-bit link
      3
      4					;	This is software parity generation as it allows Kermit to control
      5					;	it even on interfaces which don't support it (by setting them for
      6					;	8 data bits and no parity).  It was derived from the Pascal RT-11
      7					;	Kermit by Phil Murton, and does a table lookup to compute parity.
      8					;	For the sake of speed and because some RT-11 systems lack certain
      9					;	instructions this method is used at a slight cost in space.
     10
     11	006660				dopari::save	<r0,r1>			; /BBS/	somewhat cleaned up..
	006660	010046 				 mov	r0	,-(sp)
	006662	010146 				 mov	r1	,-(sp)
     12	006664	016700 	000000G			mov	parity	,r0		; get the current parity setting
     13	006670	001407 				beq	10$			; nothing to do
     14	006672	006300 				asl	r0			; word indexing to addresses
     15	006674	016601 	000006 			mov	6(sp)	,r1		; get the character to do it to
     16	006700	004770 	000376'			jsr	pc	,@pardsp(r0)	; and dispatch as desired
     17	006704	010166 	000006 			mov	r1	,6(sp)		; return the character please
     18	006710				10$:	unsave	<r1,r0>
	006710	012601 				 mov	(sp)+	,r1
	006712	012600 				 mov	(sp)+	,r0
     19	006714	000207 				return
     20
     21						.save
     22	000376					.psect	$pdata
     23	000376	000000 	006732'	006752'	pardsp:	.word	0  ,odd.p  ,even.p  ,mark.p  ,spac.p
     24	006716					.restore
     25
     26	006716	152701 	000200 		mark.p:	bisb	#200	,r1		; mark means we are always HIGH
     27	006722	000207 				return				; on bit seven
     28
     29	006724	142701 	000200 		spac.p:	bicb	#200	,r1		; space means we are always LOW
     30	006730	000207 				return				; on bit seven
     31
     32	006732	042701 	177600 		odd.p:	bic	#^c<177>,r1		; hose any previous parity
     33	006736	105761 	000410'			tstb	partab(r1)		; if char's entry in table is <>
     34	006742	001002 				bne	10$			; leave parity bit clear
     35	006744	152701 	000200 			bisb	#200	,r1		; else set parity bit
     36	006750	000207 			10$:	return
     37
     38	006752	042701 	177600 		even.p:	bic	#^c<177>,r1		; hose any previous parity
     39	006756	105761 	000410'			tstb	partab(r1)		; if char's entry in table is 0
     40	006762	001402 				beq	10$			; leave parity bit clear
     41	006764	152701 	000200 			bisb	#200	,r1		; else set parity bit
     42	006770	000207 			10$:	return
     43
     44						.save
     45	000410					.psect	$pdata
     46	000410	   000 	   001 	   001 	partab:	.byte	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0  ; first 16 ascii characters
     47	000430	   001 	   000 	   000 		.byte	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1
     48	000450	   001 	   000 	   000 		.byte	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1
     49	000470	   000 	   001 	   001 		.byte	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0
     50	000510	   001 	   000 	   000 		.byte	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1
     51	000530	   000 	   001 	   001 		.byte	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0
     52	000550	   000 	   001 	   001 		.byte	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0
     53	000570	   001 	   000 	   000 		.byte	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1  ; last 16 characters (to 177)
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 38-1
Compute parity for an outgoing 8-bit link

     54	006772					.restore
     55
     56		000001 				.end
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 38-2
Symbol table

ABT$AL  000132   	ERRBYT= 000052   	LOG$OP= 100000   	PCNT.S= ****** GX	STATE = ****** GX
ABT$CU  000130   	ERROR   005464RG    002	LOG$PA= 000001   	PREXON= ****** GX	STA.AB  000101
ABT$ER  000105   	ERROR$= 000004   	LOG$RP= 000004   	PRINTM  005730RG    002	STA.AT  000110
ALSIZE= 001000   	ERRTXT= ****** GX	LUN.IN= ****** GX	PUTCR0= ****** GX	STA.BR  000102
ASPACE  000000RG    003	ER$EOF= ****** GX	LUN.LO= ****** GX	PUTREC= ****** GX	STA.CC  000100
AT.ALL  000177   	ER$LWE= ****** GX	L$CVTN= ****** GX	P$DIV = ****** GX	STA.CO  000103
AT.CDT  000001   	ER$NIN= ****** GX	L$LEN = ****** GX	P$MUL = ****** GX	STA.DA  000104
AT.INF  000002   	ESC   = 000033   	L$PCRL= ****** GX	P.CAPA= 000011   	STA.EO  000132
AT.LEN  000004   	EVEN.P  006752R     002	L$XOR = ****** GX	P.CHKT= 000007   	STA.FI  000106
AT.ON   100000   	E$PARI  000004R     003	MARK.P  006716R     002	P.EOL = 000004   	STA.IN  000111
AT.PRO  000010   	E$RETR  000052R     003	MAXLNG= 001130   	P.MXL1= 000013   	STA.RI  000122
AT.SYS  000020   	E$SYNC  000076R     003	MAXPAK  000136   	P.MXL2= 000014   	STA.SI  000123
AT.TYP  000040   	FATAL$= 000020   	MSG$AC  000131   	P.NPAD= 000002   	STA.TY  000130
AT.XLE  000100   	FF    = 000014   	MSG$AT  000101   	P.PADC= 000003   	STRCAT= ****** GX
BADCHK= 000377 G 	FILEOU= ****** GX	MSG$BR  000102   	P.QBIN= 000006   	STRCPY= ****** GX
BELL  = 000007   	GETCR0= ****** GX	MSG$CO  000103   	P.QCTL= 000005   	SUCCS$= 000001
BINARY  000001   	GNC     005404R     002	MSG$DA  000104   	P.REPT= 000010   	SUSPEN= ****** GX
BINREA= ****** GX	GN$BYE  000114   	MSG$EO  000132   	P.SPSI= 000000   	SYSERR= ****** GX
BINWRI= ****** GX	GN$CON  000103   	MSG$ER  000105   	P.TIME= 000001   	TAB   = 000011
BS    = 000010   	GN$COP  000113   	MSG$FI  000106   	P.VEND= 000017   	TERMIN  177777
BUFFIL  004656RG    002	GN$DEL  000105   	MSG$GE  000107   	P.WIND= 000012   	TEXT    000000
CAPA.A= 000010   	GN$DIR  000104   	MSG$KE  000113   	RANERR= ****** GX	TILDE = 000176
CAPA.L= 000002   	GN$DIS  000125   	MSG$NA  000116   	RAWIO   002242R     002	TIMOUT= 000124 G
CAPA.S= 000004   	GN$EXI  000106   	MSG$RC  000122   	RDEXHD  000734R     002	TRACE = ****** GX
CCCNT = ****** GX	GN$HEL  000110   	MSG$SE  000111   	RECBIT= ****** GX	TSXSAV= ****** GX
CCFLAG= ****** GX	GN$JOU  000112   	MSG$SN  000123   	RECSOP= ****** GX	TTY   = 000001
CC$MAX= ****** GX	GN$LOG  000111   	MSG$TE  000130   	REMOTE= ****** GX	USERRB= 000053
CHECKS  004304R     002	GN$PRI  000120   	M$RETR  006522RG    002	RPACK$  000000RG    002	VT100 = 000002
CHKSIZ= ****** GX	GN$PRO  000120   	M$SYNC  006626RG    002	RPAKCK  001230R     002	VT200 = 000003
CHKTYP= ****** GX	GN$QUE  000121   	M.TSXR= ****** GX	RPAKFI  001422R     002	WAITSO  000452R     002
COMMA = 000054   	GN$REN  000122   	NAKREC= ****** GX	RPAKIN  000636R     002	WARN$ = 000002
CONPAR= ****** GX	GN$SEN  000115   	NONEIS= 000001   	RPAKLO  001752R     002	WRIT1C= ****** GX
CON$ES= 000034   	GN$SUB  000123   	NOSCOP= 000000   	RPAKRD  000674R     002	WRTALL= ****** GX
CR    = 000015   	GN$TYP  000124   	NULL    000002RG    003	RPAKST  001502R     002	XMODE = ****** GX
CRCCLC  004500R     002	GN$VAR  000126   	ODD.P   006732R     002	RPTCOU= ****** GX	XOFF  = 000023
CRCTAB  000276R     003	GN$WHO  000127   	O$LEN = 000000   	RPTINI= ****** GX	XON   = 000021
CRCTB2  000336R     003	HANDCH= ****** GX	O$SEQ = 000002   	RPTLAS= ****** GX	$ALLSI= 001144
CTLFLG= ****** GX	HAN.NO  000270R     003	O$TYP = 000004   	RPTQUO= ****** GX	$C    = 000004
CTRL$N= 000016   	HOSE  = ****** GX	PAKNUM= ****** GX	RPTSAV= ****** GX	$$    = 000002
CTRL$O= 000017   	IMAGE = ****** GX	PAK.01  000144R     003	SCANCH= ****** GX	$$SIZE= 000004
C.CRLF= 000004   	INCPAR= ****** GX	PAK.02  000155R     003	SCOLON= 000073   	$$TYPE= 177777
C.LCUC= 000040   	INPROG= ****** GX	PAK.03  000172R     003	SEED  = ****** GX	$$$0  = 000000
C.LSPA= 000010   	INSERV= ****** GX	PAK.04  000203R     003	SENLEN= ****** GX	$$1   = 000001
C.SSPA= 000020   	IRAND   004040R     002	PAK.05  000235R     003	SENLNG= ****** GX	$$2   = 000000
C.TSPA= 000200   	JSW   = 000044   	PAK.06  000243R     003	SENPAR= ****** GX	$$5   = 000027
DCDTST= ****** GX	KRTINC= 000001   	PAK.07  000250R     003	SENSOP= ****** GX	.CBUFF= 000022
DECNAT  000002   	LF    = 000012   	PAK.08  000253R     003	SERTIM= ****** GX	.CCHEC= 000002
DEFCHK= 000061 G 	LINKST= ****** GX	PARDSP  000376R     003	SEVER$= 000010   	.HDTYP= 000020
DEL   = 000177   	LN$CNT= 000003   	PARITY= ****** GX	SOH   = 000001   	.LEN  = 000006
DOPARI  006660RG    002	LN$MAX= 000120   	PARTAB  000410R     003	SPACE = 000040   	.LSIZE= 000024
DORPT = ****** GX	LOGERR  006254RG    002	PAR$EV  000002   	SPACK$  002406RG    002	.RCHEC= 000004
DOT   = 000056   	LOGINI= ****** GX	PAR$MA  000003   	SPAC.P  006724R     002	.SEQ  = 000012
DO8BIT= ****** GX	LOG$AL= 000003   	PAR$NO  000000   	SPAKCK  003610R     002	.SIZE = 000014
DSKDMP= ****** GX	LOG$CO= 000002   	PAR$OD  000001   	SPAKFI  004214R     002	.TIMEO= 000010
EBQUOT= ****** GX	LOG$DE= 000020   	PAR$SP  000004   	SPAKIN  003364R     002	.TOGO = 000016
EOF$DI  000104   	LOG$IO= 000010   	PAUSET= ****** GX	SPAKWA  003262R     002	.TYP  = 000000
ERBFSI= 000170   	LOG$ON= 040000   	PCNT.R= ****** GX	SPARE1= ****** GX	...V1 = 000003
KRTPAK	Packet driver	MACRO V05.03b  00:01  Page 38-3
Symbol table

...V2 = 000027

. ABS.	000000    000	(RW,I,GBL,ABS,OVR)
      	000000    001	(RW,I,LCL,REL,CON)
$CODE 	006772    002	(RO,I,LCL,REL,CON)
$PDATA	000610    003	(RO,D,LCL,REL,CON)
Errors detected:  0

*** Assembler statistics


Work  file  reads: 49
Work  file writes: 50
Size of work file: 13904 Words  ( 55 Pages)
Size of core pool: 12544 Words  ( 49 Pages)
Operating  system: RT-11

Elapsed time: 00:00:01.05
KRTPAK,KRTPAK=KRTNHD,KRTPAK
