.MAIN.	MACRO V05.03b  00:01
Table of contents

    1-   1	KRTNHD	EIS macros for a non-EIS CPU
    4-   1	KRTMAC	Various handy constants and macros
    6-   2	Utility macros
    8-   1	KRTCDF	Define command macro
   11-   3	Local data		; /63/ consolidate data here..
   12-   3	Define the SET commands
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 1
KRTNHD	EIS macros for a non-EIS CPU

      1						.sbttl	KRTNHD	EIS macros for a non-EIS CPU
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					; /62/	27-Jul-93  Billy Youdelman  V03.62
      6					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
      7					;
      8					;	Assemble Kermit-11 modules with this for use on a
      9					;	non-EIS CPU.  This calls p$mul and p$div, assembly
     10					;	of which into KRTSUB depends on defining "NONEIS".
     11					;	KRTASM.NON assembles everything for non-EIS use.
     12
     13					;	10-Apr-84  09:37:15  Brian Nelson
     14
     15		000001 				NONEIS	=	1		; force p$mul,p$div into KRTSUB.MAC
     16
     17						.macro	mul	src,reg		; single precision
     18						.ntype	$$	,reg		; save number of input register
     19						mov	src	,-(sp)		; pass multiplier to p$mul
     20						mov	reg	,-(sp)		; pass multiplicand too
     21						call	p$mul			; multiply, returns a 16-bit product
     22						.iif eq <$$-1>	mov	(sp)+	,r1	; ..if input register was r1
     23						.iif eq <$$-3>	mov	(sp)+	,r3	; ditto if r3
     24						.iif eq <$$-5>	mov	(sp)+	,r5	; ditto if r5
     25						.iif ne <<$$+1>&1> .error      <; bad dst reg for MUL macro>
     26						.endm	mul
     27
     28						.macro	div	src,reg		; /BBS/ made this double precision
     29						.ntype	$$	,reg		; # of register with dividend hi word
     30						mov	src	,-(sp)		; divisor
     31						.if eq $$			; hi word is in r0
     32						mov	r1	,-(sp)		; dividend low word
     33						mov	r0	,-(sp)		; dividend high word
     34						.endc
     35						.if eq $$-2			; hi word is in r2
     36						mov	r3	,-(sp)
     37						mov	r2	,-(sp)
     38						.endc
     39						.if eq $$-4			; hi word is in r4
     40						mov	r5	,-(sp)
     41						mov	r4	,-(sp)
     42						.endc
     43						call	p$div			; divide
     44						.if eq $$			; using r0..
     45						mov	(sp)+	,r1		; remainder
     46						mov	(sp)+	,r0		; this only returns a 16-bit quotient
     47						.endc
     48						.if eq $$-2			; using r2..
     49						mov	(sp)+	,r3
     50						mov	(sp)+	,r2
     51						.endc
     52						.if eq $$-4			; using r4..
     53						mov	(sp)+	,r5
     54						mov	(sp)+	,r4
     55						.endc
     56						.endm	div
     57
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 1-1
KRTNHD	EIS macros for a non-EIS CPU

     58						.macro	sob	reg,dst		; subtract one and branch if not zero
     59						dec	reg
     60						bne	dst
     61						.endm	sob
     62
     63						.macro	ash	amount,reg	; arithmetic shift
     64						.ntype	$$$0	,amount
     65						.iif ne <27-$$$0> .error       <; must be auto pc for ASH macro>
     66						$$type	= 1			; assume left shift
     67						$$size	= 0			; how many ASLs or ASRs to generate
     68						  .irpc	$a ,<amount>		; parse the first argument
     69						  $c	= ''$a			; get the character as a literal
     70						  .iif eq <$c - '-> $$type = -1	; if a minus sign then assume right
     71						  .iif eq <$c - '.> .error     <; only use octal in ASH macro please>
     72						  .iif eq <$c - '^> .error     <; only use octal in ASH macro please>
     73						  $c	= $c - '0		; check for a digit now
     74						    .if ge $c			; perhaps a digit
     75						      .if le $c-7		; got a digit
     76						      $$size = <$$size*10>+$c	; add into accumulator
     77						      .endc
     78						    .endc
     79						  .endr
     80						.rept	$$size
     81						.iif gt <$$type>  asl	reg
     82						.iif lt <$$type>  asr	reg
     83						.endr
     84						.endm
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 2
KRTNHD	EIS macros for a non-EIS CPU

      1						.title	KRTSTD	SET command list overlay
      2						.ident	"V03.63"
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	consolidate local data..
      7					;	add SET WILDCARDS
      8
      9					; /62/	27-Jul-93  Billy Youdelman  V03.62
     10					;
     11					;	move BREAK to SET CONSOLE, CREATE-SIZE and VOLUME to SET FILE
     12					;	move SETTLE-TIME to SET DIAL ..
     13
     14					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     15
     16					;	23-Oct-85  09:44:20  BDN  Creation, removed from KRTCOM
     17					;
     18					;	Copyright 1985 Change Software, Inc.
     19					;
     20					;	Call LOASET to get the overlay loaded and
     21					;	return the command list address in r0
     22
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 3
KRTNHD	EIS macros for a non-EIS CPU

      1
      2						.include "IN:KRTMAC.MAC"
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 4
KRTMAC	Various handy constants and macros

      1						.sbttl	KRTMAC	Various handy constants and macros
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	add support for SET ATTRIBUTES
      7					;	add flag to suspend logging to a disk file
      8					;	make $LN$MAX 132. bytes for EIS assembly
      9					;	pulled message macro, no longer used..
     10
     11					; /62/	27-Jul-93  Billy Youdelman  V03.62
     12					;
     13					;	move dispatch macro to KRTSER
     14					;	move erbfsiz here from KRTPAK
     15					;	condense logging (debug) modes
     16					;	increase efficiency of incm64 macro
     17					;	increase MAXLNG (long-packet size) to 1920.
     18					;	reduce MAXLNG to 600. for NONEIS assembly, so pgm loads under FB..
     19					;	ditto for ALSIZE (phone # buffer) and LN$CNT (SL # of lines saved)
     20
     21					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     22					;
     23					;	modified message macro to call .newline instead of saving CR/LF
     24					;	and null for each new line, knocking 1042. bytes off the size
     25					;	of this version..  also changed ".print" emulation to wrtall,
     26					;	for a similar savings in compiled program size.
     27					;
     28					;	dump raw I/O logging from log$al (SET DEB ALL) - too confusing
     29					;	also pulled log$rp out and made it a completely separate item..
     30					;
     31					;	added a couple upper case macros
     32
     33					;	include file for Kermit-11
     34					;
     35					;	Brian Nelson  01-Dec-83  13:56:12
     36
     37						.NLIST	BEX
     38						.LIST	MEB			; /62/
     39
     40		000001 				KRTINC	=	1		; for .include error checking
     41
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 5
KRTMAC	Various handy constants and macros

      1
      2	000000					.psect	$code	,ro,i,lcl,rel,con ; psect ordering..
      3	000000					.psect	$pdata	,ro,d,lcl,rel,con
      4
      5					;	various ascii chars
      6		000001 				SOH	=   1		; default packet start of header
      7		000007 				BELL	=   7		; beep
      8		000010 				BS	=  10		; backspace
      9		000011 				TAB	=  11		; tab
     10		000012 				LF	=  12		; line feed
     11		000014 				FF	=  14		; form feed
     12		000015 				CR	=  15		; carriage return
     13		000016 				CTRL$N	=  16		; ^N VT-100 line drawing on
     14		000017 				CTRL$O	=  17		; ^O VT-100 line drawing off
     15		000021 				XON	=  'Q&37	; ^Q
     16		000023 				XOFF	=  'S&37	; ^S
     17		000033 				ESC	=  33		; escape
     18		000040 				SPACE	=  40
     19		000054 				COMMA	=  54
     20		000056 				DOT	=  56		; /63/
     21		000073 				SCOLON	=  73		; /63/
     22		000176 				TILDE	= 176		; /63/
     23		000177 				DEL	= 177		; delete
     24
     25					;	system data locations
     26		000044 				JSW	= 44		; job status word
     27		000052 				ERRBYT	= 52		; emt error byte
     28		000053 				USERRB	= 53		; /62/ user error byte
     29		000001 					SUCCS$	=  1	; no error
     30		000002 					WARN$	=  2	; warning
     31		000004 					ERROR$	=  4	; error
     32		000010 					SEVER$	= 10	; sever error
     33		000020 					FATAL$	= 20	; fatal error
     34
     35					;	byte offsets into SINIT parameter vector
     36		000000 				P.SPSIZ	= 0		; set packet length
     37		000001 				P.TIME	= 1		; time-out
     38		000002 				P.NPAD	= 2		; number of pad chars
     39		000003 				P.PADC	= 3		; the pad character
     40		000004 				P.EOL	= 4		; eol char
     41		000005 				P.QCTL	= 5		; control char quoting
     42		000006 				P.QBIN	= 6		; 8-bit quote
     43		000007 				P.CHKT	= 7		; checksum type
     44		000010 				P.REPT	= 10		; repeated character prefix
     45		000011 				P.CAPAS	= 11		; capability bitmask
     46		000010 					CAPA.A	= 10	; attribute handling
     47		000002 					CAPA.L	= 2	; /42/ long packets
     48		000004 					CAPA.S	= 4	; /42/ sliding windows
     49		000012 				P.WINDS	= 12		; /43/ window size, # of packets
     50		000013 				P.MXL1	= 13		; /43/ high order of long packet size
     51		000014 				P.MXL2	= 14		; /43/ low order of long packet size
     52		000017 				P.VEND	= 17		; end of parameter vector
     53
     54					; /62/	bits in doattr (file attribute processing)
     55		000001 				AT.CDT	=: 1		; create date
     56		000002 				AT.INF	=: 2		; /63/ system specific info
     57		000004 				AT.LEN	=: 4		; length
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 5-1
KRTMAC	Various handy constants and macros

     58		000010 				AT.PRO	=: 10		; file protection
     59		000020 				AT.SYS	=: 20		; system ID
     60		000040 				AT.TYP	=: 40		; file type
     61		000100 				AT.XLE	=: 100		; exact length in bytes
     62		100000 				AT.ON	=: 100000	; /63/ do attribute processing
     63		000177 				AT.ALL	=: AT.CDT!AT.INF!AT.LEN!AT.PRO!AT.SYS!AT.TYP!AT.XLE
     64
     65					;	bits in trace (debug status word)
     66		000001 				LOG$PA	= 1		; log all packets
     67		000002 				LOG$CO	= 2		; /62/ CONNECT logging to disk
     68		000004 				LOG$RP	= 4		; /62/ rpack chars to TT
     69		000010 				LOG$IO	= 10		; /62/ everything received or sent
     70		000020 				LOG$DE	= 20		; /62/ debugging to TT
     71		040000 				LOG$ON	= 40000		; /63/ set to write to disk, clear to suspend
     72		100000 				LOG$OP	= 100000	; logfile is open
     73		000003 				LOG$AL	= LOG$PA!LOG$CO	; /62/ ALL
     74
     75					;	parity options
     76		000000 				PAR$NO	=: 0		; none
     77		000001 				PAR$OD	=: 1		; odd
     78		000002 				PAR$EV	=: 2		; even
     79		000003 				PAR$MA	=: 3		; mark
     80		000004 				PAR$SP	=: 4		; space
     81
     82					;	file types
     83		177777 				TERMINAL=: -1		; file to term ala xreply, not to disk
     84		000000 				TEXT	=:  0		; normal ascii text files
     85		000001 				BINARY	=:  1		; image mode
     86		000002 				DECNAT	=:  2		; /52/ 8-bit text files
     87
     88					;	terminal types
     89		000000 				NOSCOPE	= 0		; /BBS/ hard copy terminal
     90		000001 				TTY	= 1		; a dumb tube terminal
     91		000002 				VT100	= 2		; itself
     92		000003 				VT200	= 3		; ditto..
     93
     94					;	supported CVT$$ cvt_bit_pattern bits
     95		000004 				C.CRLF	= 4		; discard CR LF FF ESC
     96		000010 				C.LSPA	= 10		; discard leading spaces and tabs
     97		000020 				C.SSPA	= 20		; reduce spaces and tabs to a single space
     98		000040 				C.LCUC	= 40		; lower case to upper case
     99		000200 				C.TSPA	= 200		; discard trailing spaces and tabs
    100
    101		000034 				CON$ESC	=  '\-100	; default CONNECT escape char
    102		000170 				ERBFSIZ	=  120.		; /62/ error msg text buff size
    103		000136 				MAXPAK	=:  94.		; /63/ max_packet_length - max_checksum_length
    104
    105						.if df	NONEIS		; /62/ using NONEIS for convenience..
    106		001000 				ALSIZE	=   1000	; /63/ bufsiz for SET DIAL/PHO NUM
    107		000003 				LN$CNT	=      3.	; /62/ save/recall 3. commands
    108		000120 				LN$MAX	=     80.	; /63/ max command line length
    109		001130 				MAXLNG	=    600.	; /63/ so image is small enuff to run
    110						.iff
    111						ALSIZE	=   2000	; /62/ bufsiz for SET DIAL/PHO NUM
    112						LN$CNT	=     10.	; /63/ save/recall 10. commands
    113						LN$MAX	=    132.	; /63/ max command line length
    114						MAXLNG	=   1920.	; /63/ use max long-packet buff size
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 5-2
KRTMAC	Various handy constants and macros

    115						.endc
    116		001144 				$ALLSIZ	= <MAXLNG+14>&177776 ; /62/ make it this for safety
    117
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 6
KRTMAC	Various handy constants and macros

      1
      2						.sbttl	Utility macros
      3
      4						.macro	.br to		; /63/ added
      5						.if df	to
      6						.if ne	to-.
      7						.error	<; not at location to;>
      8						.endc
      9						.endc
     10						.endm	.br
     11
     12						.macro	.chksp	arg
     13						.ntype	$$5	,arg
     14						.iif eq <<$$5&7>-6> .error arg <; Illegal use of SP (r6) in call>
     15						.endm	.chksp
     16
     17						.macro	calls	name	,arglst
     18					;	subroutine call with arguments passed in an area pointed to by r5
     19					;	(as with F4 and BP2).  all args are pushed onto the stack in the
     20					;	order specified.  r5 points to the sp before the call and is saved
     21					;	and restored.
     22						$$ = 0				; init # of args count
     23						  .irp x ,<arglst>		; count up # of args passed
     24						  $$ = $$+1			; one at a time
     25						  .endr				; got it
     26						.if eq $$			; no args present?
     27						jsr	pc	,name		; if so, substitute a simple call
     28						.iff				; at least one arg in <arglst>
     29						mov	r5	,-(sp)		; /63/ will be used to point to arg(s)
     30						  .if eq $$-1			; is it one or more than one arg?
     31						  .chksp	arglst		; one arg, check for legal SP modes
     32						  mov	arglst	,-(sp)		; doing it thusly generates less code
     33						  mov	sp	,r5		; set pointer to argument list
     34						  jsr	pc	,name		; call the subroutine
     35						  tst	(sp)+			; pop parameter list from stack
     36						  mov	(sp)+	,r5		; /63/ restore r5
     37						  .iff				; arg_count > 1
     38						  $$2 = $$			; extract the args in
     39						    .rept	$$		; reverse order so that
     40						    $$1 = 0			; we might save a little
     41						      .irp x ,<arglst>		; core (four words)
     42						      $$1 = $$1+1		; scan the arg list until we come to
     43						        .if eq $$2-$$1		; the last one before one we just did
     44						        .chksp	x		; check for SP addressing mode
     45						        mov	x	,-(sp)	; push it
     46						        .mexit			; and exit the .irp
     47						        .endc
     48						      .endr
     49						    $$2 = $$2-1			; backwards to previous arg
     50						    .endr
     51						  mov	sp	,r5		; set up the argument list pointer
     52						  jsr	pc	,name		; and go to the routine
     53						  .iif eq <$$-2>  cmp	(sp)+	,(sp)+	; two args
     54						  .iif gt <$$-2>  add	#$$*2	,sp	; gen "add 2*argnum ,sp"
     55						  mov	(sp)+	,r5		; /63/ restore r5
     56						  .endc
     57						.endc
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 6-1
Utility macros

     58						.endm	calls
     59
     60						.macro	ctl	src ,dst
     61						clr	-(sp)
     62						bisb	src	,@sp
     63						call	l$xor
     64						movb	(sp)+	,dst
     65						.endm	ctl
     66
     67						.macro	copyz	from ,to ,maxlen
     68						.if  b	<maxlen>
     69						clr	-(sp)
     70						.iff
     71						mov	maxlen	,-(sp)
     72						.endc
     73						mov	from	,-(sp)
     74						mov	to	,-(sp)
     75						call	copyz$
     76						.endm	copyz
     77
     78						.macro	deccvt	val ,buf ,width
     79						mov	r5	,-(sp)
     80						.if  b	<width>
     81						clr	-(sp)
     82						.iff
     83						mov	width	,-(sp)
     84						.endc
     85						mov	val	,-(sp)
     86						mov	buf	,-(sp)
     87						mov	sp	,r5
     88						call	l$cvtnum
     89						add	#6	,sp
     90						mov	(sp)+	,r5
     91						.endm	deccvt
     92
     93						.macro	decout	val
     94						mov	r5	,-(sp)
     95						mov	val	,-(sp)		; /62/ l$wrdec pops this buffer
     96						mov	sp	,r5
     97						call	l$wrdec
     98						mov	(sp)+	,r5
     99						.endm	decout
    100
    101						.macro	direrr	val
    102						mov	val	,-(sp)
    103						call	direr$
    104						.endm	direrr
    105
    106						.macro	incm64	val
    107						inc	val
    108						bic	#^c<77>	,val		; /62/ faster
    109						.endm	incm64
    110
    111						.macro	indexm	reg		; check for auto increment/decrement
    112						.ntype	$$$0	,reg		; modes for macros that can't have..
    113						.if  ne	$$$0-27			; always allow pc autoincrement
    114						$$$0 =	<$$$0&177770>/10	; ..these modes in their arg list
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 6-2
Utility macros

    115						.ift				; get the mode into 0..7
    116						  .if  ge $$$0-2		; if mode >=2 and mode <=5 then error
    117						  .iif ge <5-$$$0> .error      <; Can't use auto inc/dec mode here>
    118						  .endc
    119						.endc
    120						.endm	indexm
    121
    122						.macro	ixor	reg ,dst
    123					;	get around the mode restrictions for the hardware XOR instruction
    124					;	and fix for RT-11 systems that don't have the EIS chip option
    125						.chksp	reg			; can't allow sp args
    126						.chksp	dst			; in either register
    127						indexm	reg			; check for allowed
    128						indexm	dst			; addressing mode
    129						mov	reg	,-(sp)		; it's much simpler to do this
    130						bic	dst	,@sp		; for all RT-11 systems rather
    131						bic	reg	,dst		; than to be selective
    132						bis	(sp)+	,dst		; done
    133						.endm	ixor
    134
    135						.macro	.newline		; print CR/LF on TT
    136						call	l$pcrlf
    137						.endm	.newline
    138
    139						.macro	octout	val
    140						calls	l$wroct	,<val>
    141						.endm	octout
    142
    143						.macro	prsbuf	dst
    144						mov	dst	,r0
    145						call	prsarg
    146						.endm	prsbuf
    147
    148						.macro	rpack	len.a ,pakn.a ,msg.a ,max.len	; /62/
    149						sub	#10	,sp
    150						mov	sp	,r1
    151						calls	rpack$	,<msg.a,r1,max.len>
    152						mov	(r1)+	,len.a
    153						mov	(r1)+	,pakn.a
    154						mov	@r1	,r1
    155						add	#10	,sp
    156						.endm	rpack
    157
    158						.macro	save	list
    159						.if  b	<list>
    160						 save	<r0,r1,r2,r3,r4,r5>
    161						.iff
    162						.irp	x ,<list>
    163						 mov	x	,-(sp)
    164						.endr
    165						.endc
    166						.endm	save
    167
    168						.macro	scan	ch ,str
    169						mov	str	,-(sp)
    170						clr	-(sp)
    171						bisb	ch	,@sp
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 6-3
Utility macros

    172						call	scanch
    173						.endm	scan
    174
    175						.macro	setpar	src ,dst
    176						movb	src	,-(sp)
    177						call	dopari
    178						movb	(sp)+	,dst
    179						.endm	setpar
    180
    181						.macro	spack	type ,pnum ,len ,msg
    182						.if  b	<len>
    183						.iif nb	<msg>	.error	<; bad call to SPACK macro>
    184						calls	spack$	,<type,pnum,#0,#null>
    185						.iff
    186						calls	spack$	,<type,pnum,len,msg>
    187						.endc
    188						.endm	spack
    189
    190						.macro	strcat	dst ,src
    191						mov	src	,-(sp)
    192						mov	dst	,-(sp)
    193						jsr	pc	,strcat
    194						.endm	strcat
    195
    196						.macro	strcpy	dst ,src
    197						mov	src	,-(sp)
    198						mov	dst	,-(sp)
    199						jsr	pc	,strcpy
    200						.endm	strcpy
    201
    202						.macro	strlen	string
    203						mov	string	,r0
    204						call	l$len
    205						.endm	strlen
    206
    207						.macro	textsrc	text
    208						.if  b	<text>
    209						clr	getcroutine		; /62/ reset to file I/O
    210						clr	tgetaddr
    211						.iff
    212						mov	#tgetcr0,getcroutine
    213						mov	text	,tgetaddr
    214						.endc
    215						.endm	textsrc
    216
    217						.macro	tochar	src ,dst
    218						clr	-(sp)
    219						bisb	src	,@sp
    220						add	#40	,@sp
    221						movb	(sp)+	,dst
    222						.endm	tochar
    223
    224						.macro	unchar	src ,dst
    225						clr	-(sp)
    226						bisb	src	,@sp
    227						sub	#40	,@sp
    228						movb	(sp)+	,dst
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 6-4
Utility macros

    229						.endm	unchar
    230
    231						.macro	unsave	list
    232						.if b <list>
    233						unsave	<r5,r4,r3,r2,r1,r0>
    234						.iff
    235						.irp	x ,<list>
    236						 mov	(sp)+	,x
    237						.endr
    238						.endc
    239						.endm	unsave
    240
    241						.macro	upcase	s		; /BBS/ added ..
    242						mov	s	,r0
    243						call	upcase			; /BBS/ upcase until null terminator
    244						.endm	upcase
    245
    246						.macro	upone	s		; /BBS/ added ..
    247						mov	s	,r0
    248						call	upone			; /BBS/ upcase only to next delimiter
    249						.endm	upone
    250
    251						.macro	wrtall	arg		; IO.WAL for an .asciz string
    252						mov	arg	,-(sp)		; pass the address
    253						call	wrtall			; do it
    254						.endm	wrtall
    255
    256						.macro	xor	reg ,dst
    257						ixor	reg	,dst
    258						.endm	xor
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 7
Utility macros

      1						.iif ndf  KRTINC  .error	<; .include for IN:KRTMAC.MAC failed>
      2						.include "IN:KRTCDF.MAC"
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 8
KRTCDF	Define command macro

      1						.sbttl	KRTCDF	Define command macro
      2					;	.ident	"V03.63"		; this is an .include file
      3
      4					; /63/	27-Sep-97  Billy Youdelman  V03.63
      5					;
      6					;	modify optional prompt arg to use address of prompt string
      7					;	allows longer strings to be used and eliminates redundancy
      8					;	drop $CMGLOBAL
      9
     10					; /62/	27-Jul-93  Billy Youdelman  V03.62
     11					;
     12					;	$$trip hack to avoid "ndf/df" tests blowing up .LST output
     13
     14					; /BBS/	 1-Dec-91  Billy Youdelman  V03.61
     15					;
     16					;	dump unused argtyp
     17
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 9
KRTCDF	Define command macro

      1
      2					;	usage example:
      3					;
      4					;	command	cmdlst	SEND ,3 ,c$send ,optional_prompt_addr
      5					;
      6					;	Would define the SEND command with a minimum length of
      7					;	three characters, and dispatch it to c$send.  Use of a
      8					;	prompt will cause  same  to appear when the command is
      9					;	given without argument(s).  cmdlst is the listhead for
     10					;	all commands and is  only  used once, but must be used
     11					;	in all entries to keep other arguments in place.
     12
     13
     14		000001 				KRTCDF	=  1			; used to detect an .include error
     15		000004 				$LISTL	== 4			; number of args stuffed in list here
     16		000000 				$$TRIP	=  0			; /62/ init trip counter
     17
     18						.macro	command	list ,name ,min ,address ,arg
     19						.list me
     20						.save
     21						.nlist me
     22						.if b <name>			; command name supplied this time?
     23						.list me
     24						.psect	cmddsp	,ro,d,lcl,rel,con ; no, at end of list
     25						.nlist me
     26						.word	0			; /62/ mark it with a null
     27						.list me			; /63/
     28						.psect	cmdtxt	,ro,d,lcl,rel,con ; /63/ save a few bytes by only
     29						.even				; /63/ doing this at the end of a list
     30						.nlist me			; /63/
     31						$$trip	= 0			; /62/ reset trip counter for next cmd
     32						.iff	; b <name>		; ya, process args into command data
     33						.list me
     34						.psect	cmdtxt	,ro,d,lcl,rel,con
     35						.nlist me
     36						$$name	= .
     37						.asciz	#name#			; store the command name
     38						.psect	cmddsp	,ro,d,lcl,rel,con
     39						.nlist me
     40						  .if eq $$trip			; /62/ if first pass label listhead
     41					'list:					; global flag was not set
     42						  $$trip = 1			; /62/ not first time through anymore
     43						  .endc				; no
     44						.word	$$name			; store address of command name text
     45						.word	min			; min number of chars to match
     46						.word	address			; the command routine's address
     47						  .if b <arg>			; /63/ optional_prompt address given?
     48						  .word	0			; /63/ no, say so with a null here
     49						  .iff
     50						  .word	arg			; /63/ ya, stuff in its location
     51						  .endc
     52						.endc	; b <name>
     53						.list me
     54						.restore
     55						.nlist me
     56						.endm
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 10
KRTCDF	Define command macro

      1						.iif ndf  KRTCDF  .error	<; .include for IN:KRTCDF.MAC failed>
      2
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 11
KRTCDF	Define command macro

      1
      2	000000					.psect	$pdata
      3						.sbttl	Local data		; /63/ consolidate data here..
      4
      5	000000	   117 	   156 	   054 	std.01:	.asciz	"On, Off? "
      6	000012	   126 	   141 	   154 	std.02:	.asciz	"Value: "
      7	000022	   106 	   151 	   154 	std.03:	.asciz	"File type: "
      8	000036	   061 	   054 	   040 	std.04:	.asciz	"1, 2 or 3? "
      9	000052	   114 	   151 	   156 	std.05:	.asciz	"Line, Ports or Units? "
     10	000101	   117 	   160 	   164 	std.06:	.asciz	"Option: "
     11	000112	   125 	   156 	   160 	std.07:	.asciz	"Unprefix or Prefix? "
     12	000137	   115 	   157 	   144 	std.08:	.asciz	"Mode: "
     13	000146	   104 	   151 	   162 	std.09:	.asciz	"Directory: "
     14	000162	   123 	   145 	   143 	std.10:	.asciz	"Seconds: "
     15	000174	   110 	   141 	   154 	std.11:	.asciz	"Half or Full? "
     16	000213	   117 	   143 	   164 	std.12:	.asciz	"Octal 1-36: "
     17	000230	   105 	   170 	   151 	std.13:	.asciz	"Exit, Noexit? "
     18	000247	   101 	   123 	   103 	std.14:	.asciz	"ASCII, Auto or Binary? "
     19	000277	   122 	   124 	   123 	std.15:	.asciz	"RTS/CTS or XOFF? "
     20	000321	   124 	   171 	   160 	std.16:	.asciz	"Type? "
     21	000330	   113 	   145 	   145 	std.17:	.asciz	"Keep or Discard? "
     22	000352	   104 	   145 	   166 	std.18:	.asciz	"Device name: "
     23	000370	   115 	   157 	   144 	std.19:	.asciz	"Modem name: "
     24	000405	   117 	   144 	   144 	std.20:	.asciz	"Odd, Even, Mark, Space or None? "
     25	000446	   116 	   145 	   167 	std.21:	.asciz	"New prompt: "
     26	000463	   111 	   156 	   151 	std.22:	.asciz	"Initial or Packet? "
     27	000507	   122 	   141 	   156 	std.23:	.asciz	"Random-number seed: "
     28	000534	   117 	   156 	   040 	std.24:	.asciz	"On or Off, KED or NOKED? "
     29	000566	   111 	   156 	   164 	std.25:	.asciz	"Interval: "
     30	000601	   114 	   157 	   143 	std.26:	.asciz	"Local or Remote? "
     31						.even
     32
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12
Local data		; /63/ consolidate data here..

      1
      2	000000					.psect	$code
      3						.sbttl	Define the SET commands
      4
      5	000000	012700 	000000'		loaset::mov	#setcmd	,r0		; calling this also loads this overlay
      6	000004	000207 				return
      7
      8	000006					command	setcmd	,ATTRIBUTES	,1	,set$at	,std.01
						.list me
						.save
						.list me
	000000					.psect	cmdtxt	,ro,d,lcl,rel,con
	000000	   101 	   124 	   124 		.asciz	#ATTRIBUTES#			; store the command ATTRIBUTES
	000000	000000'				.word	$$name			; store set$at of command ATTRIBUTES text
	000002	000001 				.word	1			; 1 number of chars to match
	000004	000000G				.word	set$at			; the command routine's set$at
	000006	000000'				  .word	std.01			; /63/ ya, stuff in its location
						.list me
	000006					.restore
      9	000006					command setcmd	,BAUD		,2	,set$sp	,std.02
						.list me
						.save
						.list me
	000013					.psect	cmdtxt	,ro,d,lcl,rel,con
	000013	   102 	   101 	   125 		.asciz	#BAUD#			; store the command BAUD
	000010	000013'				.word	$$name			; store set$sp of command BAUD text
	000012	000002 				.word	2			; 2 number of chars to match
	000014	000000G				.word	set$sp			; the command routine's set$sp
	000016	000012'				  .word	std.02			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     10	000006					command	setcmd	,BINARY-TYPE	,2	,set$bi	,std.03
						.list me
						.save
						.list me
	000020					.psect	cmdtxt	,ro,d,lcl,rel,con
	000020	   102 	   111 	   116 		.asciz	#BINARY-TYPE#			; store the command BINARY-TYPE
	000020	000020'				.word	$$name			; store set$bi of command BINARY-TYPE text
	000022	000002 				.word	2			; 2 number of chars to match
	000024	000000G				.word	set$bi			; the command routine's set$bi
	000026	000022'				  .word	std.03			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     11	000006					command	setcmd	,BLOCK-CHECK-TYPE,2	,set$bl	,std.04
						.list me
						.save
						.list me
	000034					.psect	cmdtxt	,ro,d,lcl,rel,con
	000034	   102 	   114 	   117 		.asciz	#BLOCK-CHECK-TYPE#			; store the command BLOCK-CHECK-TYPE
	000030	000034'				.word	$$name			; store set$bl of command BLOCK-CHECK-TYPE text
	000032	000002 				.word	2			; 2 number of chars to match
	000034	000000G				.word	set$bl			; the command routine's set$bl
	000036	000036'				  .word	std.04			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     12	000006					command setcmd	,CL:		,2	,set$cl	,std.05
						.list me
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-1
Define the SET commands

						.save
						.list me
	000055					.psect	cmdtxt	,ro,d,lcl,rel,con
	000055	   103 	   114 	   072 		.asciz	#CL:#			; store the command CL:
	000040	000055'				.word	$$name			; store set$cl of command CL: text
	000042	000002 				.word	2			; 2 number of chars to match
	000044	000000G				.word	set$cl			; the command routine's set$cl
	000046	000052'				  .word	std.05			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     13	000006					command setcmd	,CONSOLE	,2	,set$co	,std.06
						.list me
						.save
						.list me
	000061					.psect	cmdtxt	,ro,d,lcl,rel,con
	000061	   103 	   117 	   116 		.asciz	#CONSOLE#			; store the command CONSOLE
	000050	000061'				.word	$$name			; store set$co of command CONSOLE text
	000052	000002 				.word	2			; 2 number of chars to match
	000054	000000G				.word	set$co			; the command routine's set$co
	000056	000101'				  .word	std.06			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     14	000006					command setcmd	,CONTROL-CHARACTER,4	,set$ct	,std.07
						.list me
						.save
						.list me
	000071					.psect	cmdtxt	,ro,d,lcl,rel,con
	000071	   103 	   117 	   116 		.asciz	#CONTROL-CHARACTER#			; store the command CONTROL-CHARACTER
	000060	000071'				.word	$$name			; store set$ct of command CONTROL-CHARACTER text
	000062	000004 				.word	4			; 4 number of chars to match
	000064	000000G				.word	set$ct			; the command routine's set$ct
	000066	000112'				  .word	std.07			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     15	000006					command setcmd	,DEBUG		,3	,set$de	,std.08
						.list me
						.save
						.list me
	000113					.psect	cmdtxt	,ro,d,lcl,rel,con
	000113	   104 	   105 	   102 		.asciz	#DEBUG#			; store the command DEBUG
	000070	000113'				.word	$$name			; store set$de of command DEBUG text
	000072	000003 				.word	3			; 3 number of chars to match
	000074	000000G				.word	set$de			; the command routine's set$de
	000076	000137'				  .word	std.08			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     16	000006					command setcmd	,DEFAULT	,3	,c$cwd	,std.09
						.list me
						.save
						.list me
	000121					.psect	cmdtxt	,ro,d,lcl,rel,con
	000121	   104 	   105 	   106 		.asciz	#DEFAULT#			; store the command DEFAULT
	000100	000121'				.word	$$name			; store c$cwd of command DEFAULT text
	000102	000003 				.word	3			; 3 number of chars to match
	000104	000000G				.word	c$cwd			; the command routine's c$cwd
	000106	000146'				  .word	std.09			; /63/ ya, stuff in its location
						.list me
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-2
Define the SET commands

	000006					.restore
     17	000006					command	setcmd	,DELAY		,3	,set$dl	,std.10
						.list me
						.save
						.list me
	000131					.psect	cmdtxt	,ro,d,lcl,rel,con
	000131	   104 	   105 	   114 		.asciz	#DELAY#			; store the command DELAY
	000110	000131'				.word	$$name			; store set$dl of command DELAY text
	000112	000003 				.word	3			; 3 number of chars to match
	000114	000000G				.word	set$dl			; the command routine's set$dl
	000116	000162'				  .word	std.10			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     18	000006					command setcmd	,DIAL		,2	,set$di	,std.06
						.list me
						.save
						.list me
	000137					.psect	cmdtxt	,ro,d,lcl,rel,con
	000137	   104 	   111 	   101 		.asciz	#DIAL#			; store the command DIAL
	000120	000137'				.word	$$name			; store set$di of command DIAL text
	000122	000002 				.word	2			; 2 number of chars to match
	000124	000000G				.word	set$di			; the command routine's set$di
	000126	000101'				  .word	std.06			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     19	000006					command setcmd	,DTR		,2	,set$dt
						.list me
						.save
						.list me
	000144					.psect	cmdtxt	,ro,d,lcl,rel,con
	000144	   104 	   124 	   122 		.asciz	#DTR#			; store the command DTR
	000130	000144'				.word	$$name			; store set$dt of command DTR text
	000132	000002 				.word	2			; 2 number of chars to match
	000134	000000G				.word	set$dt			; the command routine's set$dt
	000136	000000 				  .word	0			; /63/ no, say so with a null here
						.list me
	000006					.restore
     20	000006					command setcmd	,DUPLEX		,2	,set$du	,std.11
						.list me
						.save
						.list me
	000150					.psect	cmdtxt	,ro,d,lcl,rel,con
	000150	   104 	   125 	   120 		.asciz	#DUPLEX#			; store the command DUPLEX
	000140	000150'				.word	$$name			; store set$du of command DUPLEX text
	000142	000002 				.word	2			; 2 number of chars to match
	000144	000000G				.word	set$du			; the command routine's set$du
	000146	000174'				  .word	std.11			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     21	000006					command	setcmd	,END-OF-LINE	,2	,set$eo	,std.12
						.list me
						.save
						.list me
	000157					.psect	cmdtxt	,ro,d,lcl,rel,con
	000157	   105 	   116 	   104 		.asciz	#END-OF-LINE#			; store the command END-OF-LINE
	000150	000157'				.word	$$name			; store set$eo of command END-OF-LINE text
	000152	000002 				.word	2			; 2 number of chars to match
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-3
Define the SET commands

	000154	000000G				.word	set$eo			; the command routine's set$eo
	000156	000213'				  .word	std.12			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     22	000006					command setcmd	,EOF		,2	,set$ef	,std.13
						.list me
						.save
						.list me
	000173					.psect	cmdtxt	,ro,d,lcl,rel,con
	000173	   105 	   117 	   106 		.asciz	#EOF#			; store the command EOF
	000160	000173'				.word	$$name			; store set$ef of command EOF text
	000162	000002 				.word	2			; 2 number of chars to match
	000164	000000G				.word	set$ef			; the command routine's set$ef
	000166	000230'				  .word	std.13			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     23	000006					command setcmd	,ESCAPE		,2	,set$es	,std.12
						.list me
						.save
						.list me
	000177					.psect	cmdtxt	,ro,d,lcl,rel,con
	000177	   105 	   123 	   103 		.asciz	#ESCAPE#			; store the command ESCAPE
	000170	000177'				.word	$$name			; store set$es of command ESCAPE text
	000172	000002 				.word	2			; 2 number of chars to match
	000174	000000G				.word	set$es			; the command routine's set$es
	000176	000213'				  .word	std.12			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     24	000006					command	setcmd	,FILE-TYPE	,2	,set$fi	,std.14
						.list me
						.save
						.list me
	000206					.psect	cmdtxt	,ro,d,lcl,rel,con
	000206	   106 	   111 	   114 		.asciz	#FILE-TYPE#			; store the command FILE-TYPE
	000200	000206'				.word	$$name			; store set$fi of command FILE-TYPE text
	000202	000002 				.word	2			; 2 number of chars to match
	000204	000000G				.word	set$fi			; the command routine's set$fi
	000206	000247'				  .word	std.14			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     25	000006					command setcmd	,FLOW-CONTROL	,2	,set$km	,std.15
						.list me
						.save
						.list me
	000220					.psect	cmdtxt	,ro,d,lcl,rel,con
	000220	   106 	   114 	   117 		.asciz	#FLOW-CONTROL#			; store the command FLOW-CONTROL
	000210	000220'				.word	$$name			; store set$km of command FLOW-CONTROL text
	000212	000002 				.word	2			; 2 number of chars to match
	000214	000000G				.word	set$km			; the command routine's set$km
	000216	000277'				  .word	std.15			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     26	000006					command setcmd	,HANDSHAKE	,2	,set$ha	,std.16
						.list me
						.save
						.list me
	000235					.psect	cmdtxt	,ro,d,lcl,rel,con
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-4
Define the SET commands

	000235	   110 	   101 	   116 		.asciz	#HANDSHAKE#			; store the command HANDSHAKE
	000220	000235'				.word	$$name			; store set$ha of command HANDSHAKE text
	000222	000002 				.word	2			; 2 number of chars to match
	000224	000000G				.word	set$ha			; the command routine's set$ha
	000226	000321'				  .word	std.16			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     27	000006					command setcmd	,HOME		,2	,set$ho	,std.09
						.list me
						.save
						.list me
	000247					.psect	cmdtxt	,ro,d,lcl,rel,con
	000247	   110 	   117 	   115 		.asciz	#HOME#			; store the command HOME
	000230	000247'				.word	$$name			; store set$ho of command HOME text
	000232	000002 				.word	2			; 2 number of chars to match
	000234	000000G				.word	set$ho			; the command routine's set$ho
	000236	000146'				  .word	std.09			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     28	000006					command setcmd	,INCOMPLETE-FILE-DISPOSITION ,1	,set$in	,std.17
						.list me
						.save
						.list me
	000254					.psect	cmdtxt	,ro,d,lcl,rel,con
	000254	   111 	   116 	   103 		.asciz	#INCOMPLETE-FILE-DISPOSITION#			; store the command INCOMPLETE-FILE-DISPOSITION
	000240	000254'				.word	$$name			; store set$in of command INCOMPLETE-FILE-DISPOSITION text
	000242	000001 				.word	1			; 1 number of chars to match
	000244	000000G				.word	set$in			; the command routine's set$in
	000246	000330'				  .word	std.17			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     29	000006					command setcmd	,LD:		,2	,set$ld	,std.06
						.list me
						.save
						.list me
	000310					.psect	cmdtxt	,ro,d,lcl,rel,con
	000310	   114 	   104 	   072 		.asciz	#LD:#			; store the command LD:
	000250	000310'				.word	$$name			; store set$ld of command LD: text
	000252	000002 				.word	2			; 2 number of chars to match
	000254	000000G				.word	set$ld			; the command routine's set$ld
	000256	000101'				  .word	std.06			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     30	000006					command setcmd	,LINE		,2	,set$li	,std.18
						.list me
						.save
						.list me
	000314					.psect	cmdtxt	,ro,d,lcl,rel,con
	000314	   114 	   111 	   116 		.asciz	#LINE#			; store the command LINE
	000260	000314'				.word	$$name			; store set$li of command LINE text
	000262	000002 				.word	2			; 2 number of chars to match
	000264	000000G				.word	set$li			; the command routine's set$li
	000266	000352'				  .word	std.18			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     31	000006					command setcmd	,LOCAL-ECHO	,3	,set$lc	,std.01
						.list me
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-5
Define the SET commands

						.save
						.list me
	000321					.psect	cmdtxt	,ro,d,lcl,rel,con
	000321	   114 	   117 	   103 		.asciz	#LOCAL-ECHO#			; store the command LOCAL-ECHO
	000270	000321'				.word	$$name			; store set$lc of command LOCAL-ECHO text
	000272	000003 				.word	3			; 3 number of chars to match
	000274	000000G				.word	set$lc			; the command routine's set$lc
	000276	000000'				  .word	std.01			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     32	000006					command setcmd	,LOGFILE	,3	,set$lo
						.list me
						.save
						.list me
	000334					.psect	cmdtxt	,ro,d,lcl,rel,con
	000334	   114 	   117 	   107 		.asciz	#LOGFILE#			; store the command LOGFILE
	000300	000334'				.word	$$name			; store set$lo of command LOGFILE text
	000302	000003 				.word	3			; 3 number of chars to match
	000304	000000G				.word	set$lo			; the command routine's set$lo
	000306	000000 				  .word	0			; /63/ no, say so with a null here
						.list me
	000006					.restore
     33	000006					command setcmd	,LONG-PACKETS	,3	,set$lp	,std.01
						.list me
						.save
						.list me
	000344					.psect	cmdtxt	,ro,d,lcl,rel,con
	000344	   114 	   117 	   116 		.asciz	#LONG-PACKETS#			; store the command LONG-PACKETS
	000310	000344'				.word	$$name			; store set$lp of command LONG-PACKETS text
	000312	000003 				.word	3			; 3 number of chars to match
	000314	000000G				.word	set$lp			; the command routine's set$lp
	000316	000000'				  .word	std.01			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     34	000006					command setcmd	,MODEM-TYPE	,1	,set$mo	,std.19
						.list me
						.save
						.list me
	000361					.psect	cmdtxt	,ro,d,lcl,rel,con
	000361	   115 	   117 	   104 		.asciz	#MODEM-TYPE#			; store the command MODEM-TYPE
	000320	000361'				.word	$$name			; store set$mo of command MODEM-TYPE text
	000322	000001 				.word	1			; 1 number of chars to match
	000324	000000G				.word	set$mo			; the command routine's set$mo
	000326	000370'				  .word	std.19			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     35	000006					command	setcmd	,NOATTRIBUTES	,3	,st$nat
						.list me
						.save
						.list me
	000374					.psect	cmdtxt	,ro,d,lcl,rel,con
	000374	   116 	   117 	   101 		.asciz	#NOATTRIBUTES#			; store the command NOATTRIBUTES
	000330	000374'				.word	$$name			; store st$nat of command NOATTRIBUTES text
	000332	000003 				.word	3			; 3 number of chars to match
	000334	000000G				.word	st$nat			; the command routine's st$nat
	000336	000000 				  .word	0			; /63/ no, say so with a null here
						.list me
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-6
Define the SET commands

	000006					.restore
     36	000006					command setcmd	,NODEBUG	,3	,sd$off
						.list me
						.save
						.list me
	000411					.psect	cmdtxt	,ro,d,lcl,rel,con
	000411	   116 	   117 	   104 		.asciz	#NODEBUG#			; store the command NODEBUG
	000340	000411'				.word	$$name			; store sd$off of command NODEBUG text
	000342	000003 				.word	3			; 3 number of chars to match
	000344	000000G				.word	sd$off			; the command routine's sd$off
	000346	000000 				  .word	0			; /63/ no, say so with a null here
						.list me
	000006					.restore
     37	000006					command	setcmd	,NOLONG-PACKETS	,3	,st$nlp
						.list me
						.save
						.list me
	000421					.psect	cmdtxt	,ro,d,lcl,rel,con
	000421	   116 	   117 	   114 		.asciz	#NOLONG-PACKETS#			; store the command NOLONG-PACKETS
	000350	000421'				.word	$$name			; store st$nlp of command NOLONG-PACKETS text
	000352	000003 				.word	3			; 3 number of chars to match
	000354	000000G				.word	st$nlp			; the command routine's st$nlp
	000356	000000 				  .word	0			; /63/ no, say so with a null here
						.list me
	000006					.restore
     38	000006					command setcmd	,NOREPEAT-QUOTING,3	,rep$of
						.list me
						.save
						.list me
	000440					.psect	cmdtxt	,ro,d,lcl,rel,con
	000440	   116 	   117 	   122 		.asciz	#NOREPEAT-QUOTING#			; store the command NOREPEAT-QUOTING
	000360	000440'				.word	$$name			; store rep$of of command NOREPEAT-QUOTING text
	000362	000003 				.word	3			; 3 number of chars to match
	000364	000000G				.word	rep$of			; the command routine's rep$of
	000366	000000 				  .word	0			; /63/ no, say so with a null here
						.list me
	000006					.restore
     39	000006					command setcmd	,NOUPDATE	,3	,set$nu
						.list me
						.save
						.list me
	000461					.psect	cmdtxt	,ro,d,lcl,rel,con
	000461	   116 	   117 	   125 		.asciz	#NOUPDATE#			; store the command NOUPDATE
	000370	000461'				.word	$$name			; store set$nu of command NOUPDATE text
	000372	000003 				.word	3			; 3 number of chars to match
	000374	000000G				.word	set$nu			; the command routine's set$nu
	000376	000000 				  .word	0			; /63/ no, say so with a null here
						.list me
	000006					.restore
     40	000006					command	setcmd	,PARITY		,3	,set$pa	,std.20
						.list me
						.save
						.list me
	000472					.psect	cmdtxt	,ro,d,lcl,rel,con
	000472	   120 	   101 	   122 		.asciz	#PARITY#			; store the command PARITY
	000400	000472'				.word	$$name			; store set$pa of command PARITY text
	000402	000003 				.word	3			; 3 number of chars to match
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-7
Define the SET commands

	000404	000000G				.word	set$pa			; the command routine's set$pa
	000406	000405'				  .word	std.20			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     41	000006					command	setcmd	,PAUSE		,3	,set$ps	,std.10
						.list me
						.save
						.list me
	000501					.psect	cmdtxt	,ro,d,lcl,rel,con
	000501	   120 	   101 	   125 		.asciz	#PAUSE#			; store the command PAUSE
	000410	000501'				.word	$$name			; store set$ps of command PAUSE text
	000412	000003 				.word	3			; 3 number of chars to match
	000414	000000G				.word	set$ps			; the command routine's set$ps
	000416	000162'				  .word	std.10			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     42	000006					command setcmd	,PHONE		,2	,set$ph	,std.06
						.list me
						.save
						.list me
	000507					.psect	cmdtxt	,ro,d,lcl,rel,con
	000507	   120 	   110 	   117 		.asciz	#PHONE#			; store the command PHONE
	000420	000507'				.word	$$name			; store set$ph of command PHONE text
	000422	000002 				.word	2			; 2 number of chars to match
	000424	000000G				.word	set$ph			; the command routine's set$ph
	000426	000101'				  .word	std.06			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     43	000006					command setcmd	,PROMPT		,2	,set$pr	,std.21
						.list me
						.save
						.list me
	000515					.psect	cmdtxt	,ro,d,lcl,rel,con
	000515	   120 	   122 	   117 		.asciz	#PROMPT#			; store the command PROMPT
	000430	000515'				.word	$$name			; store set$pr of command PROMPT text
	000432	000002 				.word	2			; 2 number of chars to match
	000434	000000G				.word	set$pr			; the command routine's set$pr
	000436	000446'				  .word	std.21			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     44	000006					command setcmd	,RANDOM		,2	,set$ra	,std.01
						.list me
						.save
						.list me
	000524					.psect	cmdtxt	,ro,d,lcl,rel,con
	000524	   122 	   101 	   116 		.asciz	#RANDOM#			; store the command RANDOM
	000440	000524'				.word	$$name			; store set$ra of command RANDOM text
	000442	000002 				.word	2			; 2 number of chars to match
	000444	000000G				.word	set$ra			; the command routine's set$ra
	000446	000000'				  .word	std.01			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     45	000006					command setcmd	,RECEIVE	,3	,set$rc	,std.06
						.list me
						.save
						.list me
	000533					.psect	cmdtxt	,ro,d,lcl,rel,con
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-8
Define the SET commands

	000533	   122 	   105 	   103 		.asciz	#RECEIVE#			; store the command RECEIVE
	000450	000533'				.word	$$name			; store set$rc of command RECEIVE text
	000452	000003 				.word	3			; 3 number of chars to match
	000454	000000G				.word	set$rc			; the command routine's set$rc
	000456	000101'				  .word	std.06			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     46	000006					command setcmd	,REPEAT-QUOTING	,3	,set$rp	,std.01
						.list me
						.save
						.list me
	000543					.psect	cmdtxt	,ro,d,lcl,rel,con
	000543	   122 	   105 	   120 		.asciz	#REPEAT-QUOTING#			; store the command REPEAT-QUOTING
	000460	000543'				.word	$$name			; store set$rp of command REPEAT-QUOTING text
	000462	000003 				.word	3			; 3 number of chars to match
	000464	000000G				.word	set$rp			; the command routine's set$rp
	000466	000000'				  .word	std.01			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     47	000006					command	setcmd	,RETRY		,3	,set$re	,std.22
						.list me
						.save
						.list me
	000562					.psect	cmdtxt	,ro,d,lcl,rel,con
	000562	   122 	   105 	   124 		.asciz	#RETRY#			; store the command RETRY
	000470	000562'				.word	$$name			; store set$re of command RETRY text
	000472	000003 				.word	3			; 3 number of chars to match
	000474	000000G				.word	set$re			; the command routine's set$re
	000476	000463'				  .word	std.22			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     48	000006					command setcmd	,SEED		,3	,set$se	,std.23
						.list me
						.save
						.list me
	000570					.psect	cmdtxt	,ro,d,lcl,rel,con
	000570	   123 	   105 	   105 		.asciz	#SEED#			; store the command SEED
	000500	000570'				.word	$$name			; store set$se of command SEED text
	000502	000003 				.word	3			; 3 number of chars to match
	000504	000000G				.word	set$se			; the command routine's set$se
	000506	000507'				  .word	std.23			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     49	000006					command	setcmd	,SEND		,3	,set$sn	,std.06
						.list me
						.save
						.list me
	000575					.psect	cmdtxt	,ro,d,lcl,rel,con
	000575	   123 	   105 	   116 		.asciz	#SEND#			; store the command SEND
	000510	000575'				.word	$$name			; store set$sn of command SEND text
	000512	000003 				.word	3			; 3 number of chars to match
	000514	000000G				.word	set$sn			; the command routine's set$sn
	000516	000101'				  .word	std.06			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     50	000006					command setcmd	,SERVER		,3	,set$sv	,std.06
						.list me
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-9
Define the SET commands

						.save
						.list me
	000602					.psect	cmdtxt	,ro,d,lcl,rel,con
	000602	   123 	   105 	   122 		.asciz	#SERVER#			; store the command SERVER
	000520	000602'				.word	$$name			; store set$sv of command SERVER text
	000522	000003 				.word	3			; 3 number of chars to match
	000524	000000G				.word	set$sv			; the command routine's set$sv
	000526	000101'				  .word	std.06			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     51	000006					command setcmd	,SL		,2	,set$sl	,std.24
						.list me
						.save
						.list me
	000611					.psect	cmdtxt	,ro,d,lcl,rel,con
	000611	   123 	   114 	   000 		.asciz	#SL#			; store the command SL
	000530	000611'				.word	$$name			; store set$sl of command SL text
	000532	000002 				.word	2			; 2 number of chars to match
	000534	000000G				.word	set$sl			; the command routine's set$sl
	000536	000534'				  .word	std.24			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     52	000006					command setcmd	,SPEED		,2	,set$sp	,std.02
						.list me
						.save
						.list me
	000614					.psect	cmdtxt	,ro,d,lcl,rel,con
	000614	   123 	   120 	   105 		.asciz	#SPEED#			; store the command SPEED
	000540	000614'				.word	$$name			; store set$sp of command SPEED text
	000542	000002 				.word	2			; 2 number of chars to match
	000544	000000G				.word	set$sp			; the command routine's set$sp
	000546	000012'				  .word	std.02			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     53	000006					command	setcmd	,START-OF-PACKET,2	,set$so	,std.12
						.list me
						.save
						.list me
	000622					.psect	cmdtxt	,ro,d,lcl,rel,con
	000622	   123 	   124 	   101 		.asciz	#START-OF-PACKET#			; store the command START-OF-PACKET
	000550	000622'				.word	$$name			; store set$so of command START-OF-PACKET text
	000552	000002 				.word	2			; 2 number of chars to match
	000554	000000G				.word	set$so			; the command routine's set$so
	000556	000213'				  .word	std.12			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     54	000006					command setcmd	,TERMINAL	,2	,set$tt	,std.16
						.list me
						.save
						.list me
	000642					.psect	cmdtxt	,ro,d,lcl,rel,con
	000642	   124 	   105 	   122 		.asciz	#TERMINAL#			; store the command TERMINAL
	000560	000642'				.word	$$name			; store set$tt of command TERMINAL text
	000562	000002 				.word	2			; 2 number of chars to match
	000564	000000G				.word	set$tt			; the command routine's set$tt
	000566	000321'				  .word	std.16			; /63/ ya, stuff in its location
						.list me
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-10
Define the SET commands

	000006					.restore
     55	000006					command setcmd	,TT:		,2	,set$tt	,std.16
						.list me
						.save
						.list me
	000653					.psect	cmdtxt	,ro,d,lcl,rel,con
	000653	   124 	   124 	   072 		.asciz	#TT:#			; store the command TT:
	000570	000653'				.word	$$name			; store set$tt of command TT: text
	000572	000002 				.word	2			; 2 number of chars to match
	000574	000000G				.word	set$tt			; the command routine's set$tt
	000576	000321'				  .word	std.16			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     56	000006					command setcmd	,UPDATE		,1	,set$up	,std.25
						.list me
						.save
						.list me
	000657					.psect	cmdtxt	,ro,d,lcl,rel,con
	000657	   125 	   120 	   104 		.asciz	#UPDATE#			; store the command UPDATE
	000600	000657'				.word	$$name			; store set$up of command UPDATE text
	000602	000001 				.word	1			; 1 number of chars to match
	000604	000000G				.word	set$up			; the command routine's set$up
	000606	000566'				  .word	std.25			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     57	000006					command	setcmd	,VLSWCH		,1	,set$vl	,std.26
						.list me
						.save
						.list me
	000666					.psect	cmdtxt	,ro,d,lcl,rel,con
	000666	   126 	   114 	   123 		.asciz	#VLSWCH#			; store the command VLSWCH
	000610	000666'				.word	$$name			; store set$vl of command VLSWCH text
	000612	000001 				.word	1			; 1 number of chars to match
	000614	000000G				.word	set$vl			; the command routine's set$vl
	000616	000601'				  .word	std.26			; /63/ ya, stuff in its location
						.list me
	000006					.restore
     58	000006					command	setcmd
						.list me
						.save
						.list me
	000620					.psect	cmddsp	,ro,d,lcl,rel,con ; no, at end of setcmd
	000620	000000 				.word	0			; /62/ mark it with a null
						.list me			; /63/
	000675					.psect	cmdtxt	,ro,d,lcl,rel,con ; /63/ save a few bytes by only
						.even				; /63/ doing this at the end of a setcmd
						.list me
	000006					.restore
     59
     60		000001 				.end
KRTSTD	SET command list overla	MACRO V05.03b  00:01  Page 12-11
Symbol table

ALSIZE= 001000   	FATAL$= 000020   	P.QCTL= 000005   	SET$MO= ****** GX	STD.12  000213R     003
AT.ALL  000177   	FF    = 000014   	P.REPT= 000010   	SET$NU= ****** GX	STD.13  000230R     003
AT.CDT  000001   	JSW   = 000044   	P.SPSI= 000000   	SET$PA= ****** GX	STD.14  000247R     003
AT.INF  000002   	KRTCDF= 000001   	P.TIME= 000001   	SET$PH= ****** GX	STD.15  000277R     003
AT.LEN  000004   	KRTINC= 000001   	P.VEND= 000017   	SET$PR= ****** GX	STD.16  000321R     003
AT.ON   100000   	LF    = 000012   	P.WIND= 000012   	SET$PS= ****** GX	STD.17  000330R     003
AT.PRO  000010   	LN$CNT= 000003   	REP$OF= ****** GX	SET$RA= ****** GX	STD.18  000352R     003
AT.SYS  000020   	LN$MAX= 000120   	SCOLON= 000073   	SET$RC= ****** GX	STD.19  000370R     003
AT.TYP  000040   	LOASET  000000RG    002	SD$OFF= ****** GX	SET$RE= ****** GX	STD.20  000405R     003
AT.XLE  000100   	LOG$AL= 000003   	SETCMD  000000R     005	SET$RP= ****** GX	STD.21  000446R     003
BELL  = 000007   	LOG$CO= 000002   	SET$AT= ****** GX	SET$SE= ****** GX	STD.22  000463R     003
BINARY  000001   	LOG$DE= 000020   	SET$BI= ****** GX	SET$SL= ****** GX	STD.23  000507R     003
BS    = 000010   	LOG$IO= 000010   	SET$BL= ****** GX	SET$SN= ****** GX	STD.24  000534R     003
CAPA.A= 000010   	LOG$ON= 040000   	SET$CL= ****** GX	SET$SO= ****** GX	STD.25  000566R     003
CAPA.L= 000002   	LOG$OP= 100000   	SET$CO= ****** GX	SET$SP= ****** GX	STD.26  000601R     003
CAPA.S= 000004   	LOG$PA= 000001   	SET$CT= ****** GX	SET$SV= ****** GX	ST$NAT= ****** GX
COMMA = 000054   	LOG$RP= 000004   	SET$DE= ****** GX	SET$TT= ****** GX	ST$NLP= ****** GX
CON$ES= 000034   	MAXLNG= 001130   	SET$DI= ****** GX	SET$UP= ****** GX	SUCCS$= 000001
CR    = 000015   	MAXPAK  000136   	SET$DL= ****** GX	SET$VL= ****** GX	TAB   = 000011
CTRL$N= 000016   	NONEIS= 000001   	SET$DT= ****** GX	SEVER$= 000010   	TERMIN  177777
CTRL$O= 000017   	NOSCOP= 000000   	SET$DU= ****** GX	SOH   = 000001   	TEXT    000000
C$CWD = ****** GX	PAR$EV  000002   	SET$EF= ****** GX	SPACE = 000040   	TILDE = 000176
C.CRLF= 000004   	PAR$MA  000003   	SET$EO= ****** GX	STD.01  000000R     003	TTY   = 000001
C.LCUC= 000040   	PAR$NO  000000   	SET$ES= ****** GX	STD.02  000012R     003	USERRB= 000053
C.LSPA= 000010   	PAR$OD  000001   	SET$FI= ****** GX	STD.03  000022R     003	VT100 = 000002
C.SSPA= 000020   	PAR$SP  000004   	SET$HA= ****** GX	STD.04  000036R     003	VT200 = 000003
C.TSPA= 000200   	P.CAPA= 000011   	SET$HO= ****** GX	STD.05  000052R     003	WARN$ = 000002
DECNAT  000002   	P.CHKT= 000007   	SET$IN= ****** GX	STD.06  000101R     003	XOFF  = 000023
DEL   = 000177   	P.EOL = 000004   	SET$KM= ****** GX	STD.07  000112R     003	XON   = 000021
DOT   = 000056   	P.MXL1= 000013   	SET$LC= ****** GX	STD.08  000137R     003	$ALLSI= 001144
ERBFSI= 000170   	P.MXL2= 000014   	SET$LD= ****** GX	STD.09  000146R     003	$LISTL= 000004 G
ERRBYT= 000052   	P.NPAD= 000002   	SET$LI= ****** GX	STD.10  000162R     003	$$NAME= 000666R     004
ERROR$= 000004   	P.PADC= 000003   	SET$LO= ****** GX	STD.11  000174R     003	$$TRIP= 000000
ESC   = 000033   	P.QBIN= 000006   	SET$LP= ****** GX

. ABS.	000000    000	(RW,I,GBL,ABS,OVR)
      	000000    001	(RW,I,LCL,REL,CON)
$CODE 	000006    002	(RO,I,LCL,REL,CON)
$PDATA	000624    003	(RO,D,LCL,REL,CON)
CMDTXT	000676    004	(RO,D,LCL,REL,CON)
CMDDSP	000622    005	(RO,D,LCL,REL,CON)
Errors detected:  0

*** Assembler statistics


Work  file  reads: 0
Work  file writes: 1
Size of work file: 12641 Words  ( 50 Pages)
Size of core pool: 12544 Words  ( 49 Pages)
Operating  system: RT-11

Elapsed time: 00:00:00.26
KRTSTD,KRTSTD=KRTNHD,KRTSTD
